<!DOCTYPE html>
<!--
ТЕХНИЧЕСКОЕ ЗАДАНИЕ

Цель: Создать систему рекомендаций сериалов с использованием Cosine Similarity.

Функциональные требования:
1. База данных сериалов из API
2. Пользователь оценивает 5-10 сериалов по шкале 1-5
3. Расчёт схожести через cosine similarity (dot product)
4. Топ-10 рекомендаций с постерами
5. Поддержка темной/светлой темы
6. Адаптивный дизайн
7. Многоязычность (русский/английский)

Технические требования:
1. Vanilla JavaScript без фреймворков
2. TVMaze API для списка сериалов (без ключа)
3. Локальное хранение оценок в localStorage
4. CSS Grid и Flexbox для верстки
5. Анимации и переходы
-->
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="AI-система рекомендаций сериалов на основе Cosine Similarity">
  <title>Show Recommender | Рекомендации сериалов</title>
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #e50914;
      --primary-dark: #b20710;
      --secondary-color: #141414;
      --accent-color: #f5c518;
      --text-color: #ffffff;
      --text-secondary: #b3b3b3;
      --bg-color: #141414;
      --card-bg: #1f1f1f;
      --card-hover: #2a2a2a;
      --border-color: #333333;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      --gradient: linear-gradient(135deg, #e50914 0%, #b20710 100%);
      --star-color: #f5c518;
      --star-empty: #555555;
    }

    [data-theme="light"] {
      --primary-color: #e50914;
      --primary-dark: #b20710;
      --secondary-color: #f5f5f5;
      --text-color: #141414;
      --text-secondary: #666666;
      --bg-color: #f5f5f5;
      --card-bg: #ffffff;
      --card-hover: #f0f0f0;
      --border-color: #e0e0e0;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      --star-empty: #cccccc;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, Roboto, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      transition: background-color 0.3s, color 0.3s;
    }

    /* Header */
    .header {
      background: var(--gradient);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: var(--shadow);
    }

    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      color: white;
      text-decoration: none;
    }

    .logo i {
      font-size: 2rem;
    }

    .logo-text {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.3s;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Main Container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    /* Progress Bar */
    .progress-section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      box-shadow: var(--shadow);
    }

    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
    }

    .progress-title {
      font-size: 1.2rem;
      font-weight: 600;
    }

    .progress-count {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    .progress-bar {
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: var(--gradient);
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .progress-hint {
      color: var(--text-secondary);
      font-size: 0.85rem;
      margin-top: 0.75rem;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: var(--card-bg);
      border: 2px solid var(--border-color);
      color: var(--text-color);
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab-btn:hover {
      border-color: var(--primary-color);
    }

    .tab-btn.active {
      background: var(--primary-color);
      border-color: var(--primary-color);
      color: white;
    }

    /* Search and Filter */
    .search-filter {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .search-box {
      flex: 1;
      min-width: 250px;
      position: relative;
    }

    .search-box input {
      width: 100%;
      padding: 0.75rem 1rem 0.75rem 2.75rem;
      border: 2px solid var(--border-color);
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      font-size: 1rem;
      transition: border-color 0.3s;
    }

    .search-box input:focus {
      outline: none;
      border-color: var(--primary-color);
    }

    .search-box i {
      position: absolute;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
    }

    .genre-filter {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .year-filter {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .year-label,
    .year-separator {
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .year-filter select {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      font-size: 0.85rem;
      transition: border-color 0.3s;
      min-width: 120px;
    }

    .year-filter select:focus {
      outline: none;
      border-color: var(--primary-color);
    }

    .genre-btn {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s;
    }

    .genre-btn:hover,
    .genre-btn.active {
      background: var(--primary-color);
      border-color: var(--primary-color);
      color: white;
    }

    /* Movies Grid */
    .movies-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1.5rem;
    }

    .movie-card {
      background: var(--card-bg);
      border-radius: 12px;
      overflow: hidden;
      transition: transform 0.3s, box-shadow 0.3s;
      cursor: pointer;
      position: relative;
    }

    .movie-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .movie-card.rated {
      border: 3px solid var(--accent-color);
    }

    .movie-poster {
      width: 100%;
      aspect-ratio: 2/3;
      object-fit: cover;
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .movie-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .movie-poster .placeholder {
      color: var(--text-secondary);
      font-size: 3rem;
    }

    .movie-poster .placeholder-text {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, var(--card-bg) 0%, #1a1a2e 100%);
      padding: 1rem;
      box-sizing: border-box;
      text-align: center;
    }

    .movie-poster .placeholder-text .title {
      color: var(--text-color);
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
      max-height: 80%;
      overflow: hidden;
    }

    .movie-poster .placeholder-text .icon {
      color: var(--primary-color);
      font-size: 2rem;
      margin-bottom: 0.5rem;
      opacity: 0.7;
    }

    .movie-info {
      padding: 1rem;
    }

    .movie-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .movie-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text-secondary);
      font-size: 0.85rem;
      margin-bottom: 0.5rem;
    }

    .movie-genres {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .genre-tag {
      background: var(--border-color);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    .user-rating {
      display: flex;
      justify-content: center;
      gap: 0.25rem;
      padding: 0.75rem;
      background: rgba(0, 0, 0, 0.3);
    }

    .star {
      font-size: 1.25rem;
      color: var(--star-empty);
      cursor: pointer;
      transition: color 0.2s, transform 0.2s;
    }

    .star:hover,
    .star.active {
      color: var(--star-color);
      transform: scale(1.2);
    }

    .star.hovered {
      color: var(--star-color);
    }

    /* Recommendations Section */
    .recommendations-section {
      margin-top: 3rem;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .section-title i {
      color: var(--primary-color);
    }

    .get-recommendations-btn {
      background: var(--gradient);
      border: none;
      color: white;
      padding: 1rem 2rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .get-recommendations-btn:hover:not(:disabled) {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(229, 9, 20, 0.4);
    }

    .get-recommendations-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Recommendation Cards */
    .recommendation-card {
      background: var(--card-bg);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      gap: 1rem;
      padding: 1rem;
      margin-bottom: 1rem;
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .recommendation-card:hover {
      transform: translateX(8px);
      box-shadow: var(--shadow);
    }

    .recommendation-rank {
      font-size: 2rem;
      font-weight: 800;
      color: var(--primary-color);
      min-width: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .recommendation-poster {
      width: 80px;
      height: 120px;
      border-radius: 8px;
      overflow: hidden;
      flex-shrink: 0;
    }

    .recommendation-poster img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .recommendation-poster .placeholder-text {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--card-bg) 0%, #1a1a2e 100%);
      padding: 0.5rem;
      box-sizing: border-box;
    }

    .recommendation-poster .placeholder-text .icon {
      font-size: 1.2rem;
      margin-bottom: 0.25rem;
    }

    .recommendation-poster .placeholder-text .title {
      font-size: 0.6rem;
      line-height: 1.2;
      text-align: center;
      overflow: hidden;
      max-height: 60%;
    }

    .recommendation-details {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .recommendation-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .recommendation-meta {
      color: var(--text-secondary);
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    .similarity-score {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .similarity-bar {
      flex: 1;
      max-width: 200px;
      height: 8px;
      background: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .similarity-fill {
      height: 100%;
      background: var(--gradient);
      border-radius: 4px;
    }

    .similarity-value {
      font-weight: 600;
      color: var(--primary-color);
      min-width: 50px;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 4rem 2rem;
      color: var(--text-secondary);
    }

    .empty-state i {
      font-size: 4rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .empty-state h3 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      color: var(--text-color);
    }

    /* Modal */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--card-bg);
      border-radius: 16px;
      max-width: 800px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }

    .modal-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(0, 0, 0, 0.5);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.25rem;
      z-index: 10;
      transition: background 0.3s;
    }

    .modal-close:hover {
      background: var(--primary-color);
    }

    .modal-content {
      display: flex;
      gap: 2rem;
      padding: 2rem;
    }

    .modal-poster {
      width: 250px;
      flex-shrink: 0;
      border-radius: 12px;
      overflow: hidden;
    }

    .modal-poster img {
      width: 100%;
      aspect-ratio: 2/3;
      object-fit: cover;
    }

    .modal-poster .placeholder-text {
      width: 100%;
      aspect-ratio: 2/3;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--card-bg) 0%, #1a1a2e 100%);
      padding: 1.5rem;
      box-sizing: border-box;
    }

    .modal-poster .placeholder-text .icon {
      font-size: 3rem;
      margin-bottom: 1rem;
    }

    .modal-poster .placeholder-text .title {
      font-size: 1.1rem;
      font-weight: 600;
      text-align: center;
      line-height: 1.3;
    }

    .modal-info {
      flex: 1;
    }

    .modal-title {
      font-size: 1.75rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .modal-meta {
      color: var(--text-secondary);
      margin-bottom: 1rem;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .modal-description {
      line-height: 1.6;
      margin-bottom: 1.5rem;
      color: var(--text-secondary);
    }

    .modal-genres {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .modal-genre-tag {
      background: var(--primary-color);
      color: white;
      padding: 0.4rem 1rem;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .modal-rating {
      margin-top: 1.5rem;
    }

    .modal-rating-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }

    .modal-stars {
      display: flex;
      gap: 0.5rem;
    }

    .modal-stars .star {
      font-size: 2rem;
    }

    /* Loading */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid var(--border-color);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        text-align: center;
      }

      .movies-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1rem;
      }

      .modal-content {
        flex-direction: column;
        padding: 1.5rem;
      }

      .modal-poster {
        width: 100%;
        max-width: 250px;
        margin: 0 auto;
      }

      .recommendation-card {
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .search-filter {
        flex-direction: column;
      }
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .movie-card {
      animation: fadeIn 0.5s ease forwards;
    }

    .recommendation-card {
      animation: fadeIn 0.5s ease forwards;
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="header-content">
      <a href="#" class="logo">
        <i class="fas fa-film"></i>
        <span class="logo-text" data-i18n="logo">Show Recommender</span>
      </a>
      <div class="header-controls">
        <button class="control-btn" id="resetBtn" title="Сбросить оценки">
          <i class="fas fa-redo"></i>
          <span data-i18n="reset">Сбросить</span>
        </button>
        <button class="control-btn" id="themeBtn">
          <i class="fas fa-moon"></i>
        </button>
        <button class="control-btn" id="langBtn">
          <i class="fas fa-globe"></i>
          <span>RU</span>
        </button>
      </div>
    </div>
  </header>

  <main class="container">
    <!-- Progress Section -->
    <section class="progress-section">
      <div class="progress-header">
        <h2 class="progress-title" data-i18n="progressTitle">Прогресс оценки</h2>
        <span class="progress-count"><span id="ratedCount">0</span> / <span id="minRatings">5</span></span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
      <p class="progress-hint" data-i18n="progressHint">
        Оцените минимум 5 сериалов, чтобы получить персональные рекомендации
      </p>
    </section>

    <!-- Tabs -->
    <div class="tabs">
      <button class="tab-btn active" data-tab="rate">
        <i class="fas fa-star"></i>
        <span data-i18n="tabRate">Оценить сериалы</span>
      </button>
      <button class="tab-btn" data-tab="recommendations">
        <i class="fas fa-magic"></i>
        <span data-i18n="tabRecommendations">Рекомендации</span>
      </button>
      <button class="tab-btn" data-tab="rated">
        <i class="fas fa-check-circle"></i>
        <span data-i18n="tabRated">Оценённые</span>
      </button>
    </div>

    <!-- Rate Tab -->
    <div id="rateTab" class="tab-content">
      <div class="search-filter">
        <div class="search-box">
          <i class="fas fa-search"></i>
          <input type="text" id="searchInput" data-i18n-placeholder="searchPlaceholder"
                 placeholder="Поиск сериалов...">
        </div>
        <div class="genre-filter" id="genreFilter"></div>
        <div class="year-filter">
          <span class="year-label" data-i18n="yearLabel">Год</span>
          <select id="yearFrom" aria-label="Год от"></select>
          <span class="year-separator">—</span>
          <select id="yearTo" aria-label="Год до"></select>
        </div>
      </div>
      <div class="movies-grid" id="moviesGrid"></div>
    </div>

    <!-- Recommendations Tab -->
    <div id="recommendationsTab" class="tab-content" style="display: none;">
      <div class="section-header">
        <h2 class="section-title">
          <i class="fas fa-wand-magic-sparkles"></i>
          <span data-i18n="recommendationsTitle">Ваши рекомендации</span>
        </h2>
        <button class="get-recommendations-btn" id="getRecsBtn">
          <i class="fas fa-sparkles"></i>
          <span data-i18n="getRecommendations">Получить рекомендации</span>
        </button>
      </div>
      <div id="recommendationsList"></div>
    </div>

    <!-- Rated Tab -->
    <div id="ratedTab" class="tab-content" style="display: none;">
      <div class="movies-grid" id="ratedGrid"></div>
    </div>
  </main>

  <!-- Movie Modal -->
  <div class="modal-overlay" id="movieModal">
    <div class="modal">
      <button class="modal-close" id="modalClose">
        <i class="fas fa-times"></i>
      </button>
      <div class="modal-content" id="modalContent"></div>
    </div>
  </div>

  <script>
    /**
     * Show Recommender Application
     * Использует Cosine Similarity для персональных рекомендаций
     */

    // База данных сериалов из TVMaze
    let MOVIES_DATABASE = [];

    // Все уникальные жанры
    let ALL_GENRES = [...new Set(MOVIES_DATABASE.flatMap(m => m.genres || []))].sort();

    const TVMAZE_API_BASE = "https://api.tvmaze.com/shows?page=";
    const TVMAZE_CACHE_KEY = "tvmazeShowsCache";
    const TVMAZE_CACHE_VERSION = 4;
    const TVMAZE_CACHE_TTL_MS = 6 * 60 * 60 * 1000;
    const TVMAZE_MAX_PAGE_PROBE = 512;
    const TVMAZE_RECENT_PAGES = 2;
    const GENRE_MAP = {
      "science-fiction": "sci-fi",
      "science fiction": "sci-fi",
      "sci-fi": "sci-fi",
      "sci fi": "sci-fi",
      "sports": "sport",
      "sport": "sport",
      "children": "family",
      "anime": "animation"
    };

    function normalizeGenre(genre) {
      if (!genre) return null;
      const normalized = genre.toLowerCase().trim();
      const slug = normalized.replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
      return GENRE_MAP[normalized] || GENRE_MAP[slug] || slug;
    }

    function slugifyTag(value) {
      if (!value) return null;
      return value
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
    }

    function mapShowToMovie(show) {
      const genres = (show.genres || [])
        .map(normalizeGenre)
        .filter(Boolean);
      const tags = [
        ...genres,
        show.type,
        show.language,
        show.status,
        show.network && show.network.name,
        show.webChannel && show.webChannel.name
      ]
        .map(slugifyTag)
        .filter(Boolean);

      return {
        id: show.id,
        title: show.name,
        titleRu: show.name,
        year: show.premiered ? show.premiered.slice(0, 4) : "—",
        premiered: show.premiered || "",
        genres,
        tags: tags.length ? tags : ["tv"],
        rating: typeof show.rating?.average === "number" ? show.rating.average : null,
        posterUrl: show.image?.medium || show.image?.original || ""
      };
    }

    function getPosterUrl(movie) {
      if (movie.posterUrl) return movie.posterUrl;
      return "";
    }

    function hasPoster(movie) {
      return Boolean(movie.posterUrl);
    }

    function renderPosterContent(movie, title) {
      const safeTitle = title.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
      if (hasPoster(movie)) {
        return `<img src="${movie.posterUrl}"
                     alt="${safeTitle}"
                     data-title="${safeTitle}"
                     onerror="handlePosterError(this)"
                     loading="lazy">`;
      }
      return `<div class="placeholder-text">
                <i class="fas fa-film icon"></i>
                <span class="title">${safeTitle}</span>
              </div>`;
    }

    function handlePosterError(img) {
      const title = img.getAttribute("data-title") || "";
      img.parentElement.innerHTML = '<div class="placeholder-text"><i class="fas fa-film icon"></i><span class="title">' + title + '</span></div>';
    }

    function formatRating(value) {
      const parsed = typeof value === "number" ? value : parseFloat(value);
      return Number.isFinite(parsed) && parsed > 0 ? parsed.toFixed(1) : "—";
    }

    function getReleaseTimestamp(movie) {
      if (movie.premiered) {
        const dateValue = Date.parse(movie.premiered);
        if (!Number.isNaN(dateValue)) {
          return dateValue;
        }
      }
      const yearValue = parseInt(movie.year, 10);
      if (Number.isFinite(yearValue)) {
        return Date.UTC(yearValue, 0, 1);
      }
      return 0;
    }

    function getRatedCount() {
      return MOVIES_DATABASE.reduce((count, movie) => {
        return count + (userRatings[movie.id] ? 1 : 0);
      }, 0);
    }

    function syncRatings() {
      const validIds = new Set(MOVIES_DATABASE.map(movie => movie.id));
      const cleaned = {};
      Object.entries(userRatings).forEach(([movieId, rating]) => {
        if (validIds.has(parseInt(movieId, 10))) {
          cleaned[movieId] = rating;
        }
      });
      if (Object.keys(cleaned).length !== Object.keys(userRatings).length) {
        userRatings = cleaned;
        localStorage.setItem("movieRatings", JSON.stringify(userRatings));
      }
    }

    function readShowsCache(allowStale = false) {
      try {
        const raw = localStorage.getItem(TVMAZE_CACHE_KEY);
        if (!raw) return null;
        const cached = JSON.parse(raw);
        if (!cached || cached.version !== TVMAZE_CACHE_VERSION) return null;
        if (!Array.isArray(cached.data) || typeof cached.timestamp !== "number") return null;
        if (!allowStale && Date.now() - cached.timestamp > TVMAZE_CACHE_TTL_MS) return null;
        return cached.data;
      } catch (error) {
        console.warn("Failed to read TVMaze cache.", error);
        return null;
      }
    }

    function writeShowsCache(data) {
      try {
        const payload = {
          version: TVMAZE_CACHE_VERSION,
          timestamp: Date.now(),
          data
        };
        localStorage.setItem(TVMAZE_CACHE_KEY, JSON.stringify(payload));
      } catch (error) {
        console.warn("Failed to write TVMaze cache.", error);
      }
    }

    function applyShowsData(movies) {
      if (!Array.isArray(movies) || movies.length === 0) return;
      MOVIES_DATABASE = movies;
      ALL_GENRES = [...new Set(MOVIES_DATABASE.flatMap(m => m.genres || []))].sort();

      if (currentGenreFilter && !ALL_GENRES.includes(currentGenreFilter)) {
        currentGenreFilter = null;
      }

      syncRatings();
      renderGenreFilter();
      renderYearFilter();
      renderMovies();
      updateProgress();

      const activeTab = document.querySelector(".tab-btn.active")?.dataset.tab;
      if (activeTab === "rated") {
        renderRatedMovies();
      } else if (activeTab === "recommendations") {
        getRecommendations();
      }
    }

    async function fetchShowsPage(page) {
      try {
        const response = await fetch(`${TVMAZE_API_BASE}${page}`);
        if (!response.ok) return null;
        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) return null;
        return data;
      } catch (error) {
        return null;
      }
    }

    async function findLastPage() {
      let lowPage = 0;
      let lowData = null;
      let highPage = 1;

      let data = await fetchShowsPage(highPage);
      if (!data) {
        return null;
      }

      lowPage = highPage;
      lowData = data;

      while (highPage < TVMAZE_MAX_PAGE_PROBE) {
        highPage *= 2;
        data = await fetchShowsPage(highPage);
        if (data) {
          lowPage = highPage;
          lowData = data;
        } else {
          break;
        }
      }

      if (highPage >= TVMAZE_MAX_PAGE_PROBE && data) {
        return { page: lowPage, data: lowData };
      }

      let left = lowPage + 1;
      let right = highPage - 1;

      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        const midData = await fetchShowsPage(mid);
        if (midData) {
          lowPage = mid;
          lowData = midData;
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }

      return lowData ? { page: lowPage, data: lowData } : null;
    }

    async function loadShows() {
      const cached = readShowsCache();
      if (cached) {
        applyShowsData(cached);
        return;
      }

      try {
        const lastPageResult = await findLastPage();
        if (!lastPageResult) {
          throw new Error("Failed to locate latest TVMaze page.");
        }

        const { page: lastPage, data: lastPageData } = lastPageResult;
        const collected = [];

        if (lastPageData) {
          collected.push(...lastPageData);
        }

        const startPage = Math.max(0, lastPage - (TVMAZE_RECENT_PAGES - 1));
        for (let page = lastPage - 1; page >= startPage; page--) {
          const pageData = await fetchShowsPage(page);
          if (pageData) {
            collected.push(...pageData);
          }
        }

        const mapped = collected.map(mapShowToMovie).filter(movie => movie.title);
        const deduped = Array.from(new Map(mapped.map(movie => [movie.id, movie])).values());

        if (deduped.length > 0) {
          writeShowsCache(deduped);
          applyShowsData(deduped);
        }
      } catch (error) {
        const stale = readShowsCache(true);
        if (stale) {
          applyShowsData(stale);
        }
        console.warn("Failed to load TVMaze shows, using cached/fallback list.", error);
      }
    }

    // Переводы
    const translations = {
      ru: {
        logo: "Рекомендатор сериалов",
        reset: "Сбросить",
        progressTitle: "Прогресс оценки",
        progressHint: "Оцените минимум 5 сериалов, чтобы получить персональные рекомендации",
        tabRate: "Оценить сериалы",
        tabRecommendations: "Рекомендации",
        tabRated: "Оценённые",
        searchPlaceholder: "Поиск сериалов...",
        yearLabel: "Год",
        yearFrom: "Год от",
        yearTo: "Год до",
        noResultsTitle: "Сериалы не найдены",
        noResultsHint: "Попробуйте изменить параметры поиска",
        recommendationsTitle: "Ваши рекомендации",
        getRecommendations: "Получить рекомендации",
        emptyRated: "Вы ещё не оценили ни одного сериала",
        emptyRatedHint: "Перейдите на вкладку \"Оценить сериалы\" и поставьте оценки",
        emptyRecommendations: "Недостаточно оценок",
        emptyRecommendationsHint: "Оцените минимум 5 сериалов для получения рекомендаций",
        similarity: "Совместимость",
        rateMovie: "Оцените сериал",
        yourRating: "Ваша оценка",
        tagsLabel: "Теги",
        allGenres: "Все",
        genres: {
          action: "Боевик",
          adventure: "Приключения",
          animation: "Анимация",
          biography: "Биография",
          comedy: "Комедия",
          crime: "Криминал",
          drama: "Драма",
          family: "Семейный",
          fantasy: "Фэнтези",
          history: "Исторический",
          horror: "Ужасы",
          music: "Музыкальный",
          mystery: "Детектив",
          romance: "Романтика",
          "sci-fi": "Фантастика",
          sport: "Спорт",
          thriller: "Триллер",
          war: "Военный",
          western: "Вестерн"
        }
      },
      en: {
        logo: "Show Recommender",
        reset: "Reset",
        progressTitle: "Rating Progress",
        progressHint: "Rate at least 5 shows to get personalized recommendations",
        tabRate: "Rate Shows",
        tabRecommendations: "Recommendations",
        tabRated: "Rated",
        searchPlaceholder: "Search shows...",
        yearLabel: "Year",
        yearFrom: "Year from",
        yearTo: "Year to",
        noResultsTitle: "No shows found",
        noResultsHint: "Try adjusting your search",
        recommendationsTitle: "Your Recommendations",
        getRecommendations: "Get Recommendations",
        emptyRated: "You haven't rated any shows yet",
        emptyRatedHint: "Go to 'Rate Shows' tab and rate some shows",
        emptyRecommendations: "Not enough ratings",
        emptyRecommendationsHint: "Rate at least 5 shows to get recommendations",
        similarity: "Match",
        rateMovie: "Rate this show",
        yourRating: "Your rating",
        tagsLabel: "Tags",
        allGenres: "All",
        genres: {
          action: "Action",
          adventure: "Adventure",
          animation: "Animation",
          biography: "Biography",
          comedy: "Comedy",
          crime: "Crime",
          drama: "Drama",
          family: "Family",
          fantasy: "Fantasy",
          history: "History",
          horror: "Horror",
          music: "Music",
          mystery: "Mystery",
          romance: "Romance",
          "sci-fi": "Sci-Fi",
          sport: "Sport",
          thriller: "Thriller",
          war: "War",
          western: "Western"
        }
      }
    };

    // Состояние приложения
    let currentLang = localStorage.getItem("movieRecLang") || "ru";
    let currentTheme = localStorage.getItem("movieRecTheme") || "dark";
    let userRatings = JSON.parse(localStorage.getItem("movieRatings") || "{}");
    let currentGenreFilter = null;
    let currentSearchQuery = "";
    let currentYearFrom = localStorage.getItem("showYearFrom") || "";
    let currentYearTo = localStorage.getItem("showYearTo") || "";

    /**
     * Инициализация приложения
     */
    function init() {
      applyTheme();
      applyLanguage();
      renderGenreFilter();
      renderYearFilter();
      renderMovies();
      updateProgress();
      setupEventListeners();
      loadShows();
    }

    /**
     * Применение темы
     */
    function applyTheme() {
      document.body.setAttribute("data-theme", currentTheme);
      const icon = document.querySelector("#themeBtn i");
      icon.className = currentTheme === "dark" ? "fas fa-sun" : "fas fa-moon";
    }

    /**
     * Применение языка
     */
    function applyLanguage() {
      const t = translations[currentLang];

      document.querySelectorAll("[data-i18n]").forEach(el => {
        const key = el.dataset.i18n;
        if (t[key]) el.textContent = t[key];
      });

      document.querySelectorAll("[data-i18n-placeholder]").forEach(el => {
        const key = el.dataset.i18nPlaceholder;
        if (t[key]) el.placeholder = t[key];
      });

      document.querySelector("#langBtn span").textContent = currentLang.toUpperCase();
    }

    /**
     * Отрисовка фильтра жанров
     */
    function renderGenreFilter() {
      const container = document.getElementById("genreFilter");
      const t = translations[currentLang];

      let html = `<button class="genre-btn ${!currentGenreFilter ? 'active' : ''}"
                          data-genre="">${t.allGenres}</button>`;

      ALL_GENRES.forEach(genre => {
        const genreName = t.genres[genre] || genre;
        html += `<button class="genre-btn ${currentGenreFilter === genre ? 'active' : ''}"
                         data-genre="${genre}">${genreName}</button>`;
      });

      container.innerHTML = html;
    }

    function persistYearFilters() {
      if (currentYearFrom) {
        localStorage.setItem("showYearFrom", currentYearFrom);
      } else {
        localStorage.removeItem("showYearFrom");
      }

      if (currentYearTo) {
        localStorage.setItem("showYearTo", currentYearTo);
      } else {
        localStorage.removeItem("showYearTo");
      }
    }

    function getAvailableYears() {
      const years = new Set();
      MOVIES_DATABASE.forEach(movie => {
        const yearValue = parseInt(movie.year, 10);
        if (Number.isFinite(yearValue)) {
          years.add(yearValue);
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }

    function renderYearFilter() {
      const fromSelect = document.getElementById("yearFrom");
      const toSelect = document.getElementById("yearTo");
      if (!fromSelect || !toSelect) return;

      const t = translations[currentLang];
      const years = getAvailableYears();
      const fromValue = parseInt(currentYearFrom, 10);
      const toValue = parseInt(currentYearTo, 10);

      if (Number.isFinite(fromValue) && !years.includes(fromValue)) {
        years.push(fromValue);
      }
      if (Number.isFinite(toValue) && !years.includes(toValue)) {
        years.push(toValue);
      }

      years.sort((a, b) => b - a);

      currentYearFrom = Number.isFinite(fromValue) ? String(fromValue) : "";
      currentYearTo = Number.isFinite(toValue) ? String(toValue) : "";

      if (currentYearFrom && currentYearTo && parseInt(currentYearFrom, 10) > parseInt(currentYearTo, 10)) {
        currentYearTo = currentYearFrom;
      }

      fromSelect.innerHTML = [
        `<option value="">${t.yearFrom}</option>`,
        ...years.map(year => `<option value="${year}">${year}</option>`)
      ].join("");

      toSelect.innerHTML = [
        `<option value="">${t.yearTo}</option>`,
        ...years.map(year => `<option value="${year}">${year}</option>`)
      ].join("");

      fromSelect.value = currentYearFrom;
      toSelect.value = currentYearTo;

      fromSelect.disabled = years.length === 0;
      toSelect.disabled = years.length === 0;
      fromSelect.setAttribute("aria-label", t.yearFrom);
      toSelect.setAttribute("aria-label", t.yearTo);

      persistYearFilters();
    }

    /**
     * Получить отфильтрованные фильмы
     */
    function getFilteredMovies() {
      return MOVIES_DATABASE.filter(movie => {
        // Фильтр по жанру
        if (currentGenreFilter && !(movie.genres || []).includes(currentGenreFilter)) {
          return false;
        }

        // Фильтр по поиску
        if (currentSearchQuery) {
          const query = currentSearchQuery.toLowerCase();
          const title = (currentLang === "ru" ? (movie.titleRu || movie.title) : movie.title).toLowerCase();
          const tags = (movie.tags || []).join(" ").toLowerCase();
          const genres = (movie.genres || []).join(" ").toLowerCase();

          if (!title.includes(query) && !tags.includes(query) && !genres.includes(query)) {
            return false;
          }
        }

        if (currentYearFrom || currentYearTo) {
          const yearValue = parseInt(movie.year, 10);
          if (!Number.isFinite(yearValue)) {
            return false;
          }
          if (currentYearFrom && yearValue < parseInt(currentYearFrom, 10)) {
            return false;
          }
          if (currentYearTo && yearValue > parseInt(currentYearTo, 10)) {
            return false;
          }
        }

        return true;
      });
    }

    /**
     * Отрисовка карточек фильмовc
     */
    function renderMovies() {
      const container = document.getElementById("moviesGrid");
      const movies = getFilteredMovies()
        .slice()
        .sort((a, b) => getReleaseTimestamp(b) - getReleaseTimestamp(a));
      const t = translations[currentLang];

      if (movies.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="grid-column: 1/-1;">
            <i class="fas fa-film"></i>
            <h3>${t.noResultsTitle}</h3>
            <p>${t.noResultsHint}</p>
          </div>
        `;
        return;
      }

      container.innerHTML = movies.map((movie, index) => {
        const title = currentLang === "ru" ? (movie.titleRu || movie.title) : movie.title;
        const rating = userRatings[movie.id] || 0;
        const displayRating = formatRating(movie.rating);

        return `
          <div class="movie-card ${rating > 0 ? 'rated' : ''}"
               data-id="${movie.id}"
               style="animation-delay: ${index * 0.05}s">
            <div class="movie-poster" onclick="openModal(${movie.id})">
              ${renderPosterContent(movie, title)}
            </div>
            <div class="movie-info">
              <h3 class="movie-title" onclick="openModal(${movie.id})">${title}</h3>
              <div class="movie-meta">
                <span>${movie.year}</span>
                <span>★ ${displayRating}</span>
              </div>
              <div class="movie-genres">
                ${movie.genres.slice(0, 2).map(g =>
                  `<span class="genre-tag">${t.genres[g] || g}</span>`
                ).join("")}
              </div>
            </div>
            <div class="user-rating">
              ${[1,2,3,4,5].map(star => `
                <span class="star ${star <= rating ? 'active' : ''}"
                      data-movie="${movie.id}"
                      data-star="${star}">★</span>
              `).join("")}
            </div>
          </div>
        `;
      }).join("");
    }

    /**
     * Отрисовка оценённых фильмов
     */
    function renderRatedMovies() {
      const container = document.getElementById("ratedGrid");
      const t = translations[currentLang];

      const ratedMovies = MOVIES_DATABASE.filter(m => userRatings[m.id] > 0)
        .sort((a, b) => userRatings[b.id] - userRatings[a.id]);

      if (ratedMovies.length === 0) {
        container.innerHTML = `
          <div class="empty-state" style="grid-column: 1/-1;">
            <i class="fas fa-star"></i>
            <h3>${t.emptyRated}</h3>
            <p>${t.emptyRatedHint}</p>
          </div>
        `;
        return;
      }

      container.innerHTML = ratedMovies.map((movie, index) => {
        const title = currentLang === "ru" ? (movie.titleRu || movie.title) : movie.title;
        const rating = userRatings[movie.id];
        const displayRating = formatRating(movie.rating);

        return `
          <div class="movie-card rated"
               data-id="${movie.id}"
               style="animation-delay: ${index * 0.05}s">
            <div class="movie-poster" onclick="openModal(${movie.id})">
              ${renderPosterContent(movie, title)}
            </div>
            <div class="movie-info">
              <h3 class="movie-title" onclick="openModal(${movie.id})">${title}</h3>
              <div class="movie-meta">
                <span>${movie.year}</span>
                <span>★ ${displayRating}</span>
              </div>
              <div class="movie-genres">
                ${movie.genres.slice(0, 2).map(g =>
                  `<span class="genre-tag">${t.genres[g] || g}</span>`
                ).join("")}
              </div>
            </div>
            <div class="user-rating">
              ${[1,2,3,4,5].map(star => `
                <span class="star ${star <= rating ? 'active' : ''}"
                      data-movie="${movie.id}"
                      data-star="${star}">★</span>
              `).join("")}
            </div>
          </div>
        `;
      }).join("");
    }

    /**
     * Создание вектора признаков для фильма
     * Использует жанры и теги как признаки
     */
    function createFeatureVector(movie) {
      const allTags = [...new Set(MOVIES_DATABASE.flatMap(m => [...(m.genres || []), ...(m.tags || [])]))];
      const vector = new Array(allTags.length).fill(0);

      [...(movie.genres || []), ...(movie.tags || [])].forEach(feature => {
        const idx = allTags.indexOf(feature);
        if (idx !== -1) {
          vector[idx] = 1;
        }
      });

      return vector;
    }

    /**
     * Cosine Similarity через dot product
     */
    function cosineSimilarity(vecA, vecB) {
      let dotProduct = 0;
      let magnitudeA = 0;
      let magnitudeB = 0;

      for (let i = 0; i < vecA.length; i++) {
        dotProduct += vecA[i] * vecB[i];
        magnitudeA += vecA[i] * vecA[i];
        magnitudeB += vecB[i] * vecB[i];
      }

      magnitudeA = Math.sqrt(magnitudeA);
      magnitudeB = Math.sqrt(magnitudeB);

      if (magnitudeA === 0 || magnitudeB === 0) return 0;

      return dotProduct / (magnitudeA * magnitudeB);
    }

    /**
     * Создание профиля пользователя на основе оценок
     */
    function createUserProfile() {
      const allTags = [...new Set(MOVIES_DATABASE.flatMap(m => [...(m.genres || []), ...(m.tags || [])]))];
      const profile = new Array(allTags.length).fill(0);

      let totalWeight = 0;

      Object.entries(userRatings).forEach(([movieId, rating]) => {
        const movie = MOVIES_DATABASE.find(m => m.id === parseInt(movieId));
        if (!movie) return;

        // Нормализуем рейтинг (1-5 -> -2 до 2)
        const weight = rating - 3;
        totalWeight += Math.abs(weight);

        [...(movie.genres || []), ...(movie.tags || [])].forEach(feature => {
          const idx = allTags.indexOf(feature);
          if (idx !== -1) {
            profile[idx] += weight;
          }
        });
      });

      // Нормализация профиля
      if (totalWeight > 0) {
        for (let i = 0; i < profile.length; i++) {
          profile[i] /= totalWeight;
        }
      }

      return profile;
    }

    /**
     * Получение рекомендаций
     */
    function getRecommendations() {
      const ratedCount = getRatedCount();
      const t = translations[currentLang];
      const container = document.getElementById("recommendationsList");

      if (ratedCount < 5) {
        container.innerHTML = `
          <div class="empty-state">
            <i class="fas fa-magic"></i>
            <h3>${t.emptyRecommendations}</h3>
            <p>${t.emptyRecommendationsHint}</p>
          </div>
        `;
        return;
      }

      const userProfile = createUserProfile();

      // Вычисляем схожесть для всех неоценённых фильмов
      const recommendations = MOVIES_DATABASE
        .filter(movie => !userRatings[movie.id])
        .map(movie => {
          const movieVector = createFeatureVector(movie);
          const similarity = cosineSimilarity(userProfile, movieVector);
          return { movie, similarity };
        })
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, 10);

      container.innerHTML = recommendations.map((rec, index) => {
        const movie = rec.movie;
        const title = currentLang === "ru" ? (movie.titleRu || movie.title) : movie.title;
        const displayRating = formatRating(movie.rating);
        const similarityPercent = Math.round(rec.similarity * 100);

        return `
          <div class="recommendation-card" style="animation-delay: ${index * 0.1}s">
            <div class="recommendation-rank">#${index + 1}</div>
            <div class="recommendation-poster">
              ${renderPosterContent(movie, title)}
            </div>
            <div class="recommendation-details">
              <h3 class="recommendation-title">${title}</h3>
              <div class="recommendation-meta">
                ${movie.year} • ★ ${displayRating} •
                ${movie.genres.slice(0, 2).map(g => t.genres[g] || g).join(", ")}
              </div>
              <div class="similarity-score">
                <span>${t.similarity}:</span>
                <div class="similarity-bar">
                  <div class="similarity-fill" style="width: ${similarityPercent}%"></div>
                </div>
                <span class="similarity-value">${similarityPercent}%</span>
              </div>
            </div>
          </div>
        `;
      }).join("");
    }

    /**
     * Обновление прогресса
     */
    function updateProgress() {
      const ratedCount = getRatedCount();
      const minRatings = 5;
      const progress = Math.min(100, (ratedCount / minRatings) * 100);

      document.getElementById("ratedCount").textContent = ratedCount;
      document.getElementById("minRatings").textContent = minRatings;
      document.getElementById("progressFill").style.width = `${progress}%`;

      const recsBtn = document.getElementById("getRecsBtn");
      recsBtn.disabled = ratedCount < minRatings;
    }

    /**
     * Установка оценки фильму
     */
    function rateMovie(movieId, rating) {
      if (userRatings[movieId] === rating) {
        delete userRatings[movieId];
      } else {
        userRatings[movieId] = rating;
      }

      localStorage.setItem("movieRatings", JSON.stringify(userRatings));
      updateProgress();

      // Обновляем звёзды на карточке
      document.querySelectorAll(`.star[data-movie="${movieId}"]`).forEach(star => {
        const starValue = parseInt(star.dataset.star);
        star.classList.toggle("active", starValue <= (userRatings[movieId] || 0));
      });

      // Обновляем класс rated на карточке
      const card = document.querySelector(`.movie-card[data-id="${movieId}"]`);
      if (card) {
        card.classList.toggle("rated", userRatings[movieId] > 0);
      }
    }

    /**
     * Открытие модального окна с деталями фильма
     */
    function openModal(movieId) {
      const movie = MOVIES_DATABASE.find(m => m.id === movieId);
      if (!movie) return;

      const t = translations[currentLang];
      const title = currentLang === "ru" ? (movie.titleRu || movie.title) : movie.title;
      const rating = userRatings[movie.id] || 0;
      const displayRating = formatRating(movie.rating);
      const ratingLabel = displayRating === "—" ? "—" : `${displayRating}/10`;
      const tags = (movie.tags || []).join(", ");
      const tagsLabel = t.tagsLabel || "Tags";

      document.getElementById("modalContent").innerHTML = `
        <div class="modal-poster">
          ${renderPosterContent(movie, title)}
        </div>
        <div class="modal-info">
          <h2 class="modal-title">${title}</h2>
          <div class="modal-meta">
            <span><i class="fas fa-calendar"></i> ${movie.year}</span>
            <span><i class="fas fa-star" style="color: var(--accent-color)"></i> ${ratingLabel}</span>
          </div>
          <div class="modal-genres">
            ${movie.genres.map(g =>
              `<span class="modal-genre-tag">${t.genres[g] || g}</span>`
            ).join("")}
          </div>
          <p class="modal-description">
            <strong>${tagsLabel}:</strong> ${tags || "—"}
          </p>
          <div class="modal-rating">
            <h4 class="modal-rating-title">${t.yourRating}</h4>
            <div class="modal-stars">
              ${[1,2,3,4,5].map(star => `
                <span class="star ${star <= rating ? 'active' : ''}"
                      data-movie="${movie.id}"
                      data-star="${star}">★</span>
              `).join("")}
            </div>
          </div>
        </div>
      `;

      document.getElementById("movieModal").classList.add("active");
    }

    /**
     * Закрытие модального окна
     */
    function closeModal() {
      document.getElementById("movieModal").classList.remove("active");
    }

    /**
     * Переключение вкладок
     */
    function switchTab(tabName) {
      document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.classList.toggle("active", btn.dataset.tab === tabName);
      });

      document.querySelectorAll(".tab-content").forEach(content => {
        content.style.display = "none";
      });

      document.getElementById(`${tabName}Tab`).style.display = "block";

      if (tabName === "rated") {
        renderRatedMovies();
      } else if (tabName === "recommendations") {
        getRecommendations();
      }
    }

    /**
     * Настройка обработчиков событий
     */
    function setupEventListeners() {
      // Переключение темы
      document.getElementById("themeBtn").addEventListener("click", () => {
        currentTheme = currentTheme === "dark" ? "light" : "dark";
        localStorage.setItem("movieRecTheme", currentTheme);
        applyTheme();
      });

      // Переключение языка
      document.getElementById("langBtn").addEventListener("click", () => {
        currentLang = currentLang === "ru" ? "en" : "ru";
        localStorage.setItem("movieRecLang", currentLang);
        applyLanguage();
        renderGenreFilter();
        renderYearFilter();
        renderMovies();

        const activeTab = document.querySelector(".tab-btn.active").dataset.tab;
        if (activeTab === "rated") {
          renderRatedMovies();
        } else if (activeTab === "recommendations") {
          getRecommendations();
        }
      });

      // Сброс оценок
      document.getElementById("resetBtn").addEventListener("click", () => {
        if (confirm(currentLang === "ru"
          ? "Вы уверены, что хотите сбросить все оценки?"
          : "Are you sure you want to reset all ratings?")) {
          userRatings = {};
          localStorage.removeItem("movieRatings");
          updateProgress();
          renderMovies();
          renderRatedMovies();
          getRecommendations();
        }
      });

      // Вкладки
      document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.addEventListener("click", () => switchTab(btn.dataset.tab));
      });

      // Поиск
      document.getElementById("searchInput").addEventListener("input", (e) => {
        currentSearchQuery = e.target.value;
        renderMovies();
      });

      // Фильтр по жанрам
      document.getElementById("genreFilter").addEventListener("click", (e) => {
        if (e.target.classList.contains("genre-btn")) {
          currentGenreFilter = e.target.dataset.genre || null;
          renderGenreFilter();
          renderMovies();
        }
      });

      // Фильтр по годам
      document.getElementById("yearFrom").addEventListener("change", (e) => {
        currentYearFrom = e.target.value;
        if (currentYearFrom && currentYearTo && parseInt(currentYearFrom, 10) > parseInt(currentYearTo, 10)) {
          currentYearTo = currentYearFrom;
          document.getElementById("yearTo").value = currentYearTo;
        }
        persistYearFilters();
        renderMovies();
      });

      document.getElementById("yearTo").addEventListener("change", (e) => {
        currentYearTo = e.target.value;
        if (currentYearFrom && currentYearTo && parseInt(currentYearTo, 10) < parseInt(currentYearFrom, 10)) {
          currentYearFrom = currentYearTo;
          document.getElementById("yearFrom").value = currentYearFrom;
        }
        persistYearFilters();
        renderMovies();
      });

      // Оценка фильмов (делегирование)
      document.addEventListener("click", (e) => {
        if (e.target.classList.contains("star")) {
          const movieId = parseInt(e.target.dataset.movie);
          const starValue = parseInt(e.target.dataset.star);
          rateMovie(movieId, starValue);
        }
      });

      // Hover эффект для звёзд
      document.addEventListener("mouseover", (e) => {
        if (e.target.classList.contains("star")) {
          const movieId = e.target.dataset.movie;
          const starValue = parseInt(e.target.dataset.star);

          document.querySelectorAll(`.star[data-movie="${movieId}"]`).forEach(star => {
            const sv = parseInt(star.dataset.star);
            star.classList.toggle("hovered", sv <= starValue);
          });
        }
      });

      document.addEventListener("mouseout", (e) => {
        if (e.target.classList.contains("star")) {
          const movieId = e.target.dataset.movie;
          document.querySelectorAll(`.star[data-movie="${movieId}"]`).forEach(star => {
            star.classList.remove("hovered");
          });
        }
      });

      // Получить рекомендации
      document.getElementById("getRecsBtn").addEventListener("click", getRecommendations);

      // Закрытие модального окна
      document.getElementById("modalClose").addEventListener("click", closeModal);
      document.getElementById("movieModal").addEventListener("click", (e) => {
        if (e.target.id === "movieModal") closeModal();
      });

      // Закрытие по Escape
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeModal();
      });
    }

    // Запуск приложения
    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
