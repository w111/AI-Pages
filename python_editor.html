<!--
Техническое задание:
1. Создать веб-редактор Python кода с использованием Pyodide для выполнения кода в браузере
2. Основные компоненты:
   - Редактор кода с подсветкой синтаксиса (на основе CodeMirror)
   - Панель вывода результатов
   - Кнопки управления (запуск, очистка)
   - Примеры кода
   - Индикация загрузки и инициализации

3. Функциональные требования:
   - Выполнение Python кода в браузере
   - Поддержка библиотек numpy и matplotlib
   - Отображение графиков и визуализаций
   - Вывод ошибок и результатов выполнения
   - Горячие клавиши (Ctrl+Enter для запуска)
   - Автопрокрутка к новому выводу

4. Интерфейс:
   - Разделение экрана на редактор и вывод
   - Удобное расположение элементов управления
   - Индикация процесса выполнения
   - Адаптивный дизайн
   - Поддержка длинного вывода с прокруткой

5. Обработка ошибок:
   - Информативные сообщения об ошибках
   - Индикация статуса загрузки окружения
   - Обработка ошибок инициализации
   - Защита от некорректного ввода

6. Примеры кода:
   - Hello World (базовый пример)
   - Fibonacci (алгоритмический пример)
   - Spiral Plot (визуализация с matplotlib)
   - Sine Wave (работа с numpy и графиками)

7. Разделение правой колонки:
   - Область вывода текста (40% высоты)
   - Область графиков (60% высоты)
   - Интерактивный разделитель для изменения пропорций
   - Минимальные размеры для каждой области
   - Визуальная индикация при перетаскивании
   - Сохранение пропорций при изменении размера окна

8. Интерактивный разделитель:
   - Изменение курсора при наведении
   - Визуальная подсказка о возможности перетаскивания
   - Плавное перетаскивание
   - Ограничение минимальных размеров областей
   - Сохранение работоспособности при быстром перетаскивании

9. Особенности реализации разделителя:
   - Использование библиотеки Split.js
   - Отдельный компонент RightColumn для управления разделением
   - Стилизация разделителя через CSS
   - Обработка событий перетаскивания
   - Корректная работа с прокруткой в обеих областях

Комментарии по реализации:
1. Используется Pyodide v0.27.2 для запуска Python в браузере
2. CSS переменные для легкой кастомизации темы
3. Асинхронная загрузка и инициализация окружения
4. Отдельные буферы для stdout и stderr
5. Прогресс-бар для отслеживания загрузки компонентов
6. Оптимизированная работа с DOM для улучшения производительности
7. Автоматическая прокрутка для длинного вывода
8. Обработка изображений matplotlib
9. Система кэширования для быстрой загрузки
10. Поддержка горячих клавиш

Особенности реализации:
- Использование CSS Grid для разметки
- Flexbox для компонентов управления
- Анимации для улучшения UX
- Модульная структура JavaScript кода
- Оптимизированная обработка событий

10. Разделители областей:
    - Вертикальный разделитель между кодом и результатами (50/50)
    - Горизонтальный разделитель в области результатов (40/60)
    - Возможность изменения пропорций мышью
    - Минимальные размеры для всех областей
    - Визуальные индикаторы разделителей
    - Сохранение пропорций при изменении размера окна
    - Разные курсоры для разных типов разделителей

11. Сохранение настроек:
    - Сохранение размеров разделителей в localStorage
    - Кнопка настроек в правом верхнем углу
    - Панель настроек с возможностью сброса layout
    - Восстановление размеров при перезагрузке страницы
    - Сброс к размерам по умолчанию
    - Сохранение последнего выбранного примера
    - Автоматическая загрузка последнего примера при старте

12. Управление графиками:
    - Кнопка раскрытия на весь экран
    - Кнопка экспорта в PNG файл
    - Кнопка закрытия графика
    - Полноэкранный режим просмотра
    - Возможность скачивания графиков
    - Всплывающие подсказки для кнопок
    - Анимация при открытии/закрытии

13. Горячие клавиши редактора:
    - Ctrl/Cmd+Enter для запуска кода
    - Ctrl/Cmd+/ для комментирования кода
    - Tab/Shift+Tab для управления отступами
    - Ctrl/Cmd+D для дублирования строки
    - Ctrl/Cmd+Y для удаления строки
    - Alt+Up/Down для перемещения строк
    - Ctrl/Cmd+F для поиска
    - Ctrl/Cmd+H для замены
    - Ctrl/Cmd+Z для отмены действия
    - Ctrl/Cmd+Shift+Z для повтора действия
    - Ctrl/Cmd+A для выделения всего текста
    - Ctrl/Cmd+G для перехода к строке

14. Работа с графиками:
    - Поддержка различных типов графиков matplotlib
    - Возможность экспорта графиков в PNG
    - Полноэкранный режим просмотра
    - Управление размером графиков
    - Интерактивные элементы управления
    - Автоматическое масштабирование
    - Поддержка множественных графиков
    - Сохранение истории графиков
    - Возможность удаления отдельных графиков
    - Настройка параметров отображения

15. Темы оформления:
    - Поддержка светлой и темной темы
    - Настраиваемые цветовые схемы
    - CSS переменные для легкой кастомизации
    - Сохранение выбранной темы
    - Автоматическое применение темы
    - Адаптивное оформление элементов
    - Анимации при смене темы
    - Контрастные цвета для улучшения читаемости
    - Стилизация скроллбаров
    - Единообразное оформление компонентов
-->

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Pages Python (Pyodide)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    <!-- Основные библиотеки (React 18) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Pyodide с указанием integrity для безопасности -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.2/full/pyodide.js"></script>

    <!-- CodeMirror с минифицированными файлами -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/theme/monokai.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/python/python.min.js"></script>

    <!-- Добавляем скрипты для автодополнения -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/hint/python-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/hint/anyword-hint.min.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/hint/show-hint.min.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/split.js@1.6.5/dist/split.min.js"></script>
    <!-- Добавляем в head после других стилей -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/shepherd.js@10.0.1/dist/css/shepherd.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/shepherd.js@10.0.1/dist/js/shepherd.min.js"></script>
    <!-- В head после других скриптов добавляем -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/lint/lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/lint/python-lint.min.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/addon/lint/lint.min.css"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #2563eb;
        --background-color: #f8fafc;
        --editor-background: #1e1e1e;
        --output-background: #ffffff;
        --text-color: #1e293b;
        --border-color: #e2e8f0;
        --card-bg: #ffffff;
        --card-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,
          Cantarell, sans-serif;
        margin: 0;
        padding: 0;
        height: 100vh;
        overflow: hidden;
        background-color: var(--background-color);
        color: var(--text-color);
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 10px;
        box-sizing: border-box;
        overflow: hidden;
      }

      .header {
        flex-shrink: 0;
      }

      .main-content {
        flex: 1;
        display: flex;
        min-height: 0;
      }

      h1 {
        margin: 0;
        padding: 0;
        font-size: 1.2rem;
        line-height: 1;
      }

      .editor-container {
        flex: 1;
        min-height: 0;
        overflow: hidden;
      }

      .code-editor {
        height: 100%;
      }

      #code {
        width: 100%;
        height: 400px;
        padding: 15px;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 14px;
        line-height: 1.5;
        border: none;
        background-color: var(--editor-background);
        color: #ffffff;
        resize: none;
      }

      .output-container,
      .plots-container {
        overflow: auto;
        padding: 5px;
        margin: 0;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--output-background);
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) #edf2f7;
      }

      .output-container::-webkit-scrollbar,
      .plots-container::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }

      .output-container::-webkit-scrollbar-track,
      .plots-container::-webkit-scrollbar-track {
        background: #edf2f7;
        border-radius: 4px;
      }

      .output-container::-webkit-scrollbar-thumb,
      .plots-container::-webkit-scrollbar-thumb {
        background-color: var(--primary-color);
        border-radius: 4px;
        border: 2px solid #edf2f7;
      }

      .output-container::-webkit-scrollbar-thumb:hover,
      .plots-container::-webkit-scrollbar-thumb:hover {
        background-color: #1d4ed8;
      }

      #output {
        white-space: pre;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 0.9rem;
        line-height: 1.4;
        margin: 0;
        padding: 5px;
      }

      #output img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 10px 0;
      }

      .controls {
        margin: 0;
        padding: 0;
        display: flex;
        gap: 5px;
        height: 28px;
      }

      button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        height: 28px;
        transition: background-color 0.2s;
      }

      button:hover {
        background-color: #1d4ed8;
      }

      button:disabled {
        background-color: #93c5fd;
        cursor: not-allowed;
      }

      .loading {
        display: none;
        align-items: center;
        gap: 10px;
        color: var(--text-color);
      }

      .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #f3f3f3;
        border-top: 2px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .examples-dropdown {
        padding: 4px 8px;
        font-size: 0.9rem;
        height: 28px;
      }

      .init-status {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--output-background);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        z-index: 1000;
        min-width: 300px;
      }

      .status-text {
        font-size: 16px;
        font-weight: 500;
        color: var(--text-color);
      }

      .status-details {
        font-size: 14px;
        color: #666;
        text-align: center;
      }

      .init-status .spinner {
        width: 30px;
        height: 30px;
      }

      /* Стили для плавающего контейнера с графиком */
      .plot-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--output-background);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        max-width: 90vw;
        max-height: 90vh;
        overflow: auto;
      }

      .plot-container img {
        max-width: 100%;
        height: auto;
      }

      .plot-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
      }

      .plot-close:hover {
        background-color: #1d4ed8;
      }

      /* Стили для CodeMirror */
      .CodeMirror {
        height: 100% !important;
        font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        font-size: 14px;
        line-height: 1.5;
        white-space: nowrap;
      }

      /* Улучшаем внешний вид редактора */
      .cm-s-monokai.CodeMirror {
        background-color: var(--editor-background);
        border-radius: 8px;
        overflow-x: auto;
      }

      .CodeMirror-gutters {
        border-right: 1px solid #444;
        background-color: var(--editor-background);
      }

      .CodeMirror-linenumber {
        color: #666;
      }

      /* Стили для области графиков */
      .plots-container {
        padding: 5px;
        gap: 10px;
      }

      .plot-item {
        position: relative;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 0;
        margin-bottom: 5px;
        overflow: hidden;
        line-height: 0;
      }

      .plot-item img {
        width: 100%;
        height: auto;
        display: block;
        margin: 0;
      }

      .plot-close {
        position: absolute;
        top: 5px;
        right: 5px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        opacity: 0.8;
      }

      .plot-close:hover {
        opacity: 1;
      }

      .plots-header {
        display: none;
      }

      .no-plots {
        color: #666;
        text-align: center;
        padding: 20px;
        font-style: italic;
      }

      /* Стили для разделителя и областей разделения */
      .split {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      .gutter {
        background-color: var(--border-color);
        background-repeat: no-repeat;
        background-position: 50%;
      }

      .gutter.gutter-vertical {
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABo7865AAAABlBMVEVHcEzMzMzyAv2sAAAAAXRSTlMAQObYZgAAABBJREFUeF5jOAMEEAIEEFwAn3kMwcB6I2AAAAAASUVORK5CYII=');
        cursor: row-resize;
        height: 6px;
      }

      .split-item {
        overflow: auto;
      }

      /* Стили для горизонтального разделителя */
      .gutter.gutter-horizontal {
        background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==');
        cursor: col-resize;
        width: 6px;
      }

      .settings-button {
        position: fixed;
        top: 20px;
        right: 20px;
        font-size: 24px;
        color: var(--primary-color);
        background-color: var(--card-bg);
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--card-shadow);
        z-index: 100;
        transition: transform 0.3s ease;
        border: none;
      }
      .settings-button:hover {
        transform: rotate(45deg);
      }

      .settings-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: transparent;
        z-index: 999;
      }

      .settings-panel {
        position: fixed;
        top: 40px;
        right: 10px;
        background: var(--output-background);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        min-width: 200px;
      }

      .settings-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .settings-header h3 {
        margin: 0;
        font-size: 1rem;
      }

      .close-button {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        padding: 0 5px;
      }

      .reset-button {
        width: 100%;
        padding: 8px;
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }

      /* Добавляем стили для горизонтального скроллбара */
      .output-container::-webkit-scrollbar,
      .plots-container::-webkit-scrollbar,
      .CodeMirror-hscrollbar::-webkit-scrollbar {
        height: 8px;
      }

      /* Обновляем стили для кнопок управления графиком */
      .plot-controls {
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        gap: 4px;
        padding: 3px;
        background: none;
        border-top-right-radius: 8px;
      }

      .plot-button {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        opacity: 0.8;
        transition:
          opacity 0.2s,
          transform 0.2s;
        backdrop-filter: none;
        padding: 0;
      }

      .plot-button:hover {
        opacity: 1;
        transform: scale(1.1);
      }

      /* Стили для полноэкранного режима */
      .fullscreen-plot {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        padding: 20px;
      }

      .fullscreen-plot img {
        max-width: 90%;
        max-height: 90vh;
        object-fit: contain;
      }

      .fullscreen-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
      }

      .fullscreen-button,
      .fullscreen-close {
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        cursor: pointer;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0.8;
        transition:
          opacity 0.2s,
          transform 0.2s;
        padding: 0;
        line-height: 1;
      }

      .fullscreen-button span,
      .fullscreen-close span {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        margin-top: -2px;
      }

      .fullscreen-button:hover,
      .fullscreen-close:hover {
        opacity: 1;
        transform: scale(1.1);
      }

      /* Добавляем переменные для темной темы */
      :root[data-theme='dark'] {
        --primary-color: #3b82f6;
        --background-color: #1a1a1a;
        --editor-background: #1e1e1e;
        --output-background: #2d2d2d;
        --text-color: #e5e7eb;
        --border-color: #404040;
        --card-bg: #2d2d2d;
        --card-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      /* Стили для переключателя темы */
      .theme-switch {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid var(--border-color);
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 20px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 20px;
      }

      .slider:before {
        position: absolute;
        content: '';
        height: 16px;
        width: 16px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--primary-color);
      }

      input:checked + .slider:before {
        transform: translateX(20px);
      }

      .theme-label {
        font-size: 0.9rem;
        user-select: none;
      }

      /* Добавляем контейнер для кнопки настроек и панели */
      .settings-container {
        position: relative;
        display: inline-block;
      }

      /* Добавляем подключение шрифта */
      @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

      /* Стили для подсветки элементов тура */
      .shepherd-enabled.shepherd-element {
        z-index: 9999;
      }

      .shepherd-target {
        position: relative;
      }

      /* Кастомизация стилей тура */
      .shepherd-element {
        max-width: 400px;
        border-radius: 8px;
      }

      .shepherd-element .shepherd-content {
        padding: 15px;
      }

      .shepherd-element .shepherd-text {
        color: #333;
        line-height: 1.5;
      }

      .shepherd-element .shepherd-footer {
        padding: 10px 15px;
      }

      .shepherd-button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 4px;
        margin: 0 5px;
        cursor: pointer;
      }

      .shepherd-button:hover {
        background: #1d4ed8;
      }

      .shepherd-button.shepherd-button-secondary {
        background: #6b7280;
      }

      .shepherd-button.shepherd-button-secondary:hover {
        background: #4b5563;
      }

      .error-line {
        background-color: rgba(255, 0, 0, 0.2);
        animation: errorHighlight 3s;
      }

      @keyframes errorHighlight {
        0% {
          background-color: rgba(255, 0, 0, 0.4);
        }
        100% {
          background-color: rgba(255, 0, 0, 0.2);
        }
      }

      .CodeMirror-selected {
        background-color: rgba(255, 255, 255, 0.15) !important;
      }
      .CodeMirror-selectedtext {
        color: inherit !important;
      }

      .cm-matchhighlight {
        background-color: rgba(255, 255, 0, 0.3);
      }

      .CodeMirror-selection-highlight-scrollbar {
        background-color: rgba(255, 255, 0, 0.3);
      }

      /* Стили для кнопки форматирования */
      button[title^='Format'] {
        background-color: #4b5563;
      }

      button[title^='Format']:hover {
        background-color: #374151;
      }

      button[title^='Format']:disabled {
        background-color: #9ca3af;
      }

      /* Анимация для процесса форматирования */
      @keyframes formatting {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      .formatting {
        animation: formatting 1s infinite;
      }

      .CodeMirror-hints {
        position: absolute;
        z-index: 10;
        overflow: hidden;
        list-style: none;
        margin: 0;
        padding: 2px;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        background: var(--output-background);
        font-size: 90%;
        font-family: 'JetBrains Mono', monospace;
        max-height: 20em;
        overflow-y: auto;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      .CodeMirror-hint {
        margin: 0;
        padding: 4px 8px;
        border-radius: 2px;
        white-space: pre;
        color: var(--text-color);
        cursor: pointer;
        font-size: 13px;
      }

      .CodeMirror-hint-active {
        background: var(--primary-color);
        color: white;
      }

      .CodeMirror-lint-tooltip {
        background-color: var(--output-background);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        color: var(--text-color);
        font-family: 'JetBrains Mono', monospace;
        padding: 4px 8px;
        font-size: 12px;
        z-index: 100;
        max-width: 600px;
        white-space: pre-wrap;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      .CodeMirror-lint-marker-error,
      .CodeMirror-lint-marker-warning {
        width: 16px;
        height: 16px;
        background-position: center center;
        background-repeat: no-repeat;
        cursor: pointer;
      }

      .CodeMirror-lint-marker-error {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23dc2626'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z'/%3E%3C/svg%3E");
      }

      .CodeMirror-lint-marker-warning {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23f59e0b'%3E%3Cpath d='M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z'/%3E%3C/svg%3E");
      }

      .CodeMirror-lint-mark-error {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='3'%3E%3Cpath d='M 0 2.5 L 1 2.5' stroke='%23dc2626'/%3E%3C/svg%3E");
        background-position: left bottom;
        background-repeat: repeat-x;
      }

      .CodeMirror-lint-mark-warning {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1' height='3'%3E%3Cpath d='M 0 2.5 L 1 2.5' stroke='%23f59e0b'/%3E%3C/svg%3E");
        background-position: left bottom;
        background-repeat: repeat-x;
      }

      .lint-marker {
        width: 16px;
        height: 16px;
        background-position: center center;
        background-repeat: no-repeat;
        cursor: pointer;
        position: relative;
      }

      .lint-marker:hover::after {
        content: attr(title);
        position: absolute;
        left: 20px;
        top: 0;
        background: var(--output-background);
        border: 1px solid var(--border-color);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
        color: var(--text-color);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // Обновляем компонент Controls, добавляем параметр onLint
      const Controls = ({
        onRun,
        onClear,
        onFormat,
        onLint,
        examples,
        onExampleSelect,
        isRunning,
        selectedExample,
        code,
      }) => {
        console.log('Controls rendered, onLint exists:', !!onLint); // Отладочный вывод
        return (
          <div className="controls">
            <button onClick={onRun} disabled={isRunning}>
              Run Code (Ctrl+Enter)
            </button>
            <button onClick={onClear}>Clear Output</button>
            <button
              onClick={() => onFormat(code)}
              disabled={isRunning}
              title="Format code (Alt+Shift+F)"
              className={isRunning ? 'formatting' : ''}
            >
              {isRunning ? 'Formatting...' : 'Format'}
            </button>
            <button
              onClick={() => {
                console.log('Lint button clicked in Controls'); // Отладочный вывод
                onLint();
              }}
              title="Check code (Ctrl+L)"
              disabled={isRunning} // Добавляем disabled состояние
            >
              {isRunning ? 'Processing...' : 'Lint Code'}
            </button>
            <select
              className="examples-dropdown"
              onChange={e => onExampleSelect(e.target.value)}
              value={selectedExample || ''}
            >
              <option value="">-- Select Example --</option>
              <option value="hello">Hello World</option>
              <option value="fibonacci">Fibonacci Sequence</option>
              <option value="turtle">Colorful Spiral</option>
              <option value="numpy">Sine Wave</option>
              <option value="plotly">3D Spiral Plot</option>
              <option value="pandas">Data Analysis</option>
              <option value="http">Bitcoin Price Analysis</option>
              <option value="pillow">Image Processing</option>
              <option value="html_parser">HTML Parser</option>
              <option value="rss_parser">RSS Parser</option>
              <option value="scipy">SciPy Curve Fitting</option>
              <option value="sympy">SymPy Symbolic Math</option>
              <option value="networkx">NetworkX Graph Analysis</option>
              <option value="sklearn">Scikit-learn ML</option>
              <option value="statsmodels">Time Series Analysis</option>
              <option value="signal">Signal Processing</option>
              <option value="skimage">Image Processing (scikit-image)</option>
              <option value="wordcloud">Word Cloud</option>
              <option value="xgboost">XGBoost ML</option>
              <option value="zarr">Zarr Arrays</option>
              <option value="xarray">XArray Data</option>
              <option value="boost_histogram">Boost Histogram</option>
              <option value="geodata">Geographic Data</option>
              <option value="maps">Maps & Coordinates</option>
              <option value="interactive_plot">Interactive Plot</option>
              <option value="http_requests">HTTP Requests</option>
              <option value="xml_parser">XML Parser</option>
              <option value="templating">Template Engine</option>
              <option value="diagrams">Various Diagrams</option>
              <option value="fractal">Mandelbrot Fractal</option>
              <option value="game_of_life">Game of Life</option>
              <option value="heatmap">Correlation Heatmap</option>
              <option value="monte_carlo">Monte Carlo π</option>
              <option value="random_walk">Random Walk</option>
              <option value="sorting_viz">Sorting Visualization</option>
              <option value="maze">Maze Generator</option>
              <option value="markov_text">Markov Text</option>
              <option value="regex_demo">Regex Demo</option>
              <option value="distributions">Distributions</option>
              <option value="fourier">Fourier Transform</option>
            </select>
            {isRunning && (
              <div className="loading">
                <div className="spinner" />
                <span>Running...</span>
              </div>
            )}
          </div>
        );
      };

      // Компонент редактора кода с CodeMirror
      const CodeEditor = React.forwardRef(
        ({ code, onChange, onRun, onFormat, pyodide }, ref) => {
          const editorRef = React.useRef(null);
          const cmRef = React.useRef(null);

          // Экспортируем методы редактора через ref
          React.useImperativeHandle(ref, () => ({
            performLint: async () => {
              if (!cmRef.current) return;

              try {
                // Очищаем предыдущие маркеры и классы
                cmRef.current.clearGutter('CodeMirror-lint-markers');
                const lineCount = cmRef.current.lineCount();
                for (let i = 0; i < lineCount; i++) {
                  cmRef.current.removeLineClass(i, 'background', 'lint-error-line');
                  cmRef.current.removeLineClass(i, 'background', 'lint-warning-line');
                }

                const code = cmRef.current.getValue();

                // Устанавливаем pyflakes если еще не установлен
                if (!pyodide.isPyflakesInstalled) {
                  await pyodide.loadPackage('micropip');
                  await pyodide.runPythonAsync(`
                                import micropip
                                await micropip.install('pyflakes')
                            `);
                  pyodide.isPyflakesInstalled = true;
                }

                // Используем pyodide из пропсов
                const result = await pyodide.runPythonAsync(`
                            import io
                            import sys
                            from pyflakes.api import check
                            from pyflakes.reporter import Reporter

                            class LintReporter:
                                def __init__(self):
                                    self.errors = []
                                    
                                def unexpectedError(self, filename, msg):
                                    self.errors.append({"line": 0, "type": "error", "message": str(msg)})
                                    
                                def syntaxError(self, filename, msg, lineno, offset, text):
                                    self.errors.append({"line": lineno, "type": "error", "message": str(msg)})
                                    
                                def flake(self, message):
                                    self.errors.append({
                                        "line": message.lineno,
                                        "type": "warning",
                                        "message": str(message.message)
                                    })

                            reporter = LintReporter()
                            check(${JSON.stringify(code)}, "code.py", reporter)
                            reporter.errors
                        `);

                const errors = result.toJs();
                let report = 'Lint Results:\n' + '-'.repeat(50) + '\n';

                if (errors.length === 0) {
                  report += 'No issues found!\n';
                } else {
                  errors.forEach(error => {
                    const line = error.line - 1;
                    const msg = error.message;
                    report += `${error.type.toUpperCase()} at line ${error.line}: ${msg}\n`;

                    // Создаем маркер ошибки с подсказкой
                    const marker = document.createElement('div');
                    marker.className = `lint-marker ${error.type}`;
                    marker.setAttribute('title', msg); // Добавляем подсказку

                    // Добавляем маркер и подсветку
                    cmRef.current.setGutterMarker(
                      line,
                      'CodeMirror-lint-markers',
                      marker
                    );
                    cmRef.current.addLineClass(
                      line,
                      'background',
                      `lint-${error.type}-line`
                    );
                  });
                }

                return report;
              } catch (error) {
                console.error('Lint error:', error);
                throw error;
              }
            },
          }));

          React.useEffect(() => {
            if (editorRef.current && !cmRef.current) {
              console.log('Initializing CodeMirror');
              cmRef.current = CodeMirror(editorRef.current, {
                value: code,
                mode: 'python',
                theme: 'monokai',
                lineNumbers: true,
                indentUnit: 4,
                tabSize: 4,
                indentWithTabs: false,
                smartIndent: true,
                lineWrapping: false,
                scrollbarStyle: 'native',
                matchBrackets: true,
                autoCloseBrackets: true,
                foldGutter: true,
                gutters: [
                  'CodeMirror-lint-markers',
                  'CodeMirror-linenumbers',
                  'CodeMirror-foldgutter',
                ],
                highlightSelectionMatches: { showToken: /\w/, annotateScrollbar: true },
                extraKeys: {
                  'Ctrl-Enter': onRun,
                  'Cmd-Enter': onRun,
                  'Ctrl-Space': function (cm) {
                    CodeMirror.commands.autocomplete(cm, null, {
                      completeSingle: false,
                    });
                  },
                  'Ctrl-/': cm => {
                    const commentCode = cm => {
                      const selections = cm.listSelections();
                      const isMultiLine = selections.some(
                        sel => sel.head.line !== sel.anchor.line
                      );

                      if (isMultiLine) {
                        // Улучшенное комментирование блоков
                        cm.toggleComment({
                          lineComment: '#',
                          blockComment: ['"""', '"""'],
                        });
                      } else {
                        // Улучшенное комментирование строк
                        const cursor = cm.getCursor();
                        const line = cm.getLine(cursor.line);
                        const isCommented = line.trimStart().startsWith('#');

                        cm.replaceRange(
                          isCommented ? line.replace(/^\s*#\s?/, '') : '# ' + line,
                          { line: cursor.line, ch: 0 },
                          { line: cursor.line, ch: line.length }
                        );
                      }
                    };
                    commentCode(cm);
                  },
                  'Alt-Shift-F': cm => {
                    onFormat(cm.getValue());
                  },
                  'Ctrl-L': cm => {
                    cm.performLint();
                  },
                },
                hintOptions: {
                  completeSingle: false,
                  alignWithWord: true,
                  closeOnUnfocus: true,
                  hint: function (cm, options) {
                    const cursor = cm.getCursor();
                    const token = cm.getTokenAt(cursor);
                    const line = cm.getLine(cursor.line);
                    const start = token.start;
                    const end = cursor.ch;
                    const word = token.string;

                    // Собираем все возможные подсказки
                    const list = options.words.filter(function (item) {
                      return item.toLowerCase().indexOf(word.toLowerCase()) === 0;
                    });

                    return {
                      list: list,
                      from: CodeMirror.Pos(cursor.line, start),
                      to: CodeMirror.Pos(cursor.line, end),
                    };
                  },
                  words: [
                    // Базовые функции Python
                    'print',
                    'input',
                    'len',
                    'range',
                    'enumerate',
                    'zip',
                    'map',
                    'filter',
                    'sorted',
                    'reversed',
                    'sum',
                    'min',
                    'max',
                    'abs',
                    'round',
                    'int',
                    'float',
                    'str',
                    'list',
                    'dict',
                    'set',
                    'tuple',
                    'any',
                    'all',
                    'isinstance',
                    'type',
                    'dir',
                    'help',
                    'id',
                    'hash',
                    'super',

                    // Ключевые слова Python
                    'def',
                    'class',
                    'import',
                    'from',
                    'return',
                    'if',
                    'else',
                    'elif',
                    'for',
                    'while',
                    'try',
                    'except',
                    'finally',
                    'with',
                    'as',
                    'in',
                    'not',
                    'and',
                    'or',
                    'is',
                    'True',
                    'False',
                    'None',
                    'self',
                    'lambda',
                    'async',
                    'await',
                    'yield',
                    'break',
                    'continue',
                    'pass',
                    'raise',
                    'assert',
                    'del',
                    'global',
                    'nonlocal',

                    // Методы строк
                    'split',
                    'join',
                    'strip',
                    'lstrip',
                    'rstrip',
                    'upper',
                    'lower',
                    'title',
                    'capitalize',
                    'replace',
                    'startswith',
                    'endswith',
                    'find',
                    'format',
                    'count',

                    // Методы списков
                    'append',
                    'extend',
                    'insert',
                    'remove',
                    'pop',
                    'clear',
                    'index',
                    'sort',
                    'reverse',

                    // Методы словарей
                    'keys',
                    'values',
                    'items',
                    'get',
                    'update',
                    'setdefault',
                    'copy',

                    // Популярные библиотеки
                    'numpy',
                    'np',
                    'pandas',
                    'pd',
                    'matplotlib',
                    'plt',
                    'sklearn',
                    'torch',
                    'tensorflow',
                    'tf',
                    'scipy',
                    'requests',
                    'json',
                    'os',
                    'sys',
                    'math',
                    'random',
                    'datetime',
                    'time',
                    're',

                    // Numpy методы
                    'array',
                    'zeros',
                    'ones',
                    'empty',
                    'arange',
                    'linspace',
                    'reshape',
                    'transpose',
                    'concatenate',
                    'split',
                    'mean',
                    'std',
                    'min',
                    'max',
                    'argmin',
                    'argmax',

                    // Pandas методы
                    'DataFrame',
                    'Series',
                    'read_csv',
                    'read_excel',
                    'to_csv',
                    'to_excel',
                    'groupby',
                    'merge',
                    'concat',
                    'pivot',
                    'pivot_table',
                    'fillna',
                    'dropna',
                    'sort_values',
                    'sort_index',
                    'reset_index',
                    'set_index',

                    // Matplotlib методы
                    'plot',
                    'scatter',
                    'hist',
                    'bar',
                    'barh',
                    'pie',
                    'boxplot',
                    'subplot',
                    'figure',
                    'title',
                    'xlabel',
                    'ylabel',
                    'legend',
                    'grid',
                    'show',
                    'savefig',
                    'close',
                    'clf',
                    'cla',
                    'axis',
                    'colorbar',
                  ],
                },
                // Добавляем поддержку линтера
                lint: {
                  async getAnnotations(text) {
                    // Проверяем, что Pyodide и pyflakes инициализированы
                    if (!pyodide) return [];

                    try {
                      // Устанавливаем pyflakes если еще не установлен
                      if (!pyodide.isPyflakesInstalled) {
                        await pyodide.loadPackage('micropip');
                        await pyodide.runPythonAsync(`
                                            import micropip
                                            await micropip.install('pyflakes')
                                        `);
                        pyodide.isPyflakesInstalled = true;
                      }

                      // Запускаем проверку кода
                      const result = await pyodide.runPythonAsync(`
                                        import io
                                        import sys
                                        from pyflakes.api import check
                                        from pyflakes.reporter import Reporter

                                        class LintReporter:
                                            def __init__(self):
                                                self.errors = []
                                                
                                            def unexpectedError(self, filename, msg):
                                                self.errors.append({"line": 0, "type": "error", "message": str(msg)})
                                                
                                            def syntaxError(self, filename, msg, lineno, offset, text):
                                                self.errors.append({"line": lineno, "type": "error", "message": str(msg)})
                                                
                                            def flake(self, message):
                                                self.errors.append({
                                                    "line": message.lineno,
                                                    "type": "warning",
                                                    "message": str(message.message)
                                                })

                                        reporter = LintReporter()
                                        check(${JSON.stringify(text)}, "code.py", reporter)
                                        reporter.errors
                                    `);

                      // Преобразуем результаты в формат CodeMirror
                      return result.toJs().map(error => ({
                        from: CodeMirror.Pos(error.line - 1, 0),
                        to: CodeMirror.Pos(error.line - 1, 1000),
                        message: error.message,
                        severity: error.type,
                      }));
                    } catch (e) {
                      console.error('Lint error:', e);
                      return [];
                    }
                  },
                  async: true,
                  delay: 1000, // Увеличиваем задержку до 1 секунды
                },
                gutters: [
                  'CodeMirror-lint-markers',
                  'CodeMirror-linenumbers',
                  'CodeMirror-foldgutter',
                ],
              });

              // Добавляем обработчик изменений для обновления линтера
              cmRef.current.on('change', () => {
                if (cmRef.current.state.lint) {
                  clearTimeout(cmRef.current.state.lint.timeout);
                  cmRef.current.state.lint.timeout = setTimeout(() => {
                    cmRef.current.performLint();
                  }, 1000);
                }
              });

              console.log(
                'CodeMirror initialized with gutters:',
                cmRef.current.getOption('gutters')
              );
            }
          }, [code, pyodide]); // Добавляем pyodide в зависимости

          // Обновляем содержимое редактора при изменении props
          React.useEffect(() => {
            if (cmRef.current && code !== cmRef.current.getValue()) {
              cmRef.current.setValue(code);
              // Перемещаем курсор в начало документа
              cmRef.current.setCursor(0, 0);
              // Фокусируемся на редакторе
              cmRef.current.focus();
            }
          }, [code]);

          // Восстанавливаем последний код при загрузке
          React.useEffect(() => {
            const lastCode = localStorage.getItem('lastCode');
            if (lastCode && cmRef.current) {
              cmRef.current.setValue(lastCode);
            }
          }, []);

          return <div ref={editorRef} className="code-editor" />;
        }
      );

      // Компонент вывода
      const Output = ({ content }) => (
        <div className="output-container">
          <pre id="output">{content}</pre>
        </div>
      );

      // Компонент для полноэкранного просмотра
      const FullscreenPlot = ({ src, onClose, onDownload }) => (
        <div className="fullscreen-plot" onClick={onClose}>
          <img src={src} onClick={e => e.stopPropagation()} />
          <div className="fullscreen-controls">
            <button
              className="fullscreen-button"
              onClick={e => {
                e.stopPropagation();
                onDownload();
              }}
              title="Download"
            >
              <span>↓</span>
            </button>
            <button className="fullscreen-close" onClick={onClose} title="Close">
              <span>×</span>
            </button>
          </div>
        </div>
      );

      // Обновленный компонент PlotsPanel
      const PlotsPanel = ({ plots, onRemovePlot }) => {
        const [fullscreenPlot, setFullscreenPlot] = React.useState(null);

        const downloadPlot = (src, index) => {
          const link = document.createElement('a');
          link.href = src;
          link.download = `plot_${index + 1}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        };

        return (
          <div className="plots-container">
            {plots.length === 0 ? (
              <div className="no-plots">No plots to display</div>
            ) : (
              plots.map((plot, index) => (
                <div key={index} className="plot-item">
                  <div className="plot-controls">
                    <button
                      className="plot-button"
                      onClick={() => setFullscreenPlot({ src: plot.src, index })}
                      title="Fullscreen"
                    >
                      ⛶
                    </button>
                    <button
                      className="plot-button"
                      onClick={() => downloadPlot(plot.src, index)}
                      title="Download"
                    >
                      ↓
                    </button>
                    <button
                      className="plot-button"
                      onClick={() => onRemovePlot(index)}
                      title="Close"
                    >
                      ×
                    </button>
                  </div>
                  <img src={plot.src} alt={`Plot ${index + 1}`} />
                </div>
              ))
            )}
            {fullscreenPlot && (
              <FullscreenPlot
                src={fullscreenPlot.src}
                onClose={() => setFullscreenPlot(null)}
                onDownload={() =>
                  downloadPlot(fullscreenPlot.src, fullscreenPlot.index)
                }
              />
            )}
          </div>
        );
      };

      // Компонент статуса инициализации
      const InitStatus = ({ status, progress }) => (
        <div className="init-status">
          <div className="spinner" />
          <div className="status-text">Initializing AI Pages Python...</div>
          <div className="status-details">
            {status} {progress && `${progress}%`}
          </div>
        </div>
      );

      // Компонент настроек
      const Settings = ({ onReset, isOpen, onClose, onStartTour }) => {
        const panelRef = React.useRef(null);
        const [isDarkTheme, setIsDarkTheme] = React.useState(
          localStorage.getItem('theme') === 'dark'
        );

        const toggleTheme = () => {
          const newTheme = isDarkTheme ? 'light' : 'dark';
          setIsDarkTheme(!isDarkTheme);
          localStorage.setItem('theme', newTheme);
          document.documentElement.setAttribute('data-theme', newTheme);
        };

        React.useEffect(() => {
          const savedTheme = localStorage.getItem('theme') || 'light';
          document.documentElement.setAttribute('data-theme', savedTheme);
        }, []);

        const handleOverlayClick = e => {
          if (!panelRef.current.contains(e.target)) {
            onClose();
          }
        };

        if (!isOpen) return null;

        return (
          <div className="settings-overlay" onClick={handleOverlayClick}>
            <div className="settings-panel" ref={panelRef}>
              <div className="settings-header">
                <h3>Settings</h3>
                <button className="close-button" onClick={onClose}>
                  ×
                </button>
              </div>
              <div className="settings-content">
                <div className="theme-switch">
                  <span className="theme-label">Dark Theme</span>
                  <label className="switch">
                    <input
                      type="checkbox"
                      checked={isDarkTheme}
                      onChange={toggleTheme}
                    />
                    <span className="slider"></span>
                  </label>
                </div>
                <button
                  className="reset-button"
                  onClick={() => {
                    localStorage.removeItem('tourCompleted');
                    onStartTour();
                    onClose();
                  }}
                  style={{ marginBottom: '10px' }}
                >
                  Start Product Tour
                </button>
                <button className="reset-button" onClick={onReset}>
                  Reset Layout
                </button>
              </div>
            </div>
          </div>
        );
      };

      // Обновляем правую колонку
      const RightColumn = ({ output, plots, onRemovePlot }) => {
        const splitRef = React.useRef(null);
        const defaultSizes = [40, 60];

        React.useEffect(() => {
          if (splitRef.current) {
            const savedSizes = localStorage.getItem('verticalSplit');
            const sizes = savedSizes ? JSON.parse(savedSizes) : defaultSizes;

            Split(splitRef.current.children, {
              direction: 'vertical',
              sizes: sizes,
              minSize: [100, 100],
              gutterSize: 6,
              cursor: 'row-resize',
              onDragEnd: sizes => {
                localStorage.setItem('verticalSplit', JSON.stringify(sizes));
              },
            });
          }
        }, []);

        return (
          <div className="right-column">
            <div className="split" ref={splitRef}>
              <div className="split-item">
                <Output content={output} />
              </div>
              <div className="split-item">
                <PlotsPanel plots={plots} onRemovePlot={onRemovePlot} />
              </div>
            </div>
          </div>
        );
      };

      // Главный компонент приложения
      const App = () => {
        const [pyodide, setPyodide] = React.useState(null);
        const [code, setCode] = React.useState('print("Hello, World!")');
        const [output, setOutput] = React.useState('');
        const [isRunning, setIsRunning] = React.useState(false);
        const [initStatus, setInitStatus] = React.useState('');
        const [initProgress, setInitProgress] = React.useState(0);
        const [plots, setPlots] = React.useState([]);
        const [isSettingsOpen, setIsSettingsOpen] = React.useState(false);
        const mainContentRef = React.useRef(null);
        const editorRef = React.useRef(null); // Добавляем ref для редактора
        const defaultSizes = [50, 50];
        const [selectedExample, setSelectedExample] = React.useState(
          localStorage.getItem('selectedExample') || ''
        );

        // Добавляем обработчик для линтера
        const handleLint = React.useCallback(async () => {
          console.log('Lint button clicked');
          if (!pyodide) {
            const message =
              'Error: Python environment is not ready yet. Please wait for initialization to complete.\n';
            console.error(message);
            setOutput(message);
            return;
          }

          if (editorRef.current) {
            console.log('Editor ref exists');
            try {
              setIsRunning(true);
              const report = await editorRef.current.performLint();
              setOutput(prev => prev + '\n' + report); // Добавляем отчет в вывод
              console.log('Lint completed');
            } catch (error) {
              console.error('Lint error:', error);
              setOutput(prev => prev + `\nLint error: ${error.message}\n`);
            } finally {
              setIsRunning(false);
            }
          } else {
            console.log('Editor ref is null');
          }
        }, [pyodide]);

        React.useEffect(() => {
          if (mainContentRef.current) {
            const savedSizes = localStorage.getItem('horizontalSplit');
            const sizes = savedSizes ? JSON.parse(savedSizes) : defaultSizes;

            Split(mainContentRef.current.children, {
              direction: 'horizontal',
              sizes: sizes,
              minSize: [300, 300],
              gutterSize: 6,
              onDragEnd: sizes => {
                localStorage.setItem('horizontalSplit', JSON.stringify(sizes));
              },
            });
          }
        }, []);

        // Инициализация Pyodide
        React.useEffect(() => {
          const initPyodide = async () => {
            try {
              setInitStatus('Downloading Python core...');
              const pyodideInstance = await loadPyodide({
                stdout: text => setOutput(prev => prev + text + '\n'),
                stderr: text => setOutput(prev => prev + 'Error: ' + text + '\n'),
                progress: progress => {
                  if (progress.loaded && progress.total) {
                    setInitProgress(
                      Math.round((progress.loaded / progress.total) * 100)
                    );
                  }
                },
              });

              setInitStatus('Loading NumPy package...');
              await pyodideInstance.loadPackage('numpy');

              setInitStatus('Loading Matplotlib package...');
              await pyodideInstance.loadPackage('matplotlib');

              setInitStatus('Loading Pandas package...');
              await pyodideInstance.loadPackage('pandas');

              setInitStatus('Loading Pillow package...');
              await pyodideInstance.loadPackage('pillow');

              setInitStatus('Loading SciPy package...');
              await pyodideInstance.loadPackage('scipy');

              setInitStatus('Loading SymPy package...');
              await pyodideInstance.loadPackage('sympy');

              setInitStatus('Loading NetworkX package...');
              await pyodideInstance.loadPackage('networkx');

              setInitStatus('Loading scikit-learn package...');
              await pyodideInstance.loadPackage('scikit-learn');

              setInitStatus('Loading statsmodels package...');
              await pyodideInstance.loadPackage('statsmodels');

              setInitStatus('Loading scikit-image package...');
              await pyodideInstance.loadPackage('scikit-image');

              setInitStatus('Loading wordcloud package...');
              await pyodideInstance.loadPackage('wordcloud');

              setInitStatus('Loading xgboost package...');
              await pyodideInstance.loadPackage('xgboost');

              setInitStatus('Loading zarr package...');
              await pyodideInstance.loadPackage('zarr');

              setInitStatus('Loading xarray package...');
              await pyodideInstance.loadPackage('xarray');

              setInitStatus('Loading boost-histogram package...');
              await pyodideInstance.loadPackage('boost-histogram');

              // Настраиваем matplotlib для работы с нашим интерфейсом
              await pyodideInstance.runPythonAsync(`
                            import matplotlib.pyplot as plt
                            import io, base64

                            def show_plot():
                                buf = io.BytesIO()
                                plt.savefig(buf, format='png', bbox_inches='tight')
                                buf.seek(0)
                                img_str = base64.b64encode(buf.getvalue()).decode('utf-8')
                                plt.close()
                                return img_str

                            def custom_show():
                                img_str = show_plot()
                                display_plot(img_str)
                                
                            plt.show = custom_show

                            # Добавляем собственную реализацию input
                            def input(prompt=''):
                                # Сначала выводим prompt
                                print(prompt, end='')
                                # Затем вызываем JavaScript prompt
                                return js_input(prompt)
                        `);

              // Добавляем функцию js_input в глобальное пространство Python
              pyodideInstance.globals.set('js_input', prompt => {
                return prompt ? window.prompt(prompt) : window.prompt();
              });

              // Добавляем функцию для отображения графиков в нашем интерфейсе
              pyodideInstance.globals.set('display_plot', img_str => {
                setPlots(prev => [
                  ...prev,
                  { src: `data:image/png;base64,${img_str}` },
                ]);
              });

              setPyodide(pyodideInstance);
              setInitStatus('');
            } catch (error) {
              setInitStatus(`Error: ${error.message}`);
              console.error('Failed to initialize Pyodide:', error);
            }
          };

          initPyodide();
        }, []);

        // Выполнение кода
        const runCode = async () => {
          if (!pyodide) return;

          setIsRunning(true);
          setOutput('');
          setPlots([]);

          try {
            // Добавляем обработку timeout
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('Execution timeout')), 30000);
            });

            const executionPromise = pyodide.runPythonAsync(code);
            await Promise.race([executionPromise, timeoutPromise]);
          } catch (error) {
            let errorMessage = error.message;

            // Улучшенная обработка ошибок Python
            if (error.type === 'PythonError') {
              const lines = error.message.split('\n');
              const lastLine = lines[lines.length - 1];
              errorMessage = `Python Error: ${lastLine}\n\nTraceback:\n${error.message}`;
            }

            setOutput(`Error: ${errorMessage}\n`);

            // Подсвечиваем строку с ошибкой в редакторе
            if (error.lineno) {
              cmRef.current.addLineClass(error.lineno - 1, 'background', 'error-line');
              setTimeout(() => {
                cmRef.current.removeLineClass(
                  error.lineno - 1,
                  'background',
                  'error-line'
                );
              }, 3000);
            }
          } finally {
            setIsRunning(false);
          }
        };

        // Загрузка примеров
        const loadExample = exampleKey => {
          if (examples[exampleKey]) {
            setCode(examples[exampleKey]);
            setSelectedExample(exampleKey);
            localStorage.setItem('selectedExample', exampleKey);
            // Очищаем вывод при загрузке нового примера
            setOutput('');
            setPlots([]);
          }
        };

        // Добавим загрузку последнего примера при инициализации
        React.useEffect(() => {
          const lastExample = localStorage.getItem('selectedExample');
          // Проверяем также наличие сохраненного кода
          const lastCode = localStorage.getItem('lastCode');
          if (lastCode) {
            setCode(lastCode);
          } else if (lastExample && examples[lastExample]) {
            setCode(examples[lastExample]);
            setSelectedExample(lastExample);
          }
        }, []);

        // Очистка вывода
        const clearOutput = () => {
          setOutput('');
          setPlots([]);
        };

        // Обработка горячих клавиш
        React.useEffect(() => {
          const handleKeyDown = e => {
            // Убираем глобальный обработчик, так как CodeMirror
            // будет обрабатывать Ctrl+Enter самостоятельно
          };

          document.addEventListener('keydown', handleKeyDown);
          return () => document.removeEventListener('keydown', handleKeyDown);
        }, [runCode]);

        const removePlot = index => {
          setPlots(plots => plots.filter((_, i) => i !== index));
        };

        const resetLayout = () => {
          localStorage.removeItem('horizontalSplit');
          localStorage.removeItem('verticalSplit');
          localStorage.removeItem('selectedExample');
          window.location.reload();
        };

        React.useEffect(() => {
          const savedTheme = localStorage.getItem('theme') || 'light';
          document.documentElement.setAttribute('data-theme', savedTheme);
        }, []);

        // В компоненте App добавляем:
        React.useEffect(() => {
          // Инициализация тура
          const tour = new Shepherd.Tour({
            useModalOverlay: true,
            defaultStepOptions: {
              classes: 'shadow-md',
              scrollTo: true,
              cancelIcon: {
                enabled: true,
              },
            },
          });

          // Добавляем шаги тура
          tour.addStep({
            id: 'welcome',
            text: 'Добро пожаловать в Garpun AI Python! Давайте познакомимся с основными возможностями редактора.',
            buttons: [
              {
                text: 'Пропустить',
                action: tour.complete,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'editor',
            attachTo: {
              element: '.editor-container',
              on: 'right',
            },
            text: 'Здесь вы можете писать и редактировать Python код. Редактор поддерживает подсветку синтаксиса и автоматические отступы.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'run-button',
            attachTo: {
              element: 'button:first-of-type',
              on: 'bottom',
            },
            text: 'Нажмите эту кнопку или используйте Ctrl+Enter для запуска кода.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'examples',
            attachTo: {
              element: '.examples-dropdown',
              on: 'bottom',
            },
            text: 'Выберите один из готовых примеров для изучения различных возможностей Python.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'output',
            attachTo: {
              element: '.output-container',
              on: 'left',
            },
            text: 'Здесь будет отображаться вывод вашей программы и сообщения об ошибках.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'plots',
            attachTo: {
              element: '.plots-container',
              on: 'left',
            },
            text: 'В этой области будут отображаться графики, созданные с помощью matplotlib и других библиотек визуализации.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          tour.addStep({
            id: 'settings',
            attachTo: {
              element: '.settings-button',
              on: 'left',
            },
            text: 'Нажмите здесь для доступа к настройкам редактора, включая выбор темы и сброс layout.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Завершить',
                action: tour.complete,
              },
            ],
          });

          // Запускаем тур после инициализации Pyodide
          if (!pyodide) {
            const startTour = () => {
              // Проверяем, не был ли тур уже показан
              if (!localStorage.getItem('tourCompleted')) {
                tour.start();
                localStorage.setItem('tourCompleted', 'true');
              }
            };

            const checkPyodide = setInterval(() => {
              if (pyodide) {
                clearInterval(checkPyodide);
                startTour();
              }
            }, 1000);
          }

          return () => {
            tour.complete();
          };
        }, [pyodide]);

        const startTour = () => {
          const tour = new Shepherd.Tour({
            useModalOverlay: true,
            defaultStepOptions: {
              classes: 'shadow-md',
              scrollTo: true,
              cancelIcon: {
                enabled: true,
              },
            },
          });

          // Добавляем шаги тура
          tour.addStep({
            id: 'welcome',
            text: 'Добро пожаловать в Garpun AI Python! Давайте познакомимся с основными возможностями редактора.',
            buttons: [
              {
                text: 'Пропустить',
                action: tour.complete,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          // Добавляем остальные шаги...
          tour.addStep({
            id: 'editor',
            attachTo: {
              element: '.editor-container',
              on: 'right',
            },
            text: 'Здесь вы можете писать и редактировать Python код. Редактор поддерживает подсветку синтаксиса и автоматические отступы.',
            buttons: [
              {
                text: 'Назад',
                action: tour.back,
              },
              {
                text: 'Далее',
                action: tour.next,
              },
            ],
          });

          // ... добавляем остальные шаги как в useEffect ...

          tour.start();
        };

        // Функция форматирования кода
        const formatCode = async code => {
          if (!pyodide) return;

          setIsRunning(true);
          setOutput('Formatting code...\n');

          try {
            // Инициализируем black если еще не установлен
            if (!pyodide.globals.get('black')) {
              setOutput('Installing black formatter...\n');
              await pyodide.loadPackage('micropip');
              await pyodide.runPythonAsync(`
import micropip
await micropip.install('black')
import black
                        `);
              setOutput('Black formatter installed successfully.\n');
            }

            // Форматируем код
            const formatScript = `
def format_python_code(code):
    import black
    try:
        mode = black.Mode(
            line_length=88,
            string_normalization=True,
            is_pyi=False
        )
        return black.format_str(code, mode=mode)
    except Exception as e:
        print(f"Formatting error: {str(e)}")
        return None
                       `;

            await pyodide.runPythonAsync(formatScript);
            pyodide.globals.set('code_to_format', code);

            const result = await pyodide.runPythonAsync(`
format_python_code(code_to_format)
                       `);

            console.log('Format result:', result);

            if (result) {
              setOutput('Code formatted successfully.\n');
              const formattedCode = result.trimEnd();
              setCode(formattedCode);
              return formattedCode;
            }
            return null;
          } catch (error) {
            console.error('Formatting failed:', error);
            setOutput(`Formatting error: ${error.message}\n`);
            return null;
          } finally {
            setIsRunning(false);
          }
        };

        // Добавляем обработчик форматирования в основной компонент
        return (
          <div className="container">
            <button
              className="settings-button"
              onClick={() => setIsSettingsOpen(!isSettingsOpen)}
              title="Settings"
            >
              <i className="fas fa-cog"></i>
            </button>
            <button
              className="tour-button"
              onClick={startTour}
              style={{
                position: 'fixed',
                top: '10px',
                right: '50px',
                background: 'var(--primary-color)',
                color: 'white',
                border: 'none',
                padding: '5px 10px',
                borderRadius: '4px',
                cursor: 'pointer',
                zIndex: 1000,
              }}
            >
              Start Tour
            </button>
            <div className="header">
              <h1>Garpun AI Python (Pyodide)</h1>
              <Controls
                onRun={runCode}
                onClear={clearOutput}
                onFormat={formatCode}
                onLint={handleLint}
                examples={examples}
                onExampleSelect={loadExample}
                isRunning={isRunning}
                selectedExample={selectedExample}
                code={code}
              />
            </div>
            <div className="main-content" ref={mainContentRef}>
              <div className="editor-container">
                <CodeEditor
                  ref={editorRef}
                  code={code}
                  onChange={setCode}
                  onRun={runCode}
                  onFormat={formatCode}
                  pyodide={pyodide} // Передаем pyodide в CodeEditor
                />
              </div>
              <RightColumn output={output} plots={plots} onRemovePlot={removePlot} />
            </div>
            {initStatus && <InitStatus status={initStatus} progress={initProgress} />}
            <Settings
              isOpen={isSettingsOpen}
              onClose={() => setIsSettingsOpen(false)}
              onReset={resetLayout}
              onStartTour={startTour}
            />
          </div>
        );
      };

      // Примеры кода
      const examples = {
        hello: `print("Hello, World!")
name = input("What's your name? ")
print(f"Nice to meet you, {name}!")`,

        fibonacci: `def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    
    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])
    return fib

n = 10
result = fibonacci(n)
print(f"First {n} numbers of Fibonacci sequence:")
print(result)`,

        turtle: `import numpy as np
import matplotlib.pyplot as plt

# Create a spiral pattern
t = np.linspace(0, 10*np.pi, 1000)
x = t * np.cos(t)
y = t * np.sin(t)

# Create colorful plot
plt.figure(figsize=(8, 8))
points = plt.scatter(x, y, c=t, cmap='rainbow', s=1)
plt.colorbar(points)
plt.title('Mathematical Spiral')
plt.axis('equal')
plt.grid(True)
plt.show()`,

        numpy: `import numpy as np
import matplotlib.pyplot as plt

# Create data
x = np.linspace(0, 10, 100)
y = np.sin(x)

# Create plot
plt.figure(figsize=(8, 4))
plt.plot(x, y, 'b-', label='sin(x)')
plt.title('Sine Wave')
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.grid(True)
plt.legend()
plt.show()`,

        plotly: `import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Создаем данные для 3D графика
theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)
z = np.linspace(-2, 2, 100)
r = z**2 + 1
x = r * np.sin(theta)
y = r * np.cos(theta)

# Создаем 3D график
fig = plt.figure(figsize=(12, 5))

# Первый subplot - 3D спираль
ax1 = fig.add_subplot(121, projection='3d')
scatter = ax1.scatter(x, y, z, c=z, cmap='viridis')
ax1.set_title('3D Spiral')
plt.colorbar(scatter, ax=ax1)

# Второй subplot - 2D проекция
ax2 = fig.add_subplot(122)
scatter2 = ax2.scatter(x, y, c=z, cmap='viridis')
ax2.set_title('2D Projection')
plt.colorbar(scatter2, ax=ax2)

plt.tight_layout()
plt.show()`,

        pandas: `import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Создаем временной ряд
dates = pd.date_range('2023-01-01', periods=100)
data = pd.DataFrame({
    'Date': dates,
    'Sales': np.random.normal(100, 15, 100).cumsum() + 1000,
    'Visitors': np.random.normal(50, 10, 100).cumsum() + 500,
    'Conversion': np.random.uniform(1, 5, 100)
})

# Устанавливаем Date как индекс
data.set_index('Date', inplace=True)

# Создаем график с двумя осями Y
fig, ax1 = plt.subplots(figsize=(12, 6))

# Первая ось для Sales и Visitors
color1, color2 = '#2563eb', '#16a34a'
ax1.set_xlabel('Date')
ax1.set_ylabel('Count', color=color1)
ax1.plot(data.index, data['Sales'], color=color1, label='Sales')
ax1.plot(data.index, data['Visitors'], color=color2, label='Visitors')
ax1.tick_params(axis='y', labelcolor=color1)

# Вторая ось для Conversion Rate
ax2 = ax1.twinx()
color3 = '#dc2626'
ax2.set_ylabel('Conversion Rate (%)', color=color3)
ax2.plot(data.index, data['Conversion'], color=color3, linestyle='--', label='Conversion')
ax2.tick_params(axis='y', labelcolor=color3)

# Добавляем заголовок и легенду
plt.title('Sales, Visitors and Conversion Rate Over Time')
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')

# Поворачиваем метки дат для лучшей читаемости
plt.xticks(rotation=45)

# Настраиваем макет
plt.tight_layout()

# Показываем график
plt.show()

# Выводим статистику
print("\\nData Statistics:")
print(data.describe())

# Выводим корреляцию
print("\\nCorrelation Matrix:")
print(data.corr().round(2))`,

        http: `from pyodide.http import pyfetch
import json
import pandas as pd
import matplotlib.pyplot as plt

async def get_bitcoin_price():
    response = await pyfetch("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd")
    data = await response.json()
    return data['bitcoin']['usd']

# Получаем текущую цену биткоина
price = await get_bitcoin_price()
print(f"Current Bitcoin price: $" + f"{price:,.2f}")

# Получаем исторические данные
response = await pyfetch(
    "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=30&interval=daily"
)
data = await response.json()

# Преобразуем данные
prices = [[x[0], x[1]] for x in data['prices']]
dates = [pd.to_datetime(x[0], unit='ms') for x in prices]
values = [x[1] for x in prices]

# Создаем график
plt.figure(figsize=(12, 6))
plt.plot(dates, values, 'b-', label='Bitcoin Price')
plt.title('Bitcoin Price Last 30 Days')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.grid(True)
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Выводим базовую статистику
prices_series = pd.Series(values)
print("\\nPrice Statistics:")
print("Mean: $" + f"{prices_series.mean():,.2f}")
print("Min: $" + f"{prices_series.min():,.2f}")
print("Max: $" + f"{prices_series.max():,.2f}")
print("Std Dev: $" + f"{prices_series.std():,.2f}")`,

        pillow: `from PIL import Image, ImageDraw, ImageFilter
import numpy as np
import matplotlib.pyplot as plt
import io

# Создаем новое изображение
width = 400
height = 300
image = Image.new('RGB', (width, height), 'white')
draw = ImageDraw.Draw(image)

# Рисуем разноцветные фигуры
for _ in range(50):
    # Случайные координаты и цвета
    x1 = np.random.randint(0, width)
    y1 = np.random.randint(0, height)
    x2 = np.random.randint(0, width)
    y2 = np.random.randint(0, height)
    r = np.random.randint(0, 255)
    g = np.random.randint(0, 255)
    b = np.random.randint(0, 255)
    
    # Рисуем линии разной толщины
    thickness = np.random.randint(1, 5)
    draw.line([(x1, y1), (x2, y2)], fill=(r, g, b), width=thickness)

# Рисуем несколько кругов
for _ in range(20):
    x = np.random.randint(0, width)
    y = np.random.randint(0, height)
    radius = np.random.randint(10, 30)
    r = np.random.randint(0, 255)
    g = np.random.randint(0, 255)
    b = np.random.randint(0, 255)
    draw.ellipse([x-radius, y-radius, x+radius, y+radius], 
                 outline=(r, g, b), 
                 width=2)

# Добавляем текст
draw.text((width//2-60, 10), 'Pillow Drawing', fill='black')

# Конвертируем в массив numpy для отображения
img_array = np.array(image)

# Отображаем результат
plt.figure(figsize=(10, 8))
plt.imshow(img_array)
plt.axis('off')
plt.title('Generated Image using Pillow')
plt.show()

# Применяем некоторые фильтры
filtered = image.filter(ImageFilter.BLUR)
img_array = np.array(filtered)

plt.figure(figsize=(10, 8))
plt.imshow(img_array)
plt.axis('off')
plt.title('Blurred Image')
plt.show()

# Поворачиваем изображение
rotated = image.rotate(45, expand=True)
img_array = np.array(rotated)

plt.figure(figsize=(10, 8))
plt.imshow(img_array)
plt.axis('off')
plt.title('Rotated Image')
plt.show()`,

        html_parser: `from html.parser import HTMLParser
import io
from pyodide.http import pyfetch
import json

async def fetch_and_parse_posts():
    print("Fetching posts from JSONPlaceholder API...")
    
    # Получаем данные из открытого API
    response = await pyfetch("https://jsonplaceholder.typicode.com/posts")
    posts = await response.json()
    
    # Получаем комментарии
    response = await pyfetch("https://jsonplaceholder.typicode.com/comments?_limit=10")
    comments = await response.json()
    
    print("\\nLatest Posts:\\n")
    print("="*60)
    
    # Выводим посты
    for post in posts[:5]:  # Первые 5 постов
        print(f"Title: {post['title']}")
        print(f"Content: {post['body'][:100]}...")  # Первые 100 символов
        print("-"*60)
    
    print("\\nLatest Comments:\\n")
    print("="*60)
    
    # Выводим комментарии
    for comment in comments[:3]:  # Первые 3 комментария
        print(f"Name: {comment['name']}")
        print(f"Email: {comment['email']}")
        print(f"Comment: {comment['body']}")
        print("-"*60)

# Запускаем парсинг
await fetch_and_parse_posts()`,

        rss_parser: `from pyodide.http import pyfetch
import pandas as pd
import xml.etree.ElementTree as ET
import io

async def parse_rss(url):
    print(f"Fetching RSS from TechInsider...\\n")
    
    # Получаем RSS
    response = await pyfetch(url)
    rss_content = await response.string()
    
    # Парсим XML
    root = ET.fromstring(rss_content)
    
    # Находим все items
    items = root.findall('.//item')
    
    # Собираем данные
    news_data = []
    for item in items:
        title = item.find('title').text if item.find('title') is not None else ''
        link = item.find('link').text if item.find('link') is not None else ''
        date = item.find('pubDate').text if item.find('pubDate') is not None else ''
        category = item.find('category').text if item.find('category') is not None else ''
        
        news_data.append({
            'Заголовок': title,
            'Дата': date,
            'Категория': category,
            'Ссылка': link
        })
    
    # Создаем DataFrame
    df = pd.DataFrame(news_data)
    
    # Выводим результаты
    print("Последние новости TechInsider:")
    print("="*100)
    print(df.to_string(index=False))
    
    # Базовая статистика
    print("\\nСтатистика:")
    print(f"Всего статей: {len(df)}")
    print(f"Уникальных категорий: {df['Категория'].nunique()}")
    print("\\nКатегории:")
    print(df['Категория'].value_counts())

# Парсим RSS ленту TechInsider
await parse_rss("https://www.techinsider.ru/out/public-feed-all-news.xml")`,

        scipy: `import numpy as np
from scipy import optimize, stats
import matplotlib.pyplot as plt

# Создаем зашумленные данные
x = np.linspace(0, 10, 100)
y_true = 3 * np.exp(-x/2)
y_noisy = y_true + np.random.normal(0, 0.2, x.shape)

# Определяем функцию для оптимизации
def exp_decay(x, a, b):
    return a * np.exp(-b * x)

# Находим оптимальные параметры
popt, pcov = optimize.curve_fit(exp_decay, x, y_noisy)

# Строим график
plt.figure(figsize=(10, 6))
plt.scatter(x, y_noisy, label='Noisy data')
plt.plot(x, exp_decay(x, *popt), 'r-', label='Fitted curve')
plt.title('Exponential Decay Fitting')
plt.legend()
plt.grid(True)
plt.show()

# Статистический анализ
print("Fitted Parameters:")
print(f"a = {popt[0]:.3f}")
print(f"b = {popt[1]:.3f}")

# Проверка нормальности распределения шума
residuals = y_noisy - exp_decay(x, *popt)
stat, p_value = stats.normaltest(residuals)
print(f"\\nNormality test p-value: {p_value:.3f}")`,

        sympy: `from sympy import symbols, solve, diff, integrate, latex
import matplotlib.pyplot as plt
import numpy as np

# Определяем символьные переменные
x, y = symbols('x y')
expr = x**2 + 2*x + 1

# Находим производную
derivative = diff(expr, x)
print(f"Expression: {expr}")
print(f"Derivative: {derivative}")

# Находим интеграл
integral = integrate(expr, x)
print(f"Integral: {integral}")

# Решаем уравнение
equation = expr - 4
solution = solve(equation, x)
print(f"Solutions for {expr} = 4: {solution}")

# Визуализируем функцию
x_vals = np.linspace(-5, 5, 100)
y_vals = [i**2 + 2*i + 1 for i in x_vals]

plt.figure(figsize=(10, 6))
plt.plot(x_vals, y_vals)
plt.title(f'$f(x) = {latex(expr)}$')
plt.grid(True)
plt.axhline(y=0, color='k', linestyle='-', alpha=0.3)
plt.axvline(x=0, color='k', linestyle='-', alpha=0.3)
plt.show()`,

        networkx: `import networkx as nx
import matplotlib.pyplot as plt
import numpy as np

# Создаем случайный граф
G = nx.random_geometric_graph(20, 0.3)

# Получаем наибольшую компоненту связности
largest_cc = max(nx.connected_components(G), key=len)
G = G.subgraph(largest_cc).copy()

# Вычисляем метрики графа
degrees = dict(G.degree())
centrality = nx.betweenness_centrality(G)

# Создаем фигуру с правильными размерами
fig, ax = plt.subplots(figsize=(10, 8))

# Получаем layout для графа
pos = nx.spring_layout(G)

# Создаем маппинг для цветов
nodes = nx.draw_networkx_nodes(G, pos,
                             node_size=[v * 1000 for v in centrality.values()],
                             node_color=list(degrees.values()),
                             cmap=plt.cm.viridis,
                             ax=ax)

# Рисуем ребра
nx.draw_networkx_edges(G, pos, alpha=0.2, ax=ax)

# Добавляем метки узлов
nx.draw_networkx_labels(G, pos, font_size=8)

# Добавляем colorbar
plt.colorbar(nodes, ax=ax, label='Node Degree')

# Настраиваем внешний вид
plt.title('Connected Component Analysis')
ax.set_axis_off()

# Показываем график
plt.tight_layout()
plt.show()

# Анализ графа
print("Graph Analysis:")
print(f"Number of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"Average clustering coefficient: {nx.average_clustering(G):.3f}")
print(f"Average shortest path length: {nx.average_shortest_path_length(G):.3f}")

# Дополнительная информация о степенях узлов
degree_sequence = sorted([d for n, d in G.degree()], reverse=True)
print("\\nDegree Distribution:")
print(f"Maximum degree: {max(degree_sequence)}")
print(f"Minimum degree: {min(degree_sequence)}")
print(f"Average degree: {sum(degree_sequence)/len(degree_sequence):.2f}")

# Дополнительные метрики
print("\\nAdditional Metrics:")
print(f"Graph density: {nx.density(G):.3f}")
print(f"Graph diameter: {nx.diameter(G)}")
print(f"Graph radius: {nx.radius(G)}")`,

        sklearn: `from sklearn.datasets import make_classification
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import numpy as np

# Генерируем данные
X, y = make_classification(n_samples=1000, n_features=2, n_redundant=0, 
                         n_clusters_per_class=1, random_state=42)

# Разделяем на тренировочную и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

# Обучаем модель
clf = RandomForestClassifier(n_estimators=100)
clf.fit(X_train, y_train)

# Делаем предсказания
y_pred = clf.predict(X_test)

# Визуализируем результаты
plt.figure(figsize=(12, 5))

# График данных и границы решения
plt.subplot(121)
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.02),
                     np.arange(y_min, y_max, 0.02))
Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
Z = Z.reshape(xx.shape)

plt.contourf(xx, yy, Z, alpha=0.4)
plt.scatter(X[:, 0], X[:, 1], c=y, alpha=0.8)
plt.title('Classification Results')

# Матрица ошибок
plt.subplot(122)
cm = confusion_matrix(y_test, y_pred)
plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
plt.title('Confusion Matrix')
plt.colorbar()
plt.show()

# Выводим метрики
print(f"Accuracy: {clf.score(X_test, y_test):.3f}")`,

        statsmodels: `import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller, acf, pacf
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

# Создаем временной ряд с трендом, сезонностью и шумом
np.random.seed(42)
dates = pd.date_range(start='2020-01-01', end='2023-12-31', freq='D')
n = len(dates)

# Создаем компоненты временного ряда
trend = np.linspace(0, 100, n)  # Линейный тренд
seasonal = 20 * np.sin(2 * np.pi * np.arange(n)/365)  # Годовая сезонность
noise = np.random.normal(0, 5, n)  # Случайный шум

# Создаем временной ряд
data = trend + seasonal + noise
ts = pd.Series(data, index=dates, name='value')

# 1. Декомпозиция временного ряда
decomposition = seasonal_decompose(ts, period=365)

# Визуализация декомпозиции
fig = plt.figure(figsize=(12, 10))
plt.subplot(411)
plt.plot(ts)
plt.title('Original Time Series')
plt.grid(True)

plt.subplot(412)
plt.plot(decomposition.trend)
plt.title('Trend')
plt.grid(True)

plt.subplot(413)
plt.plot(decomposition.seasonal)
plt.title('Seasonal')
plt.grid(True)

plt.subplot(414)
plt.plot(decomposition.resid)
plt.title('Residuals')
plt.grid(True)

plt.tight_layout()
plt.show()

# 2. Анализ стационарности
def print_adf_test(series):
    result = adfuller(series.dropna())
    print('Augmented Dickey-Fuller Test:')
    print(f'ADF Statistic: {result[0]:.3f}')
    print(f'p-value: {result[1]:.3f}')
    print('Critical values:')
    for key, value in result[4].items():
        print(f'\\t{key}: {value:.3f}')

print("Stationarity Test for Original Series:")
print_adf_test(ts)

# 3. ACF и PACF анализ
fig = plt.figure(figsize=(12, 6))
ax1 = plt.subplot(121)
plot_acf(ts, ax=ax1, lags=40)
plt.title('Autocorrelation Function')

ax2 = plt.subplot(122)
plot_pacf(ts, ax=ax2, lags=40)
plt.title('Partial Autocorrelation Function')

plt.tight_layout()
plt.show()

# 4. Прогнозирование
# Разделяем данные
train = ts[:'2023-06-30']
test = ts['2023-07-01':]

# Создаем и обучаем SARIMA модель
model = sm.tsa.statespace.SARIMAX(train, 
                                 order=(1, 1, 1),
                                 seasonal_order=(1, 1, 1, 12))
results = model.fit()

# Делаем прогноз
forecast = results.get_forecast(steps=len(test))
forecast_mean = forecast.predicted_mean
forecast_ci = forecast.conf_int()

# Визуализация прогноза
plt.figure(figsize=(12, 6))
plt.plot(train.index, train.values, label='Training Data')
plt.plot(test.index, test.values, label='Actual Values')
plt.plot(forecast_mean.index, forecast_mean.values, color='red', label='Forecast')
plt.fill_between(forecast_ci.index,
                forecast_ci.iloc[:, 0],
                forecast_ci.iloc[:, 1], color='r', alpha=.1)
plt.title('SARIMA Forecast')
plt.legend()
plt.grid(True)
plt.show()

# 5. Диагностика модели
fig = plt.figure(figsize=(12, 8))
results.plot_diagnostics(fig=fig)
plt.tight_layout()
plt.show()

# 6. Оценка качества прогноза
def calculate_metrics(actual, predicted):
    mse = np.mean((actual - predicted) ** 2)
    rmse = np.sqrt(mse)
    mae = np.mean(np.abs(actual - predicted))
    mape = np.mean(np.abs((actual - predicted) / actual)) * 100
    return {'MSE': mse, 'RMSE': rmse, 'MAE': mae, 'MAPE': mape}

metrics = calculate_metrics(test, forecast_mean)
print("\\nForecast Metrics:")
print("-" * 50)
for metric, value in metrics.items():
    print(f"{metric}: {value:.2f}")

# 7. Анализ сезонности
seasonal_patterns = ts.groupby(ts.index.month).agg(['mean', 'std'])
plt.figure(figsize=(12, 6))
seasonal_patterns['mean'].plot(kind='bar', yerr=seasonal_patterns['std'], capsize=5)
plt.title('Monthly Seasonal Patterns')
plt.xlabel('Month')
plt.ylabel('Value')
plt.grid(True)
plt.show()

# 8. Статистика модели
print("\\nModel Summary:")
print("-" * 50)
print(results.summary().tables[1])`,

        signal: `from scipy import signal
import numpy as np
import matplotlib.pyplot as plt

# Создаем сигнал
t = np.linspace(0, 1, 1000, endpoint=False)
clean_signal = np.sin(2*np.pi*10*t) + 0.5*np.sin(2*np.pi*20*t)
noise = np.random.normal(0, 0.5, clean_signal.shape)
noisy_signal = clean_signal + noise

# Применяем фильтры
# Butterworth фильтр
b, a = signal.butter(4, 0.2, 'low', analog=False)
filtered_signal = signal.filtfilt(b, a, noisy_signal)

# Спектрограмма
f, t_spec, Sxx = signal.spectrogram(noisy_signal, 1000)

# Визуализация
plt.figure(figsize=(12, 8))

# Временная область
plt.subplot(221)
plt.plot(t, clean_signal, 'g', label='Clean')
plt.plot(t, noisy_signal, 'b', alpha=0.3, label='Noisy')
plt.plot(t, filtered_signal, 'r', label='Filtered')
plt.title('Time Domain')
plt.legend()

# Частотная область
plt.subplot(222)
freq = np.fft.fftfreq(len(t), t[1]-t[0])
plt.plot(freq[:len(freq)//2], np.abs(np.fft.fft(noisy_signal))[:len(freq)//2])
plt.title('Frequency Domain')
plt.xlim(0, 50)

# Спектрограмма
plt.subplot(223)
plt.pcolormesh(t_spec, f, Sxx)
plt.title('Spectrogram')
plt.ylabel('Frequency')
plt.xlabel('Time')

plt.tight_layout()
plt.show()

# Анализ сигнала
print("Signal Analysis:")
print(f"Signal-to-Noise Ratio: {np.mean(clean_signal**2)/np.mean(noise**2):.2f}")
print(f"Peak frequency: {freq[np.argmax(np.abs(np.fft.fft(clean_signal)))]:.1f} Hz")`,

        skimage: `from skimage import filters, feature, transform
import numpy as np
import matplotlib.pyplot as plt

# Создаем тестовое изображение
image = np.random.rand(100, 100)

# Применяем различные фильтры
edges = feature.canny(image)
sobel = filters.sobel(image)
rotated = transform.rotate(image, 45)

# Визуализация
plt.figure(figsize=(12, 4))
plt.subplot(131)
plt.imshow(edges)
plt.title('Canny Edges')

plt.subplot(132)
plt.imshow(sobel)
plt.title('Sobel Filter')

plt.subplot(133)
plt.imshow(rotated)
plt.title('Rotated Image')

plt.show()`,

        wordcloud: `from wordcloud import WordCloud
import matplotlib.pyplot as plt
import numpy as np

# Создаем текст
text = """Python programming language machine learning 
data science artificial intelligence deep learning 
neural networks computer vision natural language processing"""

# Создаем облако слов
wordcloud = WordCloud(width=800, height=400,
                     background_color='white').generate(text)

# Отображаем результат
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title('Word Cloud')
plt.show()`,

        xgboost: `import xgboost as xgb
from sklearn.datasets import make_regression
import matplotlib.pyplot as plt
import numpy as np

# Создаем данные
X, y = make_regression(n_samples=1000, n_features=5, random_state=42)
X_train, X_test = X[:800], X[800:]
y_train, y_test = y[:800], y[800:]

# Создаем и обучаем модель
model = xgb.XGBRegressor(n_estimators=100)
model.fit(X_train, y_train)

# Делаем предсказания
y_pred = model.predict(X_test)

# Визуализируем результаты
plt.figure(figsize=(10, 5))
plt.scatter(y_test, y_pred, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('True Values')
plt.ylabel('Predictions')
plt.title('XGBoost Regression Results')
plt.show()

# Выводим важность признаков
importance = model.feature_importances_
plt.figure(figsize=(10, 5))
plt.bar(range(len(importance)), importance)
plt.title('Feature Importance')
plt.show()`,

        zarr: `import zarr
import numpy as np
import matplotlib.pyplot as plt

# Создаем большой массив данных
z = zarr.zeros((1000, 1000), chunks=(100, 100), dtype='float64')
z[:] = np.random.random((1000, 1000))

# Выполняем операции с данными
subset = z[400:600, 400:600]
mean_value = subset.mean()
std_value = subset.std()

# Визуализируем часть данных
plt.figure(figsize=(10, 8))
plt.imshow(subset[:], cmap='viridis')
plt.colorbar()
plt.title(f'Data Subset (Mean: {mean_value:.2f}, Std: {std_value:.2f})')
plt.show()`,

        xarray: `import xarray as xr
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Создаем многомерный массив с координатами
times = pd.date_range('2023-01-01', periods=100)
lats = np.linspace(0, 90, 30)
lons = np.linspace(0, 180, 40)

data = np.random.rand(len(times), len(lats), len(lons))
da = xr.DataArray(data, 
                 coords=[times, lats, lons],
                 dims=['time', 'lat', 'lon'])

# Вычисляем среднее по времени
mean_data = da.mean(dim='time')

# Визуализируем результаты
plt.figure(figsize=(12, 6))
mean_data.plot()
plt.title('Mean Values Over Time')
plt.show()

# Временной ряд для конкретной точки
point_data = da.sel(lat=45, lon=90, method='nearest')
plt.figure(figsize=(12, 4))
point_data.plot()
plt.title('Time Series at Lat=45, Lon=90')
plt.show()`,

        boost_histogram: `import boost_histogram as bh
import numpy as np
import matplotlib.pyplot as plt

# Создаем случайные данные
np.random.seed(42)
data1 = np.random.normal(0, 1, 10000)  # Нормальное распределение
data2 = np.random.exponential(2, 10000)  # Экспоненциальное распределение

# Создаем гистограммы
hist1 = bh.Histogram(bh.axis.Regular(50, -5, 5))
hist2 = bh.Histogram(bh.axis.Regular(50, 0, 10))

# Заполняем гистограммы
hist1.fill(data1)
hist2.fill(data2)

# Визуализация
plt.figure(figsize=(12, 5))

# Нормальное распределение
plt.subplot(121)
edges = hist1.axes[0].edges
centers = (edges[:-1] + edges[1:]) / 2
plt.bar(centers, hist1.values(), width=edges[1]-edges[0], alpha=0.5, label='Data')
plt.title('Normal Distribution')
plt.xlabel('Value')
plt.ylabel('Counts')
plt.grid(True)
plt.legend()

# Экспоненциальное распределение
plt.subplot(122)
edges = hist2.axes[0].edges
centers = (edges[:-1] + edges[1:]) / 2
plt.bar(centers, hist2.values(), width=edges[1]-edges[0], alpha=0.5, label='Data')
plt.title('Exponential Distribution')
plt.xlabel('Value')
plt.ylabel('Counts')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# Статистический анализ
print("Normal Distribution Statistics:")
print(f"Total entries: {sum(hist1.values())}")
print(f"Mean: {np.average(centers, weights=hist1.values()):.2f}")
print(f"Std Dev: {np.sqrt(np.average((centers - np.average(centers, weights=hist1.values()))**2, weights=hist1.values())):.2f}")

print("\\nExponential Distribution Statistics:")
print(f"Total entries: {sum(hist2.values())}")
print(f"Mean: {np.average(centers, weights=hist2.values()):.2f}")
print(f"Std Dev: {np.sqrt(np.average((centers - np.average(centers, weights=hist2.values()))**2, weights=hist2.values())):.2f}")`,

        geodata: `import numpy as np
import matplotlib.pyplot as plt

# Создаем данные для карты
def create_map_data(n_points=1000):
    # Генерируем случайные координаты
    lats = np.random.normal(55, 10, n_points)  # Примерно центр России
    lons = np.random.normal(37, 20, n_points)  # Примерно центр России
    values = np.random.rand(n_points)  # Случайные значения для точек
    return lats, lons, values

# Создаем данные
lats, lons, values = create_map_data()

# Создаем график
plt.figure(figsize=(15, 10))

# Scatter plot с цветовой шкалой
scatter = plt.scatter(lons, lats, c=values, cmap='viridis', 
                     alpha=0.6, s=50)
plt.colorbar(scatter, label='Values')

# Добавляем основные города России для ориентации
cities = {
    'Moscow': (55.7558, 37.6173),
    'Saint Petersburg': (59.9343, 30.3351),
    'Novosibirsk': (55.0084, 82.9357),
    'Yekaterinburg': (56.8389, 60.6057)
}

# Отмечаем города на карте
for city, coords in cities.items():
    plt.plot(coords[1], coords[0], 'r*', markersize=15)
    plt.annotate(city, (coords[1], coords[0]), xytext=(5, 5), 
                textcoords='offset points')

# Настраиваем внешний вид
plt.title('Geographic Data Visualization')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.grid(True)

# Добавляем простую сетку координат
plt.axhline(y=0, color='k', linestyle=':')
plt.axvline(x=0, color='k', linestyle=':')

plt.show()

# Анализ данных
print("Data Analysis:")
print(f"Number of points: {len(lats)}")
print(f"\\nLatitude range:")
print(f"Min: {lats.min():.2f}°")
print(f"Max: {lats.max():.2f}°")
print(f"Mean: {lats.mean():.2f}°")

print(f"\\nLongitude range:")
print(f"Min: {lons.min():.2f}°")
print(f"Max: {lons.max():.2f}°")
print(f"Mean: {lons.mean():.2f}°")

# Находим ближайшие точки к городам
def find_nearest_points(city_coords, lats, lons, values, n=5):
    distances = np.sqrt((lats - city_coords[0])**2 + (lons - city_coords[1])**2)
    nearest_idx = np.argsort(distances)[:n]
    return values[nearest_idx]

print("\\nNearest points analysis:")
for city, coords in cities.items():
    nearest_values = find_nearest_points(coords, lats, lons, values)
    print(f"\\n{city}:")
    print(f"Mean value of 5 nearest points: {nearest_values.mean():.3f}")
    print(f"Max value of 5 nearest points: {nearest_values.max():.3f}")
    print(f"Min value of 5 nearest points: {nearest_values.min():.3f}")`,

        maps: `import numpy as np
import matplotlib.pyplot as plt

# Создаем данные о городах России
cities = {
    'Moscow': (55.7558, 37.6173, 12500000),
    'Saint Petersburg': (59.9343, 30.3351, 5400000),
    'Novosibirsk': (55.0084, 82.9357, 1600000),
    'Yekaterinburg': (56.8389, 60.6057, 1500000),
    'Kazan': (55.7887, 49.1221, 1250000)
}

# Создаем базовую карту
plt.figure(figsize=(10, 6))

# Отмечаем города
for city, (lat, lon, pop) in cities.items():
    size = np.sqrt(pop) / 100  # Размер маркера зависит от населения
    plt.plot(lon, lat, 'ro', markersize=size)
    plt.annotate(city, (lon, lat), xytext=(5, 5), 
                textcoords='offset points')

# Добавляем случайные точки для плотности населения
n_points = 1000
lats = np.random.normal(55, 10, n_points)
lons = np.random.normal(60, 30, n_points)
density = np.random.rand(n_points)

# Создаем тепловую карту
plt.hexbin(lons, lats, C=density, cmap='YlOrRd', alpha=0.3)
plt.colorbar(label='Population Density')

# Настраиваем внешний вид
plt.title('Major Cities of Russia')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.grid(True)

plt.show()

# Анализ данных
print("Cities Analysis:")
print("-" * 50)
for city, (lat, lon, pop) in cities.items():
    print(f"{city}:")
    print(f"  Population: {pop:,}")
    print(f"  Coordinates: {lat:.2f}°N, {lon:.2f}°E")

# Находим ближайшие города
def find_nearest_cities(lat, lon, cities, n=2):
    distances = {}
    for city, (clat, clon, _) in cities.items():
        dist = np.sqrt((lat - clat)**2 + (lon - clon)**2)
        distances[city] = dist
    return sorted(distances.items(), key=lambda x: x[1])[:n]

print("\\nNearest Cities Analysis:")
print("-" * 50)
for i in range(3):
    random_lat = np.random.uniform(50, 70)
    random_lon = np.random.uniform(30, 90)
    nearest = find_nearest_cities(random_lat, random_lon, cities)
    print(f"\\nPoint {i+1} ({random_lat:.2f}°N, {random_lon:.2f}°E):")
    for city, dist in nearest:
        print(f"  {city}: {dist:.2f} degrees away")`,

        interactive_plot: `import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# Создаем данные
t = np.linspace(0, 10, 1000)
frequencies = [1, 2, 3]
amplitudes = [1, 0.5, 0.3]
phases = [0, np.pi/4, np.pi/2]

# Функция для создания сигнала
def create_signal(t, freq, amp, phase):
    return amp * np.sin(2 * np.pi * freq * t + phase)

# Создаем комбинированный сигнал
signal = np.zeros_like(t)
for f, a, p in zip(frequencies, amplitudes, phases):
    signal += create_signal(t, f, a, p)

# Создаем график
plt.figure(figsize=(12, 8))

# График полного сигнала
plt.subplot(211)
plt.plot(t, signal, 'b-', label='Combined Signal')
plt.title('Interactive Signal Analysis')
plt.grid(True)
plt.legend()

# График компонентов
plt.subplot(212)
for i, (f, a, p) in enumerate(zip(frequencies, amplitudes, phases)):
    component = create_signal(t, f, a, p)
    plt.plot(t, component, label=f'Component {i+1} (f={f}Hz)')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# Анализ сигнала
print("Signal Analysis:")
print("-" * 50)
print(f"Number of components: {len(frequencies)}")
print("\\nComponent details:")
for i, (f, a, p) in enumerate(zip(frequencies, amplitudes, phases)):
    print(f"\\nComponent {i+1}:")
    print(f"  Frequency: {f} Hz")
    print(f"  Amplitude: {a}")
    print(f"  Phase: {p:.2f} rad")

# Статистический анализ
print("\\nSignal Statistics:")
print("-" * 50)
print(f"Mean value: {np.mean(signal):.3f}")
print(f"Max value: {np.max(signal):.3f}")
print(f"Min value: {np.min(signal):.3f}")
print(f"Standard deviation: {np.std(signal):.3f}")

# Спектральный анализ
freqs = np.fft.fftfreq(len(t), t[1] - t[0])
spectrum = np.abs(np.fft.fft(signal))

plt.figure(figsize=(10, 5))
plt.plot(freqs[:len(freqs)//2], spectrum[:len(freqs)//2])
plt.title('Frequency Spectrum')
plt.xlabel('Frequency (Hz)')
plt.ylabel('Amplitude')
plt.grid(True)
plt.show()

# Находим основные частоты
peak_freqs = freqs[np.argsort(spectrum)[-3:]]
print("\\nDetected Frequencies:")
print("-" * 50)
for i, freq in enumerate(sorted(abs(peak_freqs)), 1):
    print(f"Peak {i}: {freq:.2f} Hz")`,

        http_requests: `from pyodide.http import pyfetch
import json
import pandas as pd
import matplotlib.pyplot as plt

async def fetch_data(url):
    """Функция для получения данных по URL"""
    response = await pyfetch(url)
    return await response.json()

# Получаем данные о пользователях
print("Fetching users data...")
users_data = await fetch_data("https://jsonplaceholder.typicode.com/users")

# Получаем данные о постах
print("Fetching posts data...")
posts_data = await fetch_data("https://jsonplaceholder.typicode.com/posts")

# Получаем данные о комментариях
print("Fetching comments data...")
comments_data = await fetch_data("https://jsonplaceholder.typicode.com/comments")

# Создаем DataFrame
users_df = pd.DataFrame(users_data)
posts_df = pd.DataFrame(posts_data)
comments_df = pd.DataFrame(comments_data)

# Анализ данных
print("\\nData Analysis:")
print("-" * 50)
print(f"Number of users: {len(users_df)}")
print(f"Number of posts: {len(posts_df)}")
print(f"Number of comments: {len(comments_df)}")

# Анализ активности пользователей
posts_per_user = posts_df['userId'].value_counts()
comments_per_post = comments_df['postId'].value_counts()

# Визуализация
plt.figure(figsize=(12, 5))

# График постов пользователей
plt.subplot(121)
plt.bar(posts_per_user.index, posts_per_user.values)
plt.title('Posts per User')
plt.xlabel('User ID')
plt.ylabel('Number of Posts')
plt.grid(True)

# График комментариев к постам
plt.subplot(122)
plt.hist(comments_per_post.values, bins=20)
plt.title('Distribution of Comments per Post')
plt.xlabel('Number of Comments')
plt.ylabel('Frequency')
plt.grid(True)

plt.tight_layout()
plt.show()

# Детальная статистика
print("\\nUser Statistics:")
print("-" * 50)
for _, user in users_df.iterrows():
    user_posts = len(posts_df[posts_df['userId'] == user['id']])
    user_comments = sum(len(comments_df[comments_df['postId'] == post_id]) 
                       for post_id in posts_df[posts_df['userId'] == user['id']]['id'])
    print(f"User: {user['name']}")
    print(f"  Email: {user['email']}")
    print(f"  Posts: {user_posts}")
    print(f"  Comments received: {user_comments}")
    print()

# Анализ длины постов и комментариев
print("\\nContent Analysis:")
print("-" * 50)
posts_df['body_length'] = posts_df['body'].str.len()
comments_df['body_length'] = comments_df['body'].str.len()

print("Posts length statistics:")
print(posts_df['body_length'].describe())
print("\\nComments length statistics:")
print(comments_df['body_length'].describe())

# Визуализация длины контента
plt.figure(figsize=(12, 5))

plt.subplot(121)
plt.boxplot(posts_df['body_length'])
plt.title('Posts Length Distribution')
plt.ylabel('Number of Characters')

plt.subplot(122)
plt.boxplot(comments_df['body_length'])
plt.title('Comments Length Distribution')
plt.ylabel('Number of Characters')`,

        xml_parser: `import xml.etree.ElementTree as ET
import matplotlib.pyplot as plt
import numpy as np

# Создаем тестовый XML документ
xml_data = """<?xml version="1.0"?>
<library>
    <book category="fiction">
        <title>The Great Gatsby</title>
        <author>F. Scott Fitzgerald</author>
        <year>1925</year>
        <rating>4.8</rating>
    </book>
    <book category="science">
        <title>A Brief History of Time</title>
        <author>Stephen Hawking</author>
        <year>1988</year>
        <rating>4.7</rating>
    </book>
    <book category="fiction">
        <title>1984</title>
        <author>George Orwell</author>
        <year>1949</year>
        <rating>4.9</rating>
    </book>
    <book category="science">
        <title>The Selfish Gene</title>
        <author>Richard Dawkins</author>
        <year>1976</year>
        <rating>4.6</rating>
    </book>
</library>"""

# Парсим XML
root = ET.fromstring(xml_data)

# Собираем данные
books = []
for book in root.findall('book'):
    books.append({
        'title': book.find('title').text,
        'author': book.find('author').text,
        'year': int(book.find('year').text),
        'rating': float(book.find('rating').text),
        'category': book.get('category')
    })

# Анализ данных
print("Library Analysis:")
print("-" * 50)

# Количество книг по категориям
categories = {}
for book in books:
    categories[book.get('category')] = categories.get(book.get('category'), 0) + 1

print("\\nBooks by Category:")
for category, count in categories.items():
    print(f"{category}: {count} books")

# Средний рейтинг по категориям
ratings_by_category = {}
for book in books:
    cat = book['category']
    if cat not in ratings_by_category:
        ratings_by_category[cat] = []
    ratings_by_category[cat].append(book['rating'])

print("\\nAverage Ratings by Category:")
for category, ratings in ratings_by_category.items():
    avg_rating = sum(ratings) / len(ratings)
    print(f"{category}: {avg_rating:.2f}")

# Визуализация данных
plt.figure(figsize=(12, 5))

# График количества книг по категориям
plt.subplot(121)
plt.bar(categories.keys(), categories.values())
plt.title('Books by Category')
plt.ylabel('Number of Books')

# График средних рейтингов по категориям
plt.subplot(122)
avg_ratings = {cat: sum(ratings)/len(ratings) for cat, ratings in ratings_by_category.items()}
plt.bar(avg_ratings.keys(), avg_ratings.values())
plt.title('Average Ratings by Category')
plt.ylabel('Rating')

plt.tight_layout()
plt.show()

# Временная линия публикаций
years = [book['year'] for book in books]
titles = [book['title'] for book in books]

plt.figure(figsize=(12, 4))
plt.plot(years, range(len(years)), 'bo-')
for i, (year, title) in enumerate(zip(years, titles)):
    plt.annotate(title, (year, i), xytext=(5, 0), textcoords='offset points')
plt.title('Publication Timeline')
plt.xlabel('Year')
plt.grid(True)
plt.show()

# Детальная информация о книгах
print("\\nDetailed Book Information:")
print("-" * 50)
for book in sorted(books, key=lambda x: x['year']):
    print(f"\\nTitle: {book['title']}")
    print(f"Author: {book['author']}")
    print(f"Year: {book['year']}")
    print(f"Rating: {book['rating']}")
    print(f"Category: {book['category']}")`,

        templating: `from string import Template
import json
import matplotlib.pyplot as plt

# Пример шаблона HTML страницы
html_template = Template("""
<!DOCTYPE html>
<html>
<head>
    <title>$title</title>
</head>
<body>
    <h1>$header</h1>
    <div class="content">
        <p>Welcome, $user_name!</p>
        <ul>
        $items
        </ul>
    </div>
    <footer>
        <p>$footer</p>
    </footer>
</body>
</html>
""")

# Данные для шаблона
data = {
    'title': 'My Website',
    'header': 'Welcome to My Website',
    'user_name': 'John Doe',
    'items': '\\n'.join([
        '        <li>Item 1: Python Programming</li>',
        '        <li>Item 2: Data Analysis</li>',
        '        <li>Item 3: Web Development</li>'
    ]),
    'footer': '© 2024 My Website'
}

# Применяем шаблон
result = html_template.substitute(data)
print("Generated HTML:")
print("-" * 50)
print(result)

# Пример шаблона для JSON
json_template = Template("""
{
    "user": {
        "name": "$name",
        "email": "$email",
        "preferences": {
            "theme": "$theme",
            "language": "$language"
        }
    },
    "settings": {
        "notifications": $notifications,
        "privacy": "$privacy_level"
    }
}
""")

# Данные для JSON шаблона
json_data = {
    'name': 'John Doe',
    'email': 'john@example.com',
    'theme': 'dark',
    'language': 'en',
    'notifications': 'true',
    'privacy_level': 'high'
}

# Применяем JSON шаблон
json_result = json_template.substitute(json_data)
print("\\nGenerated JSON:")
print("-" * 50)
print(json_result)

# Парсим JSON для анализа
parsed_json = json.loads(json_result)

# Визуализация структуры данных
def create_structure_diagram():
    fig, ax = plt.subplots(figsize=(10, 6))
    ax.set_axis_off()
    
    # Создаем древовидную структуру
    levels = {
        0: ['User Data'],
        1: ['Personal Info', 'Preferences', 'Settings'],
        2: ['Name/Email', 'Theme/Language', 'Notifications/Privacy']
    }
    
    # Рисуем узлы
    y_positions = {0: 0.8, 1: 0.5, 2: 0.2}
    node_positions = {}
    
    for level, items in levels.items():
        n_items = len(items)
        for i, item in enumerate(items):
            x = (i + 1) / (n_items + 1)
            y = y_positions[level]
            node_positions[item] = (x, y)
            plt.plot(x, y, 'o', markersize=10, color='blue', alpha=0.6)
            plt.text(x, y + 0.05, item, ha='center', va='bottom')
    
    # Рисуем связи
    connections = [
        ('User Data', 'Personal Info'),
        ('User Data', 'Preferences'),
        ('User Data', 'Settings'),
        ('Personal Info', 'Name/Email'),
        ('Preferences', 'Theme/Language'),
        ('Settings', 'Notifications/Privacy')
    ]
    
    for start, end in connections:
        x1, y1 = node_positions[start]
        x2, y2 = node_positions[end]
        plt.plot([x1, x2], [y1, y2], '-', color='gray', alpha=0.5)
    
    plt.title('Data Structure Visualization')
    plt.show()

create_structure_diagram()

# Анализ данных
print("\\nData Analysis:")
print("-" * 50)
print("Template Variables Used:", len(data))
print("JSON Structure Depth:", len(parsed_json))
print("\\nUser Preferences:")
for key, value in parsed_json['user']['preferences'].items():
    print(f"  {key}: {value}")
print("\\nSettings:")
for key, value in parsed_json['settings'].items():
    print(f"  {key}: {value}")

# Создаем простой отчет
report_template = Template("""
User Profile Report
==================
Name: $name
Email: $email

Preferences
----------
Theme: $theme
Language: $language

Settings
--------
Notifications: $notifications
Privacy Level: $privacy_level
""")

print("\\nGenerated Report:")
print("-" * 50)
print(report_template.substitute(json_data))`,

        diagrams: `import numpy as np
import matplotlib.pyplot as plt

# Создаем данные для диаграмм
categories = ['A', 'B', 'C', 'D', 'E']
values = [23, 45, 56, 78, 43]
percentages = [15, 30, 25, 10, 20]
growth = [10, -5, 15, 8, -3]

# Создаем фигуру с несколькими графиками
plt.figure(figsize=(15, 10))

# 1. Столбчатая диаграмма
plt.subplot(231)
plt.bar(categories, values, color='skyblue')
plt.title('Bar Chart')
plt.grid(True, alpha=0.3)

# 2. Горизонтальная столбчатая диаграмма
plt.subplot(232)
plt.barh(categories, values, color='lightgreen')
plt.title('Horizontal Bar Chart')
plt.grid(True, alpha=0.3)

# 3. Круговая диаграмма
plt.subplot(233)
plt.pie(percentages, labels=categories, autopct='%1.1f%%',
        colors=['lightblue', 'lightgreen', 'lightpink', 'wheat', 'lavender'])
plt.title('Pie Chart')

# 4. Диаграмма с областями
plt.subplot(234)
x = np.arange(5)
plt.stackplot(x, [values, np.array(values)*0.5, np.array(values)*0.3],
             labels=['Series 1', 'Series 2', 'Series 3'])
plt.title('Area Chart')
plt.legend(loc='upper left')
plt.grid(True, alpha=0.3)

# 5. Лепестковая диаграмма
plt.subplot(235)
angles = np.linspace(0, 2*np.pi, len(categories), endpoint=False)
values_norm = np.array(values)/max(values)  # Нормализуем значения

# Замыкаем диаграмму
values_norm = np.concatenate((values_norm, [values_norm[0]]))
angles = np.concatenate((angles, [angles[0]]))
categories_closed = categories + [categories[0]]  # Используем список вместо np.array

ax = plt.gca()
ax.plot(angles, values_norm)
ax.fill(angles, values_norm, alpha=0.25)
ax.set_xticks(angles[:-1])
ax.set_xticklabels(categories)  # Используем оригинальные категории
plt.title('Radar Chart')

# 6. Диаграмма изменений
plt.subplot(236)
colors = ['green' if x >= 0 else 'red' for x in growth]
plt.bar(categories, growth, color=colors)
plt.axhline(y=0, color='black', linestyle='-', alpha=0.3)
plt.title('Change Chart')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Создаем более сложную диаграмму с группировкой
plt.figure(figsize=(12, 6))

# Данные для сгруппированной диаграммы
groups = ['Group 1', 'Group 2', 'Group 3', 'Group 4']
series1 = [10, 15, 12, 8]
series2 = [12, 8, 15, 10]
series3 = [5, 12, 9, 14]

x = np.arange(len(groups))
width = 0.25

plt.bar(x - width, series1, width, label='Series 1', color='skyblue')
plt.bar(x, series2, width, label='Series 2', color='lightgreen')
plt.bar(x + width, series3, width, label='Series 3', color='lightpink')

plt.xlabel('Groups')
plt.ylabel('Values')
plt.title('Grouped Bar Chart')
plt.xticks(x, groups)
plt.legend()
plt.grid(True, alpha=0.3)

plt.show()

# Создаем диаграмму с накоплением
plt.figure(figsize=(12, 6))

bottom = np.zeros(len(groups))
for i, data in enumerate([series1, series2, series3]):
    plt.bar(groups, data, bottom=bottom, label=f'Series {i+1}')
    bottom += data

plt.xlabel('Groups')
plt.ylabel('Values')
plt.title('Stacked Bar Chart')
plt.legend()
plt.grid(True, alpha=0.3)

plt.show()

# Выводим статистику
print("Data Analysis:")
print("-" * 50)
print("Basic Statistics:")
print(f"Total categories: {len(categories)}")
print(f"Total value: {sum(values)}")
print(f"Average value: {np.mean(values):.2f}")
print(f"Maximum value: {max(values)}")
print(f"Minimum value: {min(values)}")

print("\\nPercentage Distribution:")
for cat, perc in zip(categories, percentages):
    print(f"{cat}: {perc}%")

print("\\nGrowth Analysis:")
for cat, gr in zip(categories, growth):
    status = "increase" if gr > 0 else "decrease" if gr < 0 else "no change"
    print(f"{cat}: {gr}% ({status})")

# Корреляционный анализ
data = np.array([series1, series2, series3])
corr = np.corrcoef(data)
print("\\nCorrelation Matrix:")
for i in range(len(corr)):
    for j in range(len(corr)):
        print(f"Series {i+1} vs Series {j+1}: {corr[i][j]:.2f}")`,

        diagram_generator: `# Функция для создания диаграммы последовательности
def create_sequence_diagram():
    diagram = """
sequenceDiagram
    participant User
    participant Client
    participant Server
    participant Database
    
    User->>Client: Submit Form
    Client->>Server: POST /api/data
    Server->>Database: Insert Data
    Database-->>Server: Confirm Insert
    Server-->>Client: Response 200 OK
    Client-->>User: Show Success
"""
    return diagram

# Функция для создания блок-схемы
def create_flowchart():
    diagram = """
flowchart TD
    A[Start] --> B{Is User Logged In?}
    B -- Yes --> C[Show Dashboard]
    B -- No --> D[Show Login Form]
    D --> E[User Enters Credentials]
    E --> F{Valid Credentials?}
    F -- Yes --> C
    F -- No --> D
"""
    return diagram

# Функция для создания диаграммы классов
def create_class_diagram():
    diagram = """
classDiagram
    class User {
        +String username
        +String email
        +String password
        +login()
        +logout()
        +updateProfile()
    }
    class Profile {
        +String fullName
        +Date birthDate
        +String avatar
        +updateAvatar()
    }
    class Post {
        +String title
        +String content
        +Date createdAt
        +create()
        +update()
        +delete()
    }
    User "1" -- "1" Profile
    User "1" -- "*" Post
"""
    return diagram

# Функция для создания диаграммы состояний
def create_state_diagram():
    diagram = """
stateDiagram-v2
    [*] --> Idle
    Idle --> Processing: Start Task
    Processing --> Success: Task Complete
    Processing --> Error: Task Failed
    Success --> Idle: Reset
    Error --> Idle: Reset
    Idle --> [*]: Exit
"""
    return diagram

# Функция для создания диаграммы Ганта
def create_gantt_chart():
    diagram = """
gantt
    title Project Timeline
    dateFormat  YYYY-MM-DD
    section Planning
    Requirements    :a1, 2024-01-01, 30d
    Design         :a2, after a1, 20d
    section Development
    Implementation :a3, after a2, 40d
    Testing        :a4, after a3, 20d
    section Deployment
    Release        :a5, after a4, 10d
"""
    return diagram

# Функция для создания диаграммы сущность-связь
def create_er_diagram():
    diagram = """
erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER {
        string name
        string email
        string address
    }
    ORDER {
        int orderNumber
        date orderDate
        float totalAmount
    }
    LINE-ITEM {
        string product
        int quantity
        float price
    }
"""
    return diagram

# Выводим все диаграммы
print("Sequence Diagram:")
print("-" * 50)
print(create_sequence_diagram())

print("\\nFlowchart:")
print("-" * 50)
print(create_flowchart())

print("\\nClass Diagram:")
print("-" * 50)
print(create_class_diagram())

print("\\nState Diagram:")
print("-" * 50)
print(create_state_diagram())

print("\\nGantt Chart:")
print("-" * 50)
print(create_gantt_chart())

print("\\nER Diagram:")
print("-" * 50)
print(create_er_diagram())

# Создаем простой пример генерации диаграммы на основе данных
def generate_flowchart_from_data(steps):
    diagram = "flowchart TD\\n"
    for i in range(len(steps)-1):
        diagram += f"    {chr(65+i)}[{steps[i]}] --> {chr(65+i+1)}[{steps[i+1]}]\\n"
    return diagram

# Пример использования
process_steps = [
    "Start Process",
    "Validate Input",
    "Process Data",
    "Save Results",
    "End Process"
]

print("\\nGenerated Flowchart:")
print("-" * 50)
print(generate_flowchart_from_data(process_steps))

# Генерация диаграммы последовательности из данных
def generate_sequence_from_data(interactions):
    diagram = "sequenceDiagram\\n"
    participants = set()
    for source, target, message in interactions:
        participants.add(source)
        participants.add(target)
    
    for participant in sorted(participants):
        diagram += f"    participant {participant}\\n"
    
    for source, target, message in interactions:
        diagram += f"    {source}->>{target}: {message}\\n"
    
    return diagram

# Пример использования
interactions = [
    ("User", "System", "Login Request"),
    ("System", "Database", "Verify Credentials"),
    ("Database", "System", "Return Result"),
    ("System", "User", "Access Granted")
]

print("\\nGenerated Sequence Diagram:")
print("-" * 50)
print(generate_sequence_from_data(interactions))`,

        graph_viz: `import networkx as nx
import matplotlib.pyplot as plt

# Создаем граф
G = nx.Graph()

# Добавляем узлы и ребра
nodes = ['A', 'B', 'C', 'D', 'E', 'F']
edges = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F'), ('F', 'A'),
         ('A', 'C'), ('B', 'D'), ('C', 'E'), ('D', 'F')]

G.add_nodes_from(nodes)
G.add_edges_from(edges)

# Создаем различные визуализации
plt.figure(figsize=(15, 10))

# 1. Круговая компоновка
plt.subplot(231)
nx.draw_circular(G, with_labels=True, node_color='lightblue', 
                node_size=1000, font_size=10)
plt.title('Circular Layout')

# 2. Случайная компоновка
plt.subplot(232)
nx.draw_random(G, with_labels=True, node_color='lightgreen',
               node_size=1000, font_size=10)
plt.title('Random Layout')

# 3. Спектральная компоновка
plt.subplot(233)
nx.draw_spectral(G, with_labels=True, node_color='lightpink',
                node_size=1000, font_size=10)
plt.title('Spectral Layout')

# 4. Spring компоновка
plt.subplot(234)
nx.draw_spring(G, with_labels=True, node_color='wheat',
              node_size=1000, font_size=10)
plt.title('Spring Layout')

# 5. Shell компоновка
plt.subplot(235)
nx.draw_shell(G, with_labels=True, node_color='lavender',
             node_size=1000, font_size=10)
plt.title('Shell Layout')

# 6. Kamada-Kawai компоновка
plt.subplot(236)
pos = nx.kamada_kawai_layout(G)
nx.draw(G, pos, with_labels=True, node_color='lightcyan',
        node_size=1000, font_size=10)
plt.title('Kamada-Kawai Layout')

plt.tight_layout()
plt.show()

# Анализ графа
print("Graph Analysis:")
print("-" * 50)
print(f"Number of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"Average degree: {sum(dict(G.degree()).values())/G.number_of_nodes():.2f}")
print(f"Density: {nx.density(G):.2f}")

# Центральность узлов
print("\\nNode Centrality:")
print("-" * 50)
degree_centrality = nx.degree_centrality(G)
betweenness_centrality = nx.betweenness_centrality(G)
closeness_centrality = nx.closeness_centrality(G)

for node in G.nodes():
    print(f"\\nNode {node}:")
    print(f"  Degree centrality: {degree_centrality[node]:.3f}")
    print(f"  Betweenness centrality: {betweenness_centrality[node]:.3f}")
    print(f"  Closeness centrality: {closeness_centrality[node]:.3f}")

# Визуализация с весами центральности
plt.figure(figsize=(12, 4))

# Размер узла зависит от степени центральности
plt.subplot(131)
node_size = [v * 3000 for v in degree_centrality.values()]
nx.draw(G, pos, with_labels=True, node_size=node_size,
        node_color='lightblue', font_size=8)
plt.title('Node Size by Degree Centrality')

# Цвет узла зависит от промежуточной центральности
plt.subplot(132)
node_color = list(betweenness_centrality.values())
nx.draw(G, pos, with_labels=True, node_size=1000,
        node_color=node_color, cmap=plt.cm.viridis, font_size=8)
plt.title('Color by Betweenness Centrality')

# Размер и цвет зависят от близости центральности
plt.subplot(133)
node_size = [v * 3000 for v in closeness_centrality.values()]
node_color = list(closeness_centrality.values())
nx.draw(G, pos, with_labels=True, node_size=node_size,
        node_color=node_color, cmap=plt.cm.viridis, font_size=8)
plt.title('Size and Color by Closeness Centrality')

plt.tight_layout()
plt.show()

# Поиск кратчайших путей
print("\\nShortest Paths:")
print("-" * 50)
for source in ['A', 'B']:
    for target in ['E', 'F']:
        if source != target:
            path = nx.shortest_path(G, source=source, target=target)
            print(f"{source} -> {target}: {' -> '.join(path)}")

# Поиск клик
cliques = list(nx.find_cliques(G))
print("\\nMaximal Cliques:")
print("-" * 50)
for i, clique in enumerate(cliques, 1):
    print(f"Clique {i}: {clique}")

# Компоненты связности
components = list(nx.connected_components(G))
print("\\nConnected Components:")
print("-" * 50)
for i, component in enumerate(components, 1):
    print(f"Component {i}: {component}")`,

        altair: `import altair as alt
import pandas as pd
import numpy as np

# Enable rendering in browser environment
alt.renderers.enable('default')

# Создаем данные
np.random.seed(42)
data = pd.DataFrame({
    'date': pd.date_range('2024-01-01', periods=100),
    'value': np.random.normal(0, 1, 100).cumsum(),
    'category': np.random.choice(['A', 'B', 'C'], 100),
    'size': np.random.randint(1, 100, 100)
})

# Создаем базовую диаграмму рассеяния
scatter = alt.Chart(data).mark_circle().encode(
    x='date:T',
    y='value:Q',
    color='category:N',
    size='size:Q',
    tooltip=['date', 'value', 'category', 'size']
).properties(
    width=600,
    height=400,
    title='Interactive Scatter Plot'
)

# Создаем график линии тренда
line = alt.Chart(data).mark_line(
    color='red',
    strokeDash=[5,5]
).transform_regression(
    'date', 'value'
).encode(
    x='date:T',
    y='value:Q'
)

# Создаем гистограмму значений
histogram = alt.Chart(data).mark_bar().encode(
    x=alt.X('value:Q', bin=True),
    y='count()',
    color=alt.value('lightblue')
).properties(
    width=600,
    height=200,
    title='Value Distribution'
)

# Объединяем графики и преобразуем в HTML
combined = (scatter + line) & histogram
print(combined.to_html())

# Создаем тепловую карту
heatmap = alt.Chart(data).mark_rect().encode(
    x=alt.X('date:T', timeUnit='month', title='Month'),
    y=alt.Y('date:T', timeUnit='day', title='Day'),
    color='value:Q',
    tooltip=['date', 'value']
).properties(
    width=400,
    height=300,
    title='Value Heatmap'
)
print(heatmap.to_html())

# Создаем круговую диаграмму
pie = alt.Chart(data).mark_arc().encode(
    theta='count()',
    color='category:N',
    tooltip=['category', 'count()']
).properties(
    width=400,
    height=400,
    title='Category Distribution'
)
print(pie.to_html())

# Выводим базовую статистику
print("\\nData Statistics:")
print("-" * 50)
print(data.describe())

print("\\nCategory Distribution:")
print("-" * 50)
print(data['category'].value_counts())

# Корреляционный анализ
correlations = data.corr()
print("\\nCorrelation Matrix:")
print("-" * 50)
print(correlations)`,

        fractal: `import numpy as np
import matplotlib.pyplot as plt

# Параметры изображения
width, height = 800, 800
x_min, x_max = -2.5, 1.0
y_min, y_max = -1.75, 1.75
max_iter = 100

# Создаем координатную сетку
x = np.linspace(x_min, x_max, width)
y = np.linspace(y_min, y_max, height)
X, Y = np.meshgrid(x, y)
C = X + 1j * Y

# Множество Мандельброта
Z = np.zeros_like(C)
M = np.zeros(C.shape)

for i in range(max_iter):
    mask = np.abs(Z) <= 2
    Z[mask] = Z[mask] ** 2 + C[mask]
    M[mask] = i

# Визуализация
plt.figure(figsize=(12, 12))
plt.imshow(M, extent=[x_min, x_max, y_min, y_max],
           cmap='hot', origin='lower', aspect='equal')
plt.colorbar(label='Iterations')
plt.title('Mandelbrot Set', fontsize=16)
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.show()

# Дополнительно: увеличенная область
print("\\nZoomed region around interesting area...")
x_min2, x_max2 = -0.75, -0.65
y_min2, y_max2 = 0.1, 0.2

x2 = np.linspace(x_min2, x_max2, width)
y2 = np.linspace(y_min2, y_max2, height)
X2, Y2 = np.meshgrid(x2, y2)
C2 = X2 + 1j * Y2
Z2 = np.zeros_like(C2)
M2 = np.zeros(C2.shape)

for i in range(200):
    mask = np.abs(Z2) <= 2
    Z2[mask] = Z2[mask] ** 2 + C2[mask]
    M2[mask] = i

plt.figure(figsize=(12, 12))
plt.imshow(M2, extent=[x_min2, x_max2, y_min2, y_max2],
           cmap='twilight_shifted', origin='lower', aspect='equal')
plt.colorbar(label='Iterations')
plt.title('Mandelbrot Set - Zoomed', fontsize=16)
plt.xlabel('Real')
plt.ylabel('Imaginary')
plt.show()`,

        game_of_life: `import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import ListedColormap

def create_grid(size, pattern='random'):
    """Создаёт начальную конфигурацию"""
    grid = np.zeros((size, size), dtype=int)

    if pattern == 'random':
        grid = np.random.choice([0, 1], size=(size, size), p=[0.85, 0.15])
    elif pattern == 'glider':
        # Планер
        glider = np.array([[0, 1, 0], [0, 0, 1], [1, 1, 1]])
        grid[1:4, 1:4] = glider
    elif pattern == 'blinker':
        # Мигалка
        grid[10, 9:12] = 1
    elif pattern == 'pulsar':
        # Пульсар
        pulsar = [
            [0,0,1,1,1,0,0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [0,0,1,1,1,0,0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0,0,1,1,1,0,0],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [1,0,0,0,0,1,0,1,0,0,0,0,1],
            [0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0,0,1,1,1,0,0]
        ]
        start = size // 2 - 6
        grid[start:start+13, start:start+13] = pulsar
    return grid

def update_grid(grid):
    """Применяет правила игры 'Жизнь'"""
    neighbors = sum([
        np.roll(np.roll(grid, i, 0), j, 1)
        for i in (-1, 0, 1) for j in (-1, 0, 1)
        if (i != 0 or j != 0)
    ])
    # Правила: живая клетка выживает при 2-3 соседях
    # Мёртвая клетка оживает при ровно 3 соседях
    return ((neighbors == 3) | ((grid == 1) & (neighbors == 2))).astype(int)

# Симуляция
size = 50
generations = 50
grid = create_grid(size, 'pulsar')

# Сохраняем историю для визуализации
history = [grid.copy()]
for _ in range(generations):
    grid = update_grid(grid)
    history.append(grid.copy())

# Визуализация нескольких поколений
fig, axes = plt.subplots(2, 4, figsize=(16, 8))
cmap = ListedColormap(['white', '#2563eb'])

steps = [0, 5, 10, 15, 25, 35, 45, 49]
for ax, step in zip(axes.flat, steps):
    ax.imshow(history[step], cmap=cmap)
    ax.set_title(f'Generation {step}')
    ax.axis('off')

plt.suptitle("Conway's Game of Life - Pulsar Pattern", fontsize=16)
plt.tight_layout()
plt.show()

# Статистика популяции
population = [np.sum(h) for h in history]
plt.figure(figsize=(10, 4))
plt.plot(population, 'b-', linewidth=2)
plt.fill_between(range(len(population)), population, alpha=0.3)
plt.xlabel('Generation')
plt.ylabel('Population')
plt.title('Population Over Time')
plt.grid(True, alpha=0.3)
plt.show()

print(f"Initial population: {population[0]}")
print(f"Final population: {population[-1]}")
print(f"Max population: {max(population)} (generation {population.index(max(population))})")`,

        heatmap: `import numpy as np
import matplotlib.pyplot as plt

# Создаём данные для корреляционной матрицы
np.random.seed(42)
n_samples = 100
n_features = 10

# Генерируем коррелированные данные
base = np.random.randn(n_samples, 3)
data = np.column_stack([
    base[:, 0],  # Feature 1
    base[:, 0] + np.random.randn(n_samples) * 0.3,  # Сильно коррелирует с 1
    base[:, 1],  # Feature 3
    base[:, 1] + np.random.randn(n_samples) * 0.5,  # Коррелирует с 3
    base[:, 2],  # Feature 5
    np.random.randn(n_samples),  # Независимый
    base[:, 0] - base[:, 1],  # Комбинация
    np.random.randn(n_samples),  # Независимый
    base[:, 2] * 0.8 + np.random.randn(n_samples) * 0.4,  # Коррелирует с 5
    np.random.randn(n_samples)  # Независимый
])

feature_names = [f'Feature {i+1}' for i in range(10)]

# Вычисляем корреляционную матрицу
corr_matrix = np.corrcoef(data.T)

# Создаём тепловую карту
fig, axes = plt.subplots(1, 2, figsize=(16, 7))

# 1. Корреляционная матрица
im1 = axes[0].imshow(corr_matrix, cmap='RdBu_r', vmin=-1, vmax=1)
axes[0].set_xticks(range(10))
axes[0].set_yticks(range(10))
axes[0].set_xticklabels(feature_names, rotation=45, ha='right')
axes[0].set_yticklabels(feature_names)
axes[0].set_title('Correlation Heatmap', fontsize=14)

# Добавляем значения в ячейки
for i in range(10):
    for j in range(10):
        color = 'white' if abs(corr_matrix[i, j]) > 0.5 else 'black'
        axes[0].text(j, i, f'{corr_matrix[i, j]:.2f}',
                     ha='center', va='center', color=color, fontsize=8)

plt.colorbar(im1, ax=axes[0], label='Correlation')

# 2. Тепловая карта данных
sample_data = data[:20, :]  # Первые 20 наблюдений
im2 = axes[1].imshow(sample_data, cmap='viridis', aspect='auto')
axes[1].set_xlabel('Features')
axes[1].set_ylabel('Samples')
axes[1].set_xticks(range(10))
axes[1].set_xticklabels(feature_names, rotation=45, ha='right')
axes[1].set_title('Data Heatmap (First 20 samples)', fontsize=14)
plt.colorbar(im2, ax=axes[1], label='Value')

plt.tight_layout()
plt.show()

# Кластеризованная тепловая карта
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.spatial.distance import pdist

# Кластеризация признаков
dist = pdist(corr_matrix)
linkage_matrix = linkage(dist, method='ward')

# Получаем порядок кластеризации
from scipy.cluster.hierarchy import leaves_list
order = leaves_list(linkage_matrix)

# Переупорядочиваем матрицу
corr_reordered = corr_matrix[order][:, order]
names_reordered = [feature_names[i] for i in order]

plt.figure(figsize=(10, 8))
plt.imshow(corr_reordered, cmap='RdBu_r', vmin=-1, vmax=1)
plt.xticks(range(10), names_reordered, rotation=45, ha='right')
plt.yticks(range(10), names_reordered)
plt.title('Clustered Correlation Heatmap', fontsize=14)
plt.colorbar(label='Correlation')
plt.tight_layout()
plt.show()

print("Strong correlations (|r| > 0.7):")
for i in range(10):
    for j in range(i+1, 10):
        if abs(corr_matrix[i, j]) > 0.7:
            print(f"  {feature_names[i]} <-> {feature_names[j]}: {corr_matrix[i, j]:.3f}")`,

        monte_carlo: `import numpy as np
import matplotlib.pyplot as plt

# Метод Монте-Карло для вычисления числа Пи
def estimate_pi(n_points):
    """Оценка Pi методом Монте-Карло"""
    # Генерируем случайные точки в квадрате [-1, 1] x [-1, 1]
    x = np.random.uniform(-1, 1, n_points)
    y = np.random.uniform(-1, 1, n_points)

    # Проверяем, попали ли точки в круг
    inside = x**2 + y**2 <= 1

    # Pi ≈ 4 * (точки внутри круга) / (всего точек)
    pi_estimate = 4 * np.sum(inside) / n_points

    return x, y, inside, pi_estimate

# Визуализация для разного количества точек
fig, axes = plt.subplots(2, 2, figsize=(12, 12))
n_values = [100, 1000, 10000, 50000]

for ax, n in zip(axes.flat, n_values):
    x, y, inside, pi_est = estimate_pi(n)

    # Рисуем точки
    ax.scatter(x[inside], y[inside], c='blue', s=1, alpha=0.5, label='Inside')
    ax.scatter(x[~inside], y[~inside], c='red', s=1, alpha=0.5, label='Outside')

    # Рисуем круг
    theta = np.linspace(0, 2*np.pi, 100)
    ax.plot(np.cos(theta), np.sin(theta), 'k-', linewidth=2)

    ax.set_xlim(-1.1, 1.1)
    ax.set_ylim(-1.1, 1.1)
    ax.set_aspect('equal')
    ax.set_title(f'n={n:,}, π ≈ {pi_est:.6f}')
    ax.legend(loc='upper right')

plt.suptitle('Monte Carlo Estimation of π', fontsize=16)
plt.tight_layout()
plt.show()

# Сходимость оценки
n_simulations = 1000
max_points = 10000
estimates = []
ns = np.logspace(1, np.log10(max_points), n_simulations).astype(int)

for n in ns:
    _, _, _, pi_est = estimate_pi(n)
    estimates.append(pi_est)

plt.figure(figsize=(12, 5))
plt.subplot(121)
plt.semilogx(ns, estimates, 'b-', alpha=0.7, label='Estimate')
plt.axhline(y=np.pi, color='r', linestyle='--', label=f'True π = {np.pi:.6f}')
plt.xlabel('Number of Points')
plt.ylabel('π Estimate')
plt.title('Convergence of Monte Carlo Estimation')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(122)
errors = np.abs(np.array(estimates) - np.pi)
plt.loglog(ns, errors, 'g-', alpha=0.7)
plt.xlabel('Number of Points')
plt.ylabel('Absolute Error')
plt.title('Error vs Number of Points')
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"True π: {np.pi:.10f}")
print(f"Final estimate (n={ns[-1]:,}): {estimates[-1]:.10f}")
print(f"Final error: {abs(estimates[-1] - np.pi):.10f}")`,

        random_walk: `import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# 2D Random Walk
def random_walk_2d(n_steps):
    """Генерирует 2D случайное блуждание"""
    # Случайные направления: 0=вверх, 1=вниз, 2=влево, 3=вправо
    directions = np.random.randint(0, 4, n_steps)

    dx = np.zeros(n_steps)
    dy = np.zeros(n_steps)

    dx[directions == 2] = -1  # влево
    dx[directions == 3] = 1   # вправо
    dy[directions == 0] = 1   # вверх
    dy[directions == 1] = -1  # вниз

    x = np.cumsum(dx)
    y = np.cumsum(dy)

    return x, y

# 3D Random Walk (Броуновское движение)
def brownian_motion_3d(n_steps, dt=0.01):
    """Генерирует 3D броуновское движение"""
    # Случайные приращения из нормального распределения
    dx = np.random.randn(n_steps) * np.sqrt(dt)
    dy = np.random.randn(n_steps) * np.sqrt(dt)
    dz = np.random.randn(n_steps) * np.sqrt(dt)

    x = np.cumsum(dx)
    y = np.cumsum(dy)
    z = np.cumsum(dz)

    return x, y, z

# Визуализация 2D
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Несколько 2D траекторий
n_walks = 5
n_steps = 1000
colors = plt.cm.viridis(np.linspace(0, 1, n_walks))

for i in range(n_walks):
    x, y = random_walk_2d(n_steps)
    axes[0].plot(x, y, color=colors[i], alpha=0.7, linewidth=0.8)
    axes[0].scatter(x[-1], y[-1], color=colors[i], s=50, zorder=5)

axes[0].scatter(0, 0, color='red', s=100, marker='*', zorder=10, label='Start')
axes[0].set_xlabel('X')
axes[0].set_ylabel('Y')
axes[0].set_title(f'2D Random Walk ({n_walks} trajectories, {n_steps} steps)')
axes[0].legend()
axes[0].grid(True, alpha=0.3)
axes[0].set_aspect('equal')

# Распределение конечных точек
n_simulations = 1000
final_distances = []
for _ in range(n_simulations):
    x, y = random_walk_2d(n_steps)
    final_distances.append(np.sqrt(x[-1]**2 + y[-1]**2))

axes[1].hist(final_distances, bins=30, density=True, alpha=0.7, color='steelblue')
axes[1].axvline(np.mean(final_distances), color='red', linestyle='--',
                label=f'Mean = {np.mean(final_distances):.1f}')
axes[1].set_xlabel('Final Distance from Origin')
axes[1].set_ylabel('Density')
axes[1].set_title(f'Distribution of Final Distances ({n_simulations} simulations)')
axes[1].legend()

plt.tight_layout()
plt.show()

# 3D Броуновское движение
fig = plt.figure(figsize=(14, 6))

ax1 = fig.add_subplot(121, projection='3d')
n_particles = 3
for i in range(n_particles):
    x, y, z = brownian_motion_3d(2000)
    ax1.plot(x, y, z, alpha=0.8, linewidth=0.5)
    ax1.scatter(x[-1], y[-1], z[-1], s=30)

ax1.scatter(0, 0, 0, color='red', s=100, marker='*')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.set_title('3D Brownian Motion')

# Среднеквадратичное смещение
ax2 = fig.add_subplot(122)
steps = np.arange(1, 2001)
msd_theoretical = steps * 0.01 * 3  # <r²> = 3*D*t для 3D

msd_empirical = []
for step in range(1, 2001, 20):
    distances = []
    for _ in range(100):
        x, y, z = brownian_motion_3d(step)
        distances.append(x[-1]**2 + y[-1]**2 + z[-1]**2)
    msd_empirical.append(np.mean(distances))

ax2.plot(steps, msd_theoretical, 'r-', label='Theoretical MSD', linewidth=2)
ax2.scatter(range(1, 2001, 20), msd_empirical, alpha=0.5, label='Empirical MSD')
ax2.set_xlabel('Time Steps')
ax2.set_ylabel('Mean Squared Displacement')
ax2.set_title('MSD vs Time (Brownian Motion)')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

print(f"Expected final distance (2D, {n_steps} steps): {np.sqrt(n_steps):.2f}")
print(f"Observed mean final distance: {np.mean(final_distances):.2f}")`,

        sorting_viz: `import numpy as np
import matplotlib.pyplot as plt

def bubble_sort_steps(arr):
    """Bubble sort с сохранением шагов"""
    arr = arr.copy()
    steps = [arr.copy()]
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                steps.append(arr.copy())
    return steps

def selection_sort_steps(arr):
    """Selection sort с сохранением шагов"""
    arr = arr.copy()
    steps = [arr.copy()]
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        steps.append(arr.copy())
    return steps

def insertion_sort_steps(arr):
    """Insertion sort с сохранением шагов"""
    arr = arr.copy()
    steps = [arr.copy()]
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
            steps.append(arr.copy())
        arr[j + 1] = key
        steps.append(arr.copy())
    return steps

def quicksort_steps(arr):
    """Quick sort с сохранением шагов"""
    arr = arr.copy()
    steps = [arr.copy()]

    def partition(low, high):
        pivot = arr[high]
        i = low - 1
        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]
                steps.append(arr.copy())
        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        steps.append(arr.copy())
        return i + 1

    def quicksort(low, high):
        if low < high:
            pi = partition(low, high)
            quicksort(low, pi - 1)
            quicksort(pi + 1, high)

    quicksort(0, len(arr) - 1)
    return steps

# Генерируем данные
np.random.seed(42)
n = 20
arr = np.random.randint(1, 100, n)

# Получаем шаги для каждого алгоритма
algorithms = {
    'Bubble Sort': bubble_sort_steps(arr),
    'Selection Sort': selection_sort_steps(arr),
    'Insertion Sort': insertion_sort_steps(arr),
    'Quick Sort': quicksort_steps(arr)
}

# Визуализация начального и конечного состояния
fig, axes = plt.subplots(2, 4, figsize=(16, 8))

colors = plt.cm.viridis(np.linspace(0.2, 0.8, n))

for idx, (name, steps) in enumerate(algorithms.items()):
    # Начальное состояние
    axes[0, idx].bar(range(n), steps[0], color=colors)
    axes[0, idx].set_title(f'{name}\\nInitial State')
    axes[0, idx].set_ylim(0, 110)

    # Конечное состояние
    sorted_colors = [colors[np.where(arr == v)[0][0]] for v in steps[-1]]
    axes[1, idx].bar(range(n), steps[-1], color=sorted_colors)
    axes[1, idx].set_title(f'Final State\\n({len(steps)} steps)')
    axes[1, idx].set_ylim(0, 110)

plt.suptitle('Sorting Algorithms Comparison', fontsize=16)
plt.tight_layout()
plt.show()

# Визуализация процесса сортировки для Bubble Sort
bubble_steps = algorithms['Bubble Sort']
n_frames = min(16, len(bubble_steps))
indices = np.linspace(0, len(bubble_steps)-1, n_frames).astype(int)

fig, axes = plt.subplots(4, 4, figsize=(14, 12))
for ax, idx in zip(axes.flat, indices):
    step_colors = plt.cm.plasma(bubble_steps[idx] / 100)
    ax.bar(range(n), bubble_steps[idx], color=step_colors)
    ax.set_title(f'Step {idx}')
    ax.set_ylim(0, 110)
    ax.set_xticks([])

plt.suptitle('Bubble Sort Step-by-Step Visualization', fontsize=16)
plt.tight_layout()
plt.show()

# Сравнение количества шагов
print("\\nAlgorithm Comparison:")
print("-" * 40)
for name, steps in algorithms.items():
    print(f"{name:20s}: {len(steps):5d} steps")

# Теоретическая сложность
print("\\nTheoretical Complexity (n=20):")
print(f"O(n²) = {n**2}")
print(f"O(n log n) ≈ {int(n * np.log2(n))}")`,

        maze: `import numpy as np
import matplotlib.pyplot as plt
from collections import deque

def generate_maze(width, height):
    """Генерирует лабиринт с помощью алгоритма DFS"""
    # Создаём сетку (1 = стена, 0 = проход)
    maze = np.ones((height * 2 + 1, width * 2 + 1), dtype=int)

    # Стек для DFS
    stack = [(0, 0)]
    visited = {(0, 0)}

    # Направления: вверх, вниз, влево, вправо
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while stack:
        x, y = stack[-1]
        maze[y * 2 + 1, x * 2 + 1] = 0

        # Находим непосещённых соседей
        neighbors = []
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height and (nx, ny) not in visited:
                neighbors.append((nx, ny, dx, dy))

        if neighbors:
            # Выбираем случайного соседа
            nx, ny, dx, dy = neighbors[np.random.randint(len(neighbors))]
            # Убираем стену между текущей и следующей клеткой
            maze[y * 2 + 1 + dy, x * 2 + 1 + dx] = 0
            visited.add((nx, ny))
            stack.append((nx, ny))
        else:
            stack.pop()

    return maze

def solve_maze_bfs(maze, start, end):
    """Решает лабиринт с помощью BFS"""
    height, width = maze.shape
    queue = deque([(start, [start])])
    visited = {start}

    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    while queue:
        (x, y), path = queue.popleft()

        if (x, y) == end:
            return path

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height:
                if maze[ny, nx] == 0 and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    queue.append(((nx, ny), path + [(nx, ny)]))

    return None

# Генерируем и решаем лабиринт
np.random.seed(42)
width, height = 20, 15
maze = generate_maze(width, height)

# Начало и конец
start = (1, 1)
end = (width * 2 - 1, height * 2 - 1)

# Находим путь
path = solve_maze_bfs(maze, start, end)

# Визуализация
fig, axes = plt.subplots(1, 2, figsize=(16, 7))

# Лабиринт без решения
axes[0].imshow(maze, cmap='binary')
axes[0].plot(start[0], start[1], 'go', markersize=10, label='Start')
axes[0].plot(end[0], end[1], 'ro', markersize=10, label='End')
axes[0].set_title('Generated Maze', fontsize=14)
axes[0].legend()
axes[0].axis('off')

# Лабиринт с решением
maze_solved = maze.copy().astype(float)
if path:
    for x, y in path:
        maze_solved[y, x] = 0.5

axes[1].imshow(maze_solved, cmap='RdYlGn_r')
axes[1].plot(start[0], start[1], 'go', markersize=10)
axes[1].plot(end[0], end[1], 'ro', markersize=10)
if path:
    path_x = [p[0] for p in path]
    path_y = [p[1] for p in path]
    axes[1].plot(path_x, path_y, 'b-', linewidth=2, alpha=0.7)
axes[1].set_title(f'Solved Maze (Path length: {len(path) if path else "No path"})', fontsize=14)
axes[1].axis('off')

plt.tight_layout()
plt.show()

# Анализ лабиринтов разных размеров
sizes = [(10, 10), (15, 15), (20, 20), (25, 25)]
path_lengths = []

fig, axes = plt.subplots(2, 2, figsize=(12, 12))

for ax, (w, h) in zip(axes.flat, sizes):
    m = generate_maze(w, h)
    s = (1, 1)
    e = (w * 2 - 1, h * 2 - 1)
    p = solve_maze_bfs(m, s, e)
    path_lengths.append(len(p) if p else 0)

    m_viz = m.copy().astype(float)
    if p:
        for x, y in p:
            m_viz[y, x] = 0.5

    ax.imshow(m_viz, cmap='RdYlGn_r')
    ax.set_title(f'{w}x{h} maze\\nPath: {len(p) if p else 0} steps')
    ax.axis('off')

plt.suptitle('Mazes of Different Sizes', fontsize=16)
plt.tight_layout()
plt.show()

print("Maze Statistics:")
print("-" * 30)
for (w, h), length in zip(sizes, path_lengths):
    print(f"{w}x{h} maze: {length} steps")`,

        markov_text: `import numpy as np
from collections import defaultdict
import re

# Пример текста для обучения (Пушкин)
sample_text = """
Мой дядя самых честных правил,
Когда не в шутку занемог,
Он уважать себя заставил
И лучше выдумать не мог.
Его пример другим наука;
Но, боже мой, какая скука
С больным сидеть и день и ночь,
Не отходя ни шагу прочь!
Какое низкое коварство
Полуживого забавлять,
Ему подушки поправлять,
Печально подносить лекарство,
Вздыхать и думать про себя:
Когда же чёрт возьмёт тебя!
"""

# Второй пример текста (английский)
english_text = """
To be or not to be that is the question
Whether tis nobler in the mind to suffer
The slings and arrows of outrageous fortune
Or to take arms against a sea of troubles
And by opposing end them To die to sleep
No more and by a sleep to say we end
The heartache and the thousand natural shocks
That flesh is heir to Tis a consummation
Devoutly to be wished To die to sleep
"""

class MarkovChain:
    def __init__(self, order=2):
        self.order = order
        self.chain = defaultdict(list)
        self.starts = []

    def train(self, text):
        """Обучает модель на тексте"""
        # Очищаем текст
        words = text.split()

        if len(words) < self.order + 1:
            return

        # Сохраняем начальные n-граммы
        self.starts.append(tuple(words[:self.order]))

        # Строим цепь
        for i in range(len(words) - self.order):
            key = tuple(words[i:i + self.order])
            next_word = words[i + self.order]
            self.chain[key].append(next_word)

    def generate(self, length=50):
        """Генерирует текст"""
        if not self.starts:
            return ""

        # Начинаем со случайного начала
        current = list(self.starts[np.random.randint(len(self.starts))])
        result = list(current)

        for _ in range(length - self.order):
            key = tuple(current)
            if key in self.chain:
                next_word = np.random.choice(self.chain[key])
                result.append(next_word)
                current = current[1:] + [next_word]
            else:
                # Если зашли в тупик, начинаем заново
                current = list(self.starts[np.random.randint(len(self.starts))])
                result.extend(current)

        return ' '.join(result)

# Обучаем модели разного порядка
print("=== Марковские цепи для генерации текста ===\\n")

for order in [1, 2, 3]:
    print(f"\\n--- Порядок {order} ---")

    # Русский текст
    model_ru = MarkovChain(order=order)
    model_ru.train(sample_text)
    generated_ru = model_ru.generate(30)
    print(f"\\nРусский текст (Пушкин):")
    print(f"  {generated_ru}")

    # Английский текст
    model_en = MarkovChain(order=order)
    model_en.train(english_text)
    generated_en = model_en.generate(30)
    print(f"\\nАнглийский текст (Шекспир):")
    print(f"  {generated_en}")

# Визуализация структуры цепи
import matplotlib.pyplot as plt

model = MarkovChain(order=1)
model.train("the cat sat on the mat the cat ate the rat")

# Создаём матрицу переходов
words = list(set(model.train.__code__.co_consts[1].split() if hasattr(model.train.__code__.co_consts[1], 'split') else []))
words = list(set([w for ws in model.chain.values() for w in ws] + [w[0] for w in model.chain.keys()]))
n = len(words)
word_to_idx = {w: i for i, w in enumerate(words)}

transition_matrix = np.zeros((n, n))
for key, values in model.chain.items():
    if key[0] in word_to_idx:
        for v in values:
            if v in word_to_idx:
                transition_matrix[word_to_idx[key[0]], word_to_idx[v]] += 1

# Нормализуем
row_sums = transition_matrix.sum(axis=1, keepdims=True)
row_sums[row_sums == 0] = 1
transition_matrix = transition_matrix / row_sums

plt.figure(figsize=(10, 8))
plt.imshow(transition_matrix, cmap='Blues')
plt.xticks(range(n), words, rotation=45, ha='right')
plt.yticks(range(n), words)
plt.colorbar(label='Transition Probability')
plt.title('Markov Chain Transition Matrix')
plt.xlabel('Next Word')
plt.ylabel('Current Word')
plt.tight_layout()
plt.show()

# Статистика
print("\\n=== Статистика модели ===")
print(f"Уникальных состояний: {len(model.chain)}")
print(f"Средняя ветвистость: {np.mean([len(v) for v in model.chain.values()]):.2f}")`,

        regex_demo: `import re

# Демонстрация регулярных выражений
print("=== Демонстрация регулярных выражений ===\\n")

# Тестовые данные
test_texts = [
    "Email: user@example.com, another.user123@test.org",
    "Phone: +7 (999) 123-45-67, 8-800-555-35-35",
    "IP: 192.168.1.1, 10.0.0.255, 256.1.1.1",
    "Dates: 2024-01-15, 15/01/2024, January 15, 2024",
    "URLs: https://example.com/path?q=test, http://test.org",
    "Prices: $19.99, €15.50, 1000 руб, ¥299",
]

patterns = {
    "Email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}",
    "Phone (RU)": r"(?:\\+7|8)[\\s\\-]?\\(?\\d{3}\\)?[\\s\\-]?\\d{3}[\\s\\-]?\\d{2}[\\s\\-]?\\d{2}",
    "IP Address": r"\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\b",
    "Date (YYYY-MM-DD)": r"\\d{4}-\\d{2}-\\d{2}",
    "URL": r"https?://[^\\s,]+",
    "Price": r"[\\$€¥]\\d+(?:\\.\\d{2})?|\\d+\\s*(?:руб|₽)",
}

for text in test_texts:
    print(f"Text: {text}")
    print("-" * 60)
    for name, pattern in patterns.items():
        matches = re.findall(pattern, text)
        if matches:
            print(f"  {name}: {matches}")
    print()

# Продвинутые примеры
print("\\n=== Продвинутые примеры ===\\n")

# 1. Группы захвата
text = "John Smith (john.smith@email.com) - Manager"
pattern = r"(\\w+)\\s+(\\w+)\\s+\\(([^)]+)\\)\\s+-\\s+(\\w+)"
match = re.search(pattern, text)
if match:
    print("Группы захвата:")
    print(f"  Имя: {match.group(1)}")
    print(f"  Фамилия: {match.group(2)}")
    print(f"  Email: {match.group(3)}")
    print(f"  Должность: {match.group(4)}")

# 2. Именованные группы
pattern = r"(?P<first>\\w+)\\s+(?P<last>\\w+)\\s+\\((?P<email>[^)]+)\\)"
match = re.search(pattern, text)
if match:
    print("\\nИменованные группы:")
    print(f"  {match.groupdict()}")

# 3. Замена с использованием функции
def censor_email(match):
    email = match.group(0)
    name, domain = email.split('@')
    return name[0] + '*' * (len(name)-1) + '@' + domain

text = "Контакты: alice@mail.com и bob@example.org"
censored = re.sub(r"[\\w.]+@[\\w.]+", censor_email, text)
print(f"\\nЦензура email:")
print(f"  До: {text}")
print(f"  После: {censored}")

# 4. Валидация паролей
def validate_password(password):
    checks = {
        "Минимум 8 символов": len(password) >= 8,
        "Заглавная буква": bool(re.search(r"[A-Z]", password)),
        "Строчная буква": bool(re.search(r"[a-z]", password)),
        "Цифра": bool(re.search(r"\\d", password)),
        "Спецсимвол": bool(re.search(r"[!@#$%^&*(),.?\":{}|<>]", password)),
    }
    return checks

passwords = ["weak", "Better123", "Strong@Pass1", "NoSpecial123"]
print("\\nВалидация паролей:")
for pwd in passwords:
    checks = validate_password(pwd)
    passed = sum(checks.values())
    print(f"  '{pwd}': {passed}/5 проверок")
    for check, result in checks.items():
        status = "✓" if result else "✗"
        print(f"    {status} {check}")

# 5. Парсинг логов
log_line = '[2024-01-15 14:30:45] ERROR: Connection failed (code: 500)'
pattern = r"\\[([\\d-]+)\\s+([\\d:]+)\\]\\s+(\\w+):\\s+(.+?)\\s+\\(code:\\s+(\\d+)\\)"
match = re.search(pattern, log_line)
if match:
    print("\\nПарсинг лога:")
    print(f"  Дата: {match.group(1)}")
    print(f"  Время: {match.group(2)}")
    print(f"  Уровень: {match.group(3)}")
    print(f"  Сообщение: {match.group(4)}")
    print(f"  Код: {match.group(5)}")`,

        distributions: `import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# Настройка стиля
plt.style.use('default')

# Создаём фигуру для дискретных распределений
fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# 1. Биномиальное распределение
ax = axes[0, 0]
n, p = 20, 0.5
x = np.arange(0, n+1)
pmf = stats.binom.pmf(x, n, p)
ax.bar(x, pmf, color='steelblue', alpha=0.7)
ax.set_title(f'Binomial (n={n}, p={p})')
ax.set_xlabel('k')
ax.set_ylabel('P(X=k)')
ax.axvline(n*p, color='red', linestyle='--', label=f'μ={n*p}')
ax.legend()

# 2. Распределение Пуассона
ax = axes[0, 1]
lambda_ = 5
x = np.arange(0, 20)
pmf = stats.poisson.pmf(x, lambda_)
ax.bar(x, pmf, color='green', alpha=0.7)
ax.set_title(f'Poisson (λ={lambda_})')
ax.set_xlabel('k')
ax.set_ylabel('P(X=k)')
ax.axvline(lambda_, color='red', linestyle='--', label=f'μ={lambda_}')
ax.legend()

# 3. Геометрическое распределение
ax = axes[0, 2]
p = 0.3
x = np.arange(1, 20)
pmf = stats.geom.pmf(x, p)
ax.bar(x, pmf, color='orange', alpha=0.7)
ax.set_title(f'Geometric (p={p})')
ax.set_xlabel('k')
ax.set_ylabel('P(X=k)')
ax.legend()

# 4. Нормальное распределение
ax = axes[1, 0]
x = np.linspace(-4, 4, 1000)
for mu, sigma in [(0, 1), (0, 0.5), (0, 2)]:
    pdf = stats.norm.pdf(x, mu, sigma)
    ax.plot(x, pdf, label=f'μ={mu}, σ={sigma}', linewidth=2)
ax.set_title('Normal Distribution')
ax.set_xlabel('x')
ax.set_ylabel('f(x)')
ax.legend()
ax.grid(True, alpha=0.3)

# 5. Экспоненциальное распределение
ax = axes[1, 1]
x = np.linspace(0, 5, 1000)
for lambda_ in [0.5, 1, 2]:
    pdf = stats.expon.pdf(x, scale=1/lambda_)
    ax.plot(x, pdf, label=f'λ={lambda_}', linewidth=2)
ax.set_title('Exponential Distribution')
ax.set_xlabel('x')
ax.set_ylabel('f(x)')
ax.legend()
ax.grid(True, alpha=0.3)

# 6. Равномерное распределение
ax = axes[1, 2]
x = np.linspace(-1, 6, 1000)
for a, b in [(0, 1), (1, 3), (2, 5)]:
    pdf = stats.uniform.pdf(x, a, b-a)
    ax.plot(x, pdf, label=f'[{a}, {b}]', linewidth=2)
ax.set_title('Uniform Distribution')
ax.set_xlabel('x')
ax.set_ylabel('f(x)')
ax.legend()
ax.grid(True, alpha=0.3)
ax.set_ylim(0, 1.5)

plt.tight_layout()
plt.show()

# Центральная предельная теорема
fig, axes = plt.subplots(2, 3, figsize=(15, 8))

# Исходное распределение (экспоненциальное)
sample_sizes = [1, 2, 5, 10, 30, 100]
n_simulations = 10000
lambda_exp = 1

for ax, n in zip(axes.flat, sample_sizes):
    # Генерируем выборочные средние
    means = [np.mean(np.random.exponential(1/lambda_exp, n)) for _ in range(n_simulations)]

    ax.hist(means, bins=50, density=True, alpha=0.7, color='steelblue')

    # Теоретическое нормальное распределение
    if n > 1:
        x = np.linspace(min(means), max(means), 100)
        theoretical = stats.norm.pdf(x, 1/lambda_exp, 1/(lambda_exp * np.sqrt(n)))
        ax.plot(x, theoretical, 'r-', linewidth=2, label='Normal approx')
        ax.legend()

    ax.set_title(f'n = {n}')
    ax.set_xlabel('Sample Mean')
    ax.set_ylabel('Density')

plt.suptitle('Central Limit Theorem Demo (Exponential → Normal)', fontsize=14)
plt.tight_layout()
plt.show()

# Статистика
print("Distribution Statistics:")
print("-" * 50)
print(f"Normal(0,1): mean={stats.norm.mean():.2f}, var={stats.norm.var():.2f}")
print(f"Exponential(1): mean={stats.expon.mean():.2f}, var={stats.expon.var():.2f}")
print(f"Poisson(5): mean={stats.poisson.mean(5):.2f}, var={stats.poisson.var(5):.2f}")
print(f"Binomial(20,0.5): mean={stats.binom.mean(20,0.5):.2f}, var={stats.binom.var(20,0.5):.2f}")`,

        fourier: `import numpy as np
import matplotlib.pyplot as plt

# Быстрое преобразование Фурье (FFT)
print("=== Демонстрация преобразования Фурье ===\\n")

# Параметры
fs = 1000  # Частота дискретизации (Гц)
T = 1.0    # Длительность сигнала (сек)
t = np.linspace(0, T, int(fs * T), endpoint=False)

# Создаём сложный сигнал: сумма синусоид
frequencies = [5, 20, 50]  # Гц
amplitudes = [1.0, 0.5, 0.3]

signal = sum(a * np.sin(2 * np.pi * f * t) for f, a in zip(frequencies, amplitudes))
# Добавляем шум
signal_noisy = signal + np.random.normal(0, 0.2, len(t))

# Применяем FFT
fft_result = np.fft.fft(signal_noisy)
fft_freq = np.fft.fftfreq(len(t), 1/fs)
fft_magnitude = np.abs(fft_result) / len(t) * 2

# Визуализация
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 1. Исходный сигнал
axes[0, 0].plot(t[:200], signal[:200], 'b-', label='Clean signal', linewidth=1.5)
axes[0, 0].plot(t[:200], signal_noisy[:200], 'gray', alpha=0.5, label='Noisy signal')
axes[0, 0].set_xlabel('Time (s)')
axes[0, 0].set_ylabel('Amplitude')
axes[0, 0].set_title('Time Domain Signal')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# 2. Спектр (только положительные частоты)
pos_mask = fft_freq >= 0
axes[0, 1].plot(fft_freq[pos_mask][:100], fft_magnitude[pos_mask][:100], 'r-', linewidth=1.5)
axes[0, 1].set_xlabel('Frequency (Hz)')
axes[0, 1].set_ylabel('Magnitude')
axes[0, 1].set_title('Frequency Spectrum (FFT)')
for f, a in zip(frequencies, amplitudes):
    axes[0, 1].axvline(f, color='green', linestyle='--', alpha=0.7)
    axes[0, 1].annotate(f'{f} Hz', (f, a), textcoords="offset points", xytext=(5,5))
axes[0, 1].grid(True, alpha=0.3)

# 3. Спектрограмма
axes[1, 0].specgram(signal_noisy, Fs=fs, cmap='viridis')
axes[1, 0].set_xlabel('Time (s)')
axes[1, 0].set_ylabel('Frequency (Hz)')
axes[1, 0].set_title('Spectrogram')
axes[1, 0].set_ylim(0, 100)

# 4. Фильтрация сигнала
# Создаём низкочастотный фильтр
cutoff = 30  # Гц
fft_filtered = fft_result.copy()
fft_filtered[np.abs(fft_freq) > cutoff] = 0
signal_filtered = np.real(np.fft.ifft(fft_filtered))

axes[1, 1].plot(t[:200], signal_noisy[:200], 'gray', alpha=0.5, label='Noisy')
axes[1, 1].plot(t[:200], signal_filtered[:200], 'b-', linewidth=1.5, label='Filtered')
axes[1, 1].plot(t[:200], signal[:200], 'g--', alpha=0.7, label='Original')
axes[1, 1].set_xlabel('Time (s)')
axes[1, 1].set_ylabel('Amplitude')
axes[1, 1].set_title(f'Low-pass Filtered Signal (cutoff={cutoff} Hz)')
axes[1, 1].legend()
axes[1, 1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Демонстрация свойств преобразования Фурье
fig, axes = plt.subplots(2, 3, figsize=(15, 8))

# Разные сигналы
signals = {
    'Sine (10 Hz)': np.sin(2 * np.pi * 10 * t),
    'Square Wave': np.sign(np.sin(2 * np.pi * 5 * t)),
    'Sawtooth': 2 * (t * 5 % 1) - 1,
    'Chirp': np.sin(2 * np.pi * (5 + 45 * t) * t),
    'Pulse': np.where((t > 0.4) & (t < 0.6), 1, 0).astype(float),
    'Gaussian': np.exp(-((t - 0.5) ** 2) / (2 * 0.05 ** 2))
}

for ax, (name, sig) in zip(axes.flat, signals.items()):
    # FFT
    fft = np.fft.fft(sig)
    freq = np.fft.fftfreq(len(t), 1/fs)
    mag = np.abs(fft) / len(t) * 2

    # Рисуем спектр
    pos = freq >= 0
    ax.plot(freq[pos][:100], mag[pos][:100], 'b-', linewidth=1.5)
    ax.set_title(name)
    ax.set_xlabel('Frequency (Hz)')
    ax.set_ylabel('Magnitude')
    ax.grid(True, alpha=0.3)

plt.suptitle('Fourier Spectra of Different Signals', fontsize=14)
plt.tight_layout()
plt.show()

# Статистика
print("\\nSignal Analysis:")
print("-" * 40)
print(f"Detected frequencies: {frequencies} Hz")
print(f"Signal duration: {T} s")
print(f"Sampling rate: {fs} Hz")
print(f"Frequency resolution: {fs/len(t):.2f} Hz")`,
      };

      // Добавляем стили для маркеров линтера
      const styles = `
            .lint-marker {
                width: 16px;
                height: 16px;
                background-position: center center;
                background-repeat: no-repeat;
            }
            
            .lint-marker.error {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23dc2626'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z'/%3E%3C/svg%3E");
            }
            
            .lint-marker.warning {
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23f59e0b'%3E%3Cpath d='M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z'/%3E%3C/svg%3E");
            }
            
            .lint-error-line {
                background-color: rgba(220, 38, 38, 0.1);
            }
            
            .lint-warning-line {
                background-color: rgba(245, 158, 11, 0.1);
            }
        `;

      // Добавляем стили в head
      const styleSheet = document.createElement('style');
      styleSheet.type = 'text/css';
      styleSheet.innerText = styles;
      document.head.appendChild(styleSheet);

      // Рендерим приложение
      // React 18 рендеринг
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>
