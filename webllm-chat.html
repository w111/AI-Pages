<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebLLM Chat - Локальный ИИ в браузере</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <!--
    Техническое описание:
    - WebLLM для локального запуска LLM в браузере
    - Поддержка Llama 3, Mistral, Phi-3, Qwen и других моделей
    - OpenAI-совместимый API интерфейс
    - Полностью клиентская реализация без серверов
    - WebGPU для ускорения вычислений
    - Tool Calling с интеграцией внешних API:
      * Wikipedia API - поиск информации и фактов
      * Open-Meteo API - погода и прогнозы
      * ExchangeRate API - курсы валют
      * CoinGecko API - криптовалюты
      * MusicBrainz API - музыка и артисты
      * TheSportsDB API - спорт и команды

    История изменений:
    2025-01-26: Первоначальная версия WebLLM Chat
    2025-12-12: Добавлен Tool Calling с 6 API интеграциями
    2025-12-12: Добавлена история чатов с хранением в localStorage
              Интерфейс переделан в стиле ChatGPT
              Настройки модели скрыты в выдвижную панель
  -->

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --primary-color: #10a37f;
        --secondary-color: #19c37d;
        --bg-color: #0a0a0a;
        --card-bg: #1a1a1a;
        --chat-bg: #2a2a2a;
        --text-color: #ffffff;
        --text-secondary: #d1d5db;
        --border-color: #374151;
        --user-msg-bg: #3b82f6;
        --ai-msg-bg: #374151;
        --success-color: #10b981;
        --warning-color: #f59e0b;
        --error-color: #ef4444;
      }

      body {
        font-family:
          'Segoe UI',
          system-ui,
          -apple-system,
          sans-serif;
        background: linear-gradient(135deg, var(--bg-color) 0%, #1a1a2e 100%);
        color: var(--text-color);
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      /* App Header in Sidebar */
      .app-header-section {
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .app-title {
        font-size: 1.4rem;
        color: white;
        margin-bottom: 5px;
        font-weight: 600;
      }

      .app-title i {
        margin-right: 8px;
        color: rgba(255, 255, 255, 0.9);
      }

      .app-subtitle {
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.9rem;
        margin: 0;
      }

      .compatibility-warning {
        background: #fef3c7;
        color: #92400e;
        padding: 10px 15px;
        margin: 10px 20px;
        border-radius: 8px;
        border-left: 4px solid var(--warning-color);
      }

      .requirements-header {
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 10px;
      }

      .requirements-header i {
        transition: transform 0.3s ease;
      }

      .requirements-header.collapsed i {
        transform: rotate(-90deg);
      }

      .requirements-content {
        max-height: 200px;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .requirements-content.collapsed {
        max-height: 0;
      }

      .main-container {
        display: flex;
        height: 100vh;
        min-height: 0;
        overflow: hidden;
      }

      /* Chat History Sidebar (ChatGPT style) */
      .chat-history-sidebar {
        width: 260px;
        background: #171717;
        border-right: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        min-height: 0;
        transition: transform 0.3s ease, width 0.3s ease;
      }

      .chat-history-sidebar.collapsed {
        width: 0;
        transform: translateX(-260px);
        overflow: hidden;
      }

      .sidebar-header {
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 1px solid var(--border-color);
      }

      .new-chat-btn {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px 16px;
        background: transparent;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        color: var(--text-color);
        cursor: pointer;
        font-size: 0.95rem;
        transition: all 0.2s ease;
      }

      .new-chat-btn:hover {
        background: var(--chat-bg);
      }

      .toggle-sidebar-btn {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 8px;
        margin-left: 8px;
        transition: all 0.2s ease;
      }

      .toggle-sidebar-btn:hover {
        background: var(--chat-bg);
        color: var(--text-color);
      }

      .chat-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }

      .chat-list-item {
        display: flex;
        align-items: center;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-bottom: 4px;
        position: relative;
      }

      .chat-list-item:hover {
        background: var(--chat-bg);
      }

      .chat-list-item.active {
        background: var(--chat-bg);
      }

      .chat-list-item .chat-icon {
        width: 20px;
        margin-right: 12px;
        color: var(--text-secondary);
      }

      .chat-list-item .chat-title {
        flex: 1;
        font-size: 0.9rem;
        color: var(--text-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .chat-list-item .chat-delete {
        opacity: 0;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s ease;
      }

      .chat-list-item:hover .chat-delete {
        opacity: 1;
      }

      .chat-list-item .chat-delete:hover {
        background: var(--border-color);
        color: var(--error-color);
      }

      .sidebar-footer {
        padding: 12px;
        border-top: 1px solid var(--border-color);
      }

      .sidebar-footer-btn {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: transparent;
        border: none;
        border-radius: 8px;
        color: var(--text-color);
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }

      .sidebar-footer-btn:hover {
        background: var(--chat-bg);
      }

      .sidebar-footer-btn i {
        width: 20px;
        color: var(--text-secondary);
      }

      /* Model Settings Sidebar (hidden by default) */
      .model-sidebar {
        width: 320px;
        background: var(--card-bg);
        border-left: 1px solid var(--border-color);
        padding: 15px;
        overflow-y: auto;
        min-height: 0;
        position: fixed;
        right: 0;
        top: 0;
        bottom: 0;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 200;
      }

      .model-sidebar.show {
        transform: translateX(0);
      }

      .model-sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 199;
      }

      .model-sidebar-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .model-sidebar-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
      }

      .model-sidebar-close {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .model-sidebar-close:hover {
        background: var(--bg-color);
        color: var(--text-color);
      }

      /* Expand sidebar button (when collapsed) */
      .expand-sidebar-btn {
        position: fixed;
        top: 12px;
        left: 12px;
        width: 40px;
        height: 40px;
        display: none;
        align-items: center;
        justify-content: center;
        background: var(--card-bg);
        border: 1px solid var(--border-color);
        color: var(--text-color);
        cursor: pointer;
        border-radius: 8px;
        z-index: 100;
        transition: all 0.2s ease;
      }

      .expand-sidebar-btn.show {
        display: flex;
      }

      .expand-sidebar-btn:hover {
        background: var(--chat-bg);
      }

      /* Old sidebar (keep for compatibility but hide) */
      .sidebar {
        display: none;
        width: 300px;
        background: var(--card-bg);
        border-right: 1px solid var(--border-color);
        padding: 15px;
        overflow-y: auto;
        min-height: 0;
      }

      .model-section {
        margin-bottom: 20px;
      }

      .section-title {
        color: var(--primary-color);
        font-size: 1.2rem;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .model-select {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: var(--bg-color);
        color: var(--text-color);
        font-size: 1rem;
        margin-bottom: 15px;
      }

      .model-select option {
        padding: 8px;
        background: var(--bg-color);
        color: var(--text-color);
      }

      .model-dropdown {
        position: relative;
        margin-bottom: 15px;
      }

      .model-dropdown-button {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: var(--bg-color);
        color: var(--text-color);
        font-size: 1rem;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: all 0.3s ease;
      }

      .model-dropdown-button:hover {
        border-color: var(--primary-color);
      }

      .model-dropdown-button.open {
        border-color: var(--primary-color);
        border-radius: 8px 8px 0 0;
      }

      .model-dropdown-content {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--bg-color);
        border: 1px solid var(--primary-color);
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 400px;
        overflow-y: auto;
        z-index: 100;
        display: none;
      }

      .model-dropdown-content.show {
        display: block;
      }

      .model-option {
        padding: 12px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color);
        transition: background-color 0.2s ease;
      }

      .model-option:last-child {
        border-bottom: none;
      }

      .model-option:hover {
        background: var(--border-color);
      }

      .model-option.selected {
        background: var(--primary-color);
        color: white;
      }

      .model-option-header {
        font-weight: 600;
        margin-bottom: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .model-option-size {
        font-size: 0.8rem;
        color: var(--text-secondary);
      }

      .model-option-desc {
        font-size: 0.85rem;
        color: var(--text-secondary);
        margin-bottom: 8px;
        line-height: 1.3;
      }

      .model-option-specs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .model-spec-tag {
        font-size: 0.75rem;
        padding: 2px 6px;
        background: var(--chat-bg);
        border-radius: 3px;
        color: var(--text-secondary);
      }

      .status-indicator {
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 15px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .status-loading {
        background: rgba(245, 158, 11, 0.1);
        border: 1px solid var(--warning-color);
        color: var(--warning-color);
      }

      .status-ready {
        background: rgba(16, 185, 129, 0.1);
        border: 1px solid var(--success-color);
        color: var(--success-color);
      }

      .status-error {
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid var(--error-color);
        color: var(--error-color);
      }

      .progress-container {
        margin: 15px 0;
        display: none;
      }

      .progress-container.show {
        display: block;
      }

      .progress-bar {
        width: 100%;
        height: 6px;
        background: var(--border-color);
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 8px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--primary-color),
          var(--secondary-color)
        );
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 0.85rem;
        color: var(--text-secondary);
        text-align: center;
      }

      .settings-section {
        margin-top: 15px;
      }

      .setting-item {
        margin-bottom: 12px;
      }

      .setting-item label {
        display: block;
        margin-bottom: 5px;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }

      .setting-input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-color);
        color: var(--text-color);
        font-size: 0.9rem;
      }

      .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--chat-bg);
        min-height: 0;
        position: relative;
      }

      .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px 20px 100px 20px;
        scroll-behavior: smooth;
      }

      .message {
        margin-bottom: 20px;
        display: flex;
        gap: 12px;
      }

      .message.user {
        justify-content: flex-end;
      }

      .message.user .message-content {
        background: var(--user-msg-bg);
        color: white;
        margin-left: 50px;
      }

      .message.ai .message-content {
        background: var(--ai-msg-bg);
        color: var(--text-color);
        margin-right: 50px;
      }

      .message-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        flex-shrink: 0;
      }

      .message.user .message-avatar {
        background: var(--user-msg-bg);
        color: white;
        order: 2;
      }

      .message.ai .message-avatar {
        background: var(--primary-color);
        color: white;
      }

      .message-content {
        padding: 12px 16px;
        border-radius: 12px;
        max-width: 70%;
        line-height: 1.5;
        word-wrap: break-word;
      }

      .message-content pre {
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 6px;
        overflow-x: auto;
        margin: 8px 0;
      }

	      .message-content code {
	        background: rgba(0, 0, 0, 0.3);
	        padding: 2px 4px;
	        border-radius: 3px;
	        font-family: 'Courier New', monospace;
	      }
	
	      .message-content a {
	        color: #8ab4f8;
	        text-decoration: underline;
	      }
	
	      .message-content a:hover {
	        color: #a8c7ff;
	      }

      .chat-input-container {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 20px;
        border-top: 1px solid var(--border-color);
        background: var(--card-bg);
        z-index: 10;
      }

      .chat-input-wrapper {
        display: flex;
        gap: 10px;
        align-items: flex-end;
      }

      .chat-input {
        flex: 1;
        min-height: 50px;
        max-height: 150px;
        padding: 12px 16px;
        border: 1px solid var(--border-color);
        border-radius: 25px;
        background: var(--bg-color);
        color: var(--text-color);
        font-size: 1rem;
        resize: none;
        overflow-y: auto;
      }

      .chat-input:focus {
        outline: none;
        border-color: var(--primary-color);
      }

      .send-button {
        width: 50px;
        height: 50px;
        border: none;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        transition: all 0.3s ease;
      }

      .send-button:hover:not(:disabled) {
        background: var(--secondary-color);
        transform: scale(1.05);
      }

      .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .typing-indicator {
        margin-bottom: 20px;
        display: none;
      }

      .typing-indicator.show {
        display: flex;
        gap: 12px;
      }

      .typing-content {
        background: var(--ai-msg-bg);
        padding: 12px 16px;
        border-radius: 12px;
        margin-right: 50px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .typing-dots {
        display: flex;
        gap: 4px;
      }

      .typing-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-secondary);
        animation: typingAnimation 1.4s infinite;
      }

      .typing-dot:nth-child(2) {
        animation-delay: 0.2s;
      }

      .typing-dot:nth-child(3) {
        animation-delay: 0.4s;
      }

      @keyframes typingAnimation {
        0%,
        60%,
        100% {
          opacity: 0.3;
        }
        30% {
          opacity: 1;
        }
      }

      .welcome-message {
        text-align: center;
        padding: 40px 20px;
        color: var(--text-secondary);
      }

      .welcome-message i {
        font-size: 3rem;
        color: var(--primary-color);
        margin-bottom: 20px;
      }

      .action-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .action-btn {
        flex: 1;
        padding: 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--bg-color);
        color: var(--text-color);
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
      }

      .action-btn:hover {
        background: var(--border-color);
      }

      .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .requirements-btn {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--warning-color);
        border-radius: 6px;
        background: rgba(245, 158, 11, 0.1);
        color: var(--warning-color);
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 0.9rem;
        margin-top: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .requirements-btn:hover {
        background: rgba(245, 158, 11, 0.2);
      }

      /* Accordion Styles */
      .accordion-item {
        margin-bottom: 10px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        overflow: hidden;
      }

      .accordion-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 15px;
        background: var(--chat-bg);
        cursor: pointer;
        transition: all 0.3s ease;
        border-bottom: 1px solid transparent;
      }

      .accordion-header:hover {
        background: var(--border-color);
      }

      .accordion-header.active {
        border-bottom-color: var(--border-color);
      }

      .accordion-header .section-title {
        margin: 0;
        flex: 1;
      }

      .accordion-icon {
        transition: transform 0.3s ease;
        color: var(--text-secondary);
      }

      .accordion-header.active .accordion-icon {
        transform: rotate(180deg);
      }

      .accordion-content {
        padding: 15px;
        background: var(--bg-color);
        max-height: 1000px;
        overflow: hidden;
        transition:
          max-height 0.3s ease,
          padding 0.3s ease;
      }

      .accordion-content.collapsed {
        max-height: 0;
        padding: 0 15px;
      }

      /* System message styles */
      .message.system-message {
        opacity: 0.9;
      }

      .message.system-message .message-content {
        background: linear-gradient(135deg, var(--primary-color), #667eea);
        color: white;
        border-radius: 12px;
        padding: 12px 16px;
        margin-right: 0;
      }

      .message.system-message .message-avatar {
        background: linear-gradient(135deg, var(--primary-color), #667eea);
        color: white;
      }

      /* Tool call styles */
      .message.tool-call {
        opacity: 0.85;
      }

      .message.tool-call .message-content {
        background: linear-gradient(135deg, #f39c12, #e67e22);
        color: white;
        border-radius: 12px;
        padding: 12px 16px;
        font-size: 0.9rem;
      }

      .message.tool-call .message-avatar {
        background: linear-gradient(135deg, #f39c12, #e67e22);
        color: white;
      }

      .message.tool-result {
        opacity: 0.9;
      }

      .message.tool-result .message-content {
        background: linear-gradient(135deg, #27ae60, #2ecc71);
        color: white;
        border-radius: 12px;
        padding: 12px 16px;
      }

      .message.tool-result .message-avatar {
        background: linear-gradient(135deg, #27ae60, #2ecc71);
        color: white;
      }

      .tool-result-data {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        padding: 10px;
        margin-top: 8px;
        font-size: 0.85rem;
        max-height: 200px;
        overflow-y: auto;
      }

      /* Tools toggle section */
      .tools-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .tool-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: var(--bg-color);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid transparent;
      }

      .tool-item:hover {
        border-color: var(--primary-color);
      }

      .tool-item.active {
        background: rgba(16, 163, 127, 0.2);
        border-color: var(--primary-color);
      }

      .tool-item input[type="checkbox"] {
        display: none;
      }

      .tool-item .tool-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        font-size: 0.9rem;
      }

      .tool-item .tool-name {
        font-size: 0.85rem;
        flex: 1;
      }

      .tool-item .tool-check {
        width: 18px;
        height: 18px;
        border: 2px solid var(--border-color);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .tool-item.active .tool-check {
        background: var(--primary-color);
        border-color: var(--primary-color);
      }

      .tool-item.active .tool-check::after {
        content: '✓';
        color: white;
        font-size: 12px;
      }

      .tools-info {
        font-size: 0.8rem;
        color: var(--text-secondary);
        margin-top: 10px;
        padding: 8px;
        background: var(--bg-color);
        border-radius: 6px;
        border-left: 3px solid var(--primary-color);
      }

      .requirements-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .requirements-modal.show {
        display: flex;
      }

      .requirements-content {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 25px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        position: relative;
      }

      .requirements-close {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 1.5rem;
        padding: 5px;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .requirements-close:hover {
        background: var(--bg-color);
        color: var(--text-color);
      }

      .requirements-title {
        color: var(--primary-color);
        font-size: 1.4rem;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .requirements-list {
        margin: 15px 0 0 20px;
      }

      .requirements-list li {
        margin-bottom: 10px;
        color: var(--text-color);
      }

      .tech-note {
        background: var(--bg-color);
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        border-left: 4px solid var(--primary-color);
      }

      /* Chat header */
      .chat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
        border-bottom: 1px solid var(--border-color);
        background: var(--card-bg);
      }

      .chat-header-left {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .chat-header-model {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: var(--bg-color);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .chat-header-model:hover {
        background: var(--chat-bg);
      }

      .chat-header-model .model-name {
        font-size: 0.95rem;
        font-weight: 500;
      }

      .chat-header-model .model-status {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--warning-color);
      }

      .chat-header-model .model-status.ready {
        background: var(--success-color);
      }

      .chat-header-right {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .chat-header-btn {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .chat-header-btn:hover {
        background: var(--bg-color);
        color: var(--text-color);
      }

      /* Hide old settings button */
      .settings-button {
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background: var(--primary-color);
        color: white;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        transition: background 0.3s ease;
      }

      .settings-button:hover {
        background: var(--secondary-color);
      }

      /* Модальное окно настроек */
      .settings-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .settings-modal.show {
        display: flex;
      }

      .settings-content {
        background: var(--card-bg);
        border-radius: 12px;
        padding: 25px;
        max-width: 400px;
        width: 90%;
        border: 1px solid var(--border-color);
        position: relative;
      }

      .settings-close {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        font-size: 1.5rem;
        padding: 5px;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .settings-close:hover {
        background: var(--bg-color);
        color: var(--text-color);
      }

      .settings-title {
        color: var(--primary-color);
        font-size: 1.8rem;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .settings-option {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 15px;
      }

      .settings-option label {
        font-size: 1.1rem;
        color: var(--text-color);
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toggle-switch {
        position: relative;
        width: 50px;
        height: 28px;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--border-color);
        border-radius: 28px;
        transition: 0.4s;
      }

      .slider:before {
        position: absolute;
        content: '';
        height: 22px;
        width: 22px;
        left: 3px;
        bottom: 3px;
        border-radius: 50%;
        background-color: var(--text-color);
        transition: 0.4s;
      }

      input:checked + .slider {
        background-color: var(--primary-color);
      }

      input:focus + .slider {
        box-shadow: 0 0 1px var(--primary-color);
      }

      input:checked + .slider:before {
        transform: translateX(22px);
      }

      @media (max-width: 768px) {
        .main-container {
          flex-direction: column;
        }

        .chat-history-sidebar {
          position: fixed;
          left: 0;
          top: 0;
          bottom: 0;
          z-index: 300;
          width: 280px;
        }

        .chat-history-sidebar.collapsed {
          transform: translateX(-280px);
        }

        .model-sidebar {
          width: 100%;
        }

        .sidebar {
          display: none;
        }

        .chat-messages {
          padding: 15px 15px 120px 15px;
        }

        .chat-input-container {
          padding: 15px;
        }

        .message-content {
          max-width: 85%;
        }

        .header {
          padding: 10px 20px;
          flex-shrink: 0;
        }

        .header h1 {
          font-size: 1.8rem;
          margin-bottom: 2px;
        }

        .header p {
          font-size: 1rem;
        }

        .compatibility-warning {
          margin: 5px 10px;
          padding: 8px 12px;
        }

        .model-section {
          margin-bottom: 15px;
        }

        .setting-item {
          margin-bottom: 10px;
        }

        .expand-sidebar-btn {
          top: auto;
          bottom: 90px;
          left: 12px;
        }

        .chat-header {
          padding: 10px 12px;
        }

        .chat-header-model .model-name {
          max-width: 120px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      }
    </style>
  </head>
  <body>
    <!-- Кнопка расширения sidebar -->
    <button class="expand-sidebar-btn" id="expandSidebarBtn" title="Открыть историю чатов">
      <i class="fas fa-bars"></i>
    </button>

    <!-- Модальное окно настроек -->
    <div class="settings-modal" id="settingsModal" role="dialog" aria-labelledby="settingsTitle" aria-modal="true">
      <div class="settings-content">
        <button class="settings-close" onclick="closeSettingsModal()">
          <i class="fas fa-times"></i>
        </button>
        <h3 class="settings-title" id="settingsTitle">
          <i class="fas fa-sliders-h"></i> Настройки
        </h3>
        <div class="settings-option">
          <label for="themeSwitch">
            <i class="fas fa-moon"></i> Темная тема
          </label>
          <label class="toggle-switch">
            <input type="checkbox" id="themeSwitch">
            <span class="slider"></span>
          </label>
        </div>
      </div>
    </div>

    <!-- Model Settings Sidebar Overlay -->
    <div class="model-sidebar-overlay" id="modelSidebarOverlay"></div>

    <!-- Model Settings Sidebar (скрыта по умолчанию) -->
    <div class="model-sidebar" id="modelSidebar">
      <div class="model-sidebar-header">
        <h3 class="section-title" style="margin: 0;">
          <i class="fas fa-cog"></i>
          Настройки модели
        </h3>
        <button class="model-sidebar-close" id="closeModelSidebar">
          <i class="fas fa-times"></i>
        </button>
      </div>

      <div class="model-section">
        <h4 class="section-title">
          <i class="fas fa-microchip"></i>
          Выбор модели
        </h4>

        <div class="model-dropdown" id="modelDropdown">
          <div class="model-dropdown-button" id="modelDropdownButton">
            <span id="selectedModelText">Qwen-3-4B-Instruct (Рекомендуется)</span>
            <i class="fas fa-chevron-down"></i>
          </div>
          <div class="model-dropdown-content" id="modelDropdownContent">
            <div class="model-option selected" data-model="qwen-3-4b">
              <div class="model-option-header">
                <span>Qwen-3-4B-Instruct</span>
                <span class="model-option-size">2.0GB</span>
              </div>
              <div class="model-option-desc">
                Лучшая компактная модель от Alibaba. Отличное качество при небольшом размере.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">3GB VRAM</span>
                <span class="model-spec-tag">Очень быстрая</span>
                <span class="model-spec-tag">Рекомендуется</span>
              </div>
            </div>

            <div class="model-option" data-model="qwen-3-8b">
              <div class="model-option-header">
                <span>Qwen-3-8B-Instruct</span>
                <span class="model-option-size">4.5GB</span>
              </div>
              <div class="model-option-desc">
                Многоязычная модель от Alibaba с отличным пониманием контекста.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">6GB VRAM</span>
                <span class="model-spec-tag">Быстрая</span>
                <span class="model-spec-tag">Многоязычная</span>
              </div>
            </div>

            <div class="model-option" data-model="llama-3-8b">
              <div class="model-option-header">
                <span>Llama-3-8B-Instruct</span>
                <span class="model-option-size">4.3GB</span>
              </div>
              <div class="model-option-desc">
                Мощная модель от Meta. Отличное качество ответов и понимание контекста.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">6GB VRAM</span>
                <span class="model-spec-tag">Высокое качество</span>
              </div>
            </div>

            <div class="model-option" data-model="mistral-7b">
              <div class="model-option-header">
                <span>Mistral-7B-Instruct</span>
                <span class="model-option-size">3.8GB</span>
              </div>
              <div class="model-option-desc">
                Быстрая и эффективная модель от Mistral AI. Хороший баланс скорости и качества.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">5GB VRAM</span>
                <span class="model-spec-tag">Быстрая</span>
                <span class="model-spec-tag">Высокое качество</span>
              </div>
            </div>

            <div class="model-option" data-model="phi-3-mini">
              <div class="model-option-header">
                <span>Phi-3-Mini-4K</span>
                <span class="model-option-size">2.2GB</span>
              </div>
              <div class="model-option-desc">
                Компактная модель от Microsoft. Идеальна для быстрых ответов и небольших задач.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">3GB VRAM</span>
                <span class="model-spec-tag">Очень быстрая</span>
                <span class="model-spec-tag">Компактная</span>
              </div>
            </div>

            <div class="model-option" data-model="gemma-3n-4b">
              <div class="model-option-header">
                <span>Gemma-3n-4B-Instruct</span>
                <span class="model-option-size">2.5GB</span>
              </div>
              <div class="model-option-desc">
                Компактная модель Google с адаптивной активацией параметров. 140+ языков.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">3.5GB VRAM</span>
                <span class="model-spec-tag">Быстрая</span>
                <span class="model-spec-tag">Многоязычная</span>
              </div>
            </div>

            <div class="model-option" data-model="smollm2-1.7b">
              <div class="model-option-header">
                <span>SmolLM2-1.7B</span>
                <span class="model-option-size">1.0GB</span>
              </div>
              <div class="model-option-desc">
                Ультра-компактная модель. Минимальные требования к памяти.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">2GB VRAM</span>
                <span class="model-spec-tag">Мгновенная</span>
                <span class="model-spec-tag">Ультра-компактная</span>
              </div>
            </div>

            <div class="model-option" data-model="demo">
              <div class="model-option-header">
                <span>Демо-режим</span>
                <span class="model-option-size">0MB</span>
              </div>
              <div class="model-option-desc">
                Демонстрационный режим без загрузки модели. Показывает примеры интерфейса.
              </div>
              <div class="model-option-specs">
                <span class="model-spec-tag">Без загрузки</span>
                <span class="model-spec-tag">Мгновенная</span>
                <span class="model-spec-tag">Тестирование UI</span>
              </div>
            </div>
          </div>
        </div>

        <div class="status-indicator" id="statusIndicator">
          <i class="fas fa-circle-notch fa-spin"></i>
          <span>Инициализация...</span>
        </div>

        <div class="progress-container" id="progressContainer">
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
          <div class="progress-text" id="progressText">Загрузка модели...</div>
        </div>

        <div class="action-buttons">
          <button class="action-btn" id="loadModelBtn" onclick="loadSelectedModel()">
            <i class="fas fa-download"></i> Загрузить
          </button>
        </div>
      </div>

      <!-- Инструменты (Tool Calling) -->
      <div class="accordion-item">
        <div class="accordion-header active" onclick="toggleAccordion('toolsSettings')">
          <h3 class="section-title">
            <i class="fas fa-tools"></i>
            Инструменты
          </h3>
          <i class="fas fa-chevron-down accordion-icon"></i>
        </div>
        <div id="toolsSettings" class="accordion-content">
          <div class="tools-grid" id="toolsGrid">
            <label class="tool-item active" data-tool="wikipedia">
              <input type="checkbox" checked>
              <span class="tool-icon" style="background: #667eea; color: white;">
                <i class="fab fa-wikipedia-w"></i>
              </span>
              <span class="tool-name">Wikipedia</span>
              <span class="tool-check"></span>
            </label>
            <label class="tool-item active" data-tool="weather">
              <input type="checkbox" checked>
              <span class="tool-icon" style="background: #3498db; color: white;">
                <i class="fas fa-cloud-sun"></i>
              </span>
              <span class="tool-name">Погода</span>
              <span class="tool-check"></span>
            </label>
            <label class="tool-item active" data-tool="currency">
              <input type="checkbox" checked>
              <span class="tool-icon" style="background: #27ae60; color: white;">
                <i class="fas fa-dollar-sign"></i>
              </span>
              <span class="tool-name">Валюты</span>
              <span class="tool-check"></span>
            </label>
            <label class="tool-item active" data-tool="crypto">
              <input type="checkbox" checked>
              <span class="tool-icon" style="background: #f7931a; color: white;">
                <i class="fab fa-bitcoin"></i>
              </span>
              <span class="tool-name">Крипто</span>
              <span class="tool-check"></span>
            </label>
            <label class="tool-item active" data-tool="music">
              <input type="checkbox" checked>
              <span class="tool-icon" style="background: #9b59b6; color: white;">
                <i class="fas fa-music"></i>
              </span>
              <span class="tool-name">Музыка</span>
              <span class="tool-check"></span>
            </label>
	            <label class="tool-item active" data-tool="sports">
	              <input type="checkbox" checked>
	              <span class="tool-icon" style="background: #e74c3c; color: white;">
	                <i class="fas fa-futbol"></i>
	              </span>
	              <span class="tool-name">Спорт</span>
	              <span class="tool-check"></span>
	            </label>
	            <label class="tool-item active" data-tool="websearch">
	              <input type="checkbox" checked>
	              <span class="tool-icon" style="background: #2d9cdb; color: white;">
	                <i class="fas fa-search"></i>
	              </span>
	              <span class="tool-name">WebSearch</span>
	              <span class="tool-check"></span>
	            </label>
	            <label class="tool-item active" data-tool="openurl">
	              <input type="checkbox" checked>
	              <span class="tool-icon" style="background: #34495e; color: white;">
	                <i class="fas fa-link"></i>
	              </span>
	              <span class="tool-name">Open URL</span>
	              <span class="tool-check"></span>
	            </label>
	          </div>
	          <div class="tools-info">
	            <i class="fas fa-info-circle"></i>
	            ИИ автоматически вызывает инструменты для получения актуальных данных
	          </div>
        </div>
      </div>

      <!-- Базовые настройки -->
      <div class="accordion-item">
        <div class="accordion-header" onclick="toggleAccordion('basicSettings')">
          <h3 class="section-title">
            <i class="fas fa-sliders-h"></i>
            Параметры генерации
          </h3>
          <i class="fas fa-chevron-down accordion-icon"></i>
        </div>
        <div id="basicSettings" class="accordion-content collapsed">
          <div class="setting-item">
            <label for="temperature">Temperature (креативность):</label>
            <input
              type="range"
              id="temperature"
              class="setting-input"
              min="0"
              max="2"
              step="0.1"
              value="0.7"
            />
            <small style="color: var(--text-secondary)"
              >Текущее: <span id="temperatureValue">0.7</span></small
            >
          </div>

          <div class="setting-item">
            <label for="maxTokens">Максимум токенов:</label>
            <input
              type="range"
              id="maxTokens"
              class="setting-input"
              min="50"
              max="2048"
              step="50"
              value="512"
            />
            <small style="color: var(--text-secondary)"
              >Текущее: <span id="maxTokensValue">512</span></small
            >
          </div>

          <div class="setting-item">
            <label for="systemPrompt">Системный промпт:</label>
            <textarea
              id="systemPrompt"
              class="setting-input"
              rows="3"
              placeholder="Ты - полезный ИИ-ассистент..."
            >Ты - полезный ИИ-ассистент. Отвечай кратко и по делу.</textarea>
          </div>
        </div>
      </div>

      <button class="requirements-btn" onclick="showRequirements()">
        <i class="fas fa-info-circle"></i>
        Системные требования
      </button>
    </div>

    <div class="main-container">
      <!-- Chat History Sidebar -->
      <div class="chat-history-sidebar" id="chatHistorySidebar">
        <div class="sidebar-header">
          <button class="new-chat-btn" id="newChatBtn">
            <i class="fas fa-plus"></i>
            <span>Новый чат</span>
          </button>
          <button class="toggle-sidebar-btn" id="toggleSidebarBtn" title="Свернуть">
            <i class="fas fa-chevron-left"></i>
          </button>
        </div>

        <div class="chat-list" id="chatList">
          <!-- Chat history items will be rendered here -->
        </div>

        <div class="sidebar-footer">
          <button class="sidebar-footer-btn" id="openSettingsBtn">
            <i class="fas fa-cog"></i>
            <span>Настройки модели</span>
          </button>
          <button class="sidebar-footer-btn" id="clearAllChatsBtn">
            <i class="fas fa-trash-alt"></i>
            <span>Очистить историю</span>
          </button>
        </div>
      </div>

      <div class="chat-container">
        <!-- Chat Header -->
        <div class="chat-header">
          <div class="chat-header-left">
            <div class="chat-header-model" id="chatHeaderModel" title="Открыть настройки модели">
              <span class="model-status" id="modelStatusDot"></span>
              <span class="model-name" id="headerModelName">WebLLM Chat</span>
              <i class="fas fa-chevron-down" style="font-size: 0.7rem; color: var(--text-secondary);"></i>
            </div>
          </div>
          <div class="chat-header-right">
            <button class="chat-header-btn" id="clearCurrentChatBtn" title="Очистить чат">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>

        <div class="chat-messages" id="chatMessages">
          <div class="welcome-message" id="welcomeMessage">
            <i class="fas fa-comments"></i>
            <h3>Добро пожаловать в WebLLM Chat!</h3>
            <p>Выберите модель и начните общение с ИИ прямо в браузере</p>
            <p style="font-size: 0.9rem; margin-top: 10px">
              🔒 Полная конфиденциальность - все вычисления локально<br />
              ⚡ Без API-ключей и интернета после загрузки модели<br />
              🚀 Использует ваш GPU для быстрых ответов
            </p>
            <p style="font-size: 0.85rem; margin-top: 15px; color: var(--primary-color)">
              🔧 <strong>Tool Calling:</strong> Спросите о погоде, курсах валют,<br />
              криптовалютах, музыке или спорте!
            </p>
          </div>

          <div class="typing-indicator" id="typingIndicator">
            <div class="message-avatar">
              <i class="fas fa-robot"></i>
            </div>
            <div class="typing-content">
              <span>ИИ печатает</span>
              <div class="typing-dots">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="chat-input-container">
          <div class="chat-input-wrapper">
            <textarea
              id="chatInput"
              class="chat-input"
              placeholder="Напишите ваше сообщение..."
              rows="1"
            ></textarea>
            <button id="sendButton" class="send-button">
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Модальное окно системных требований -->
    <div class="requirements-modal" id="requirementsModal">
      <div class="requirements-content">
        <button class="requirements-close" onclick="hideRequirements()">
          <i class="fas fa-times"></i>
        </button>

        <h2 class="requirements-title">
          <i class="fas fa-exclamation-triangle"></i>
          Системные требования
        </h2>

        <h3 style="color: var(--text-color); margin-bottom: 15px">
          Минимальные требования:
        </h3>
        <ul class="requirements-list">
	          <li>
	            <strong>Браузер:</strong> Chrome/Edge с WebGPU или Safari на iPadOS/iOS 17.4+ с WebGPU
	          </li>
          <li>
            <strong>GPU:</strong> Минимум 6GB видеопамяти (рекомендуется 8GB+ для
            больших моделей)
          </li>
          <li>
            <strong>Интернет:</strong> Стабильное соединение для первичной загрузки
            модели
          </li>
          <li><strong>Память:</strong> Минимум 8GB оперативной памяти</li>
        </ul>

        <h3 style="color: var(--text-color); margin: 20px 0 15px 0">
          Рекомендуемое оборудование:
        </h3>
        <ul class="requirements-list">
          <li><strong>Apple:</strong> Mac с чипом M1/M2/M3 (любая модель)</li>
          <li><strong>NVIDIA:</strong> RTX 3070+, RTX 4000+, A100, H100</li>
          <li><strong>AMD:</strong> RX 6800+, RX 7000+</li>
          <li><strong>Intel:</strong> Arc A750+</li>
        </ul>

        <div class="tech-note">
          <h4 style="color: var(--primary-color); margin-bottom: 10px">
            <i class="fas fa-microchip"></i> Технические детали:
          </h4>
          <p style="margin-bottom: 10px">
            <strong>WebLLM + WebGPU:</strong> Запуск больших языковых моделей локально в
            браузере без серверов
          </p>
          <p style="margin-bottom: 10px">
            <strong>Поддерживаемые модели:</strong> Llama-3-8B (~4.3GB), Mistral-7B
            (~3.8GB), Phi-3-Mini (~2.2GB), Gemma-2B (~1.5GB)
          </p>
          <p>
            <strong>Приватность:</strong> Все вычисления происходят локально, данные не
            передаются на внешние серверы
          </p>
        </div>

        <div style="margin-top: 20px; text-align: center">
          <button
            class="action-btn"
            onclick="hideRequirements()"
            style="width: auto; padding: 10px 20px"
          >
            Понятно
          </button>
        </div>
      </div>
    </div>

    <script type="module">
      // Централизованная библиотека настроек aiPagesSettings
      window.aiPagesSettings = {
        // Дефолтные значения настроек (для WebLLM темная тема по умолчанию)
        defaults: {
          theme: 'dark',
          language: 'ru',
          view: 'grid'
        },

        // Получить значение настройки
        get(key) {
          const value = localStorage.getItem(key);
          return value !== null ? value : this.defaults[key];
        },

        // Установить значение настройки
        set(key, value) {
          localStorage.setItem(key, value);

          // Автоматически применяем изменения
          if (key === 'theme') {
            this.applyTheme();
          } else if (key === 'language') {
            this.applyLanguage();
          }
        },

        // Применить тему
        applyTheme() {
          const theme = this.get('theme');
          document.documentElement.setAttribute('data-theme', theme);

          // Обновляем checkbox если он есть
          const themeSwitch = document.getElementById('themeSwitch');
          if (themeSwitch) {
            themeSwitch.checked = theme === 'dark';
          }
        },

        // Применить язык
        applyLanguage() {
          const language = this.get('language');
          document.documentElement.setAttribute('lang', language);
        },

        // Инициализация
        init() {
          this.applyTheme();
          this.applyLanguage();
        }
      };

      /**
       * ToolManager - Менеджер инструментов для WebLLM Chat
       * Поддерживает Wikipedia, Weather, Currency, Crypto, Music, Sports API
       */
	      class ToolManager {
	        constructor() {
	          this.enabledTools = {
	            wikipedia: true,
	            weather: true,
	            currency: true,
	            crypto: true,
	            music: true,
	            sports: true,
	            websearch: true,
	            openurl: true
	          };

          // Определения инструментов
	          this.toolDefinitions = {
            wikipedia: {
              name: 'wikipedia_search',
              description: 'Поиск информации в Wikipedia. Используй для получения фактов, биографий, описаний понятий.',
              parameters: {
                query: 'Поисковый запрос (название статьи или термин)'
              }
            },
            weather: {
              name: 'get_weather',
              description: 'Получение текущей погоды и прогноза. Используй когда спрашивают о погоде в городе.',
              parameters: {
                city: 'Название города'
              }
            },
            currency: {
              name: 'get_currency_rate',
              description: 'Получение курсов валют. Используй для конвертации или получения актуального курса.',
              parameters: {
                from: 'Код исходной валюты (USD, EUR, RUB и т.д.)',
                to: 'Код целевой валюты (опционально)',
                amount: 'Сумма для конвертации (опционально)'
              }
            },
            crypto: {
              name: 'get_crypto_price',
              description: 'Получение цен криптовалют. Используй для Bitcoin, Ethereum и других криптовалют.',
              parameters: {
                coin: 'Название криптовалюты (bitcoin, ethereum, и т.д.)'
              }
            },
            music: {
              name: 'search_music',
              description: 'Поиск информации о музыке. Используй для артистов, альбомов, треков.',
              parameters: {
                query: 'Имя артиста или название альбома/трека',
                type: 'Тип поиска: artist, album, track (по умолчанию artist)'
              }
            },
	            sports: {
	              name: 'search_sports',
	              description: 'Поиск спортивной информации. Используй для команд, лиг, соревнований.',
	              parameters: {
	                query: 'Название команды или лиги'
	              }
	            },
	            websearch: {
	              name: 'web_search',
	              description: 'Поиск по открытым источникам без прокси (Wikipedia, arXiv, OpenAlex, StackOverflow, GitHub, Hacker News). Возвращает список ссылок и краткие сниппеты.',
	              parameters: {
	                query: 'Поисковый запрос',
	                limit: 'Сколько результатов вернуть (опционально, по умолчанию 8)'
	              }
	            },
	            openurl: {
	              name: 'open_url',
	              description: 'Открывает ссылку и возвращает текст (без прокси работает только для некоторых источников/URL; многие сайты блокируются CORS). Используй после web_search для чтения 1-2 самых релевантных ссылок.',
	              parameters: {
	                url: 'URL для открытия',
	                max_chars: 'Максимум символов текста (опционально, по умолчанию 8000)'
	              }
	            }
	          };
	        }

        /**
         * Генерация системного промпта с описанием инструментов
         */
        getToolsSystemPrompt() {
          const enabledToolsList = Object.entries(this.enabledTools)
            .filter(([_, enabled]) => enabled)
            .map(([tool]) => this.toolDefinitions[tool]);

          if (enabledToolsList.length === 0) {
            return '';
          }

          let prompt = `\n\nУ тебя есть доступ к следующим инструментам для получения актуальных данных:\n\n`;

          enabledToolsList.forEach(tool => {
            prompt += `**${tool.name}**: ${tool.description}\n`;
            prompt += `Параметры: ${JSON.stringify(tool.parameters)}\n\n`;
          });

	          prompt += `Когда тебе нужно использовать инструмент, отправь ТОЛЬКО вызов (без пояснений) в одном из форматов:
	<tool_call>{"tool": "название_инструмента", "params": {"param1": "value1"}}</tool_call>
	или просто JSON:
	{"tool": "название_инструмента", "params": {"param1": "value1"}}

	После получения результата, сформулируй ответ пользователю на основе полученных данных.
	Если нужна информация из интернета: сначала вызови web_search, затем при необходимости open_url для 1-2 результатов.
	Используй инструменты только когда это действительно нужно для ответа на вопрос.`;

          return prompt;
        }

	        /**
	         * Проверка, содержит ли ответ вызов инструмента
	         */
	        hasToolCall(response) {
	          return this.extractToolCall(response) !== null;
	        }

	        /**
	         * Извлечение вызова инструмента из ответа
	         */
	        extractToolCall(response) {
	          const text = this.normalizeToolText(response);
	          if (!text) return null;
	
	          // 1) Формат с тегами
	          const tagMatch = text.match(/<tool_call>([\s\S]*?)<\/tool_call>/i);
	          if (tagMatch) {
	            return this.parseAndNormalizeToolCall(tagMatch[1]);
	          }
	
	          // 2) JSON в fenced code block (```json ... ```)
	          const fencedMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
	          if (fencedMatch) {
	            const parsed = this.parseAndNormalizeToolCall(fencedMatch[1]);
	            if (parsed) return parsed;
	          }
	
	          // 3) Чистый JSON целиком
	          if (text.startsWith('{') && text.endsWith('}')) {
	            const parsed = this.parseAndNormalizeToolCall(text);
	            if (parsed) return parsed;
	          }
	
	          // 4) JSON внутри текста (модели иногда добавляют слова/пробелы/невидимые символы)
	          const embedded = this.findEmbeddedToolCallJson(text);
	          if (embedded) return embedded;
	
	          return null;
	        }
	
	        normalizeToolText(text) {
	          // Убираем BOM/zero-width символы, которые ломают startsWith('{') у некоторых моделей
	          return (text || '').replace(/[\u200B-\u200D\uFEFF]/g, '').trim();
	        }
	
	        findEmbeddedToolCallJson(text) {
	          const toolNames = Object.values(this.toolDefinitions).map(def => def.name);
	          const re = /"tool"\s*:\s*"([^"]+)"/g;
	          let match;
	          while ((match = re.exec(text))) {
	            const toolName = match[1];
	            if (!toolNames.includes(toolName)) continue;
	
	            const jsonText = this.extractBalancedJsonObject(text, match.index);
	            if (!jsonText) continue;
	
	            const parsed = this.parseAndNormalizeToolCall(jsonText);
	            if (parsed) return parsed;
	          }
	          return null;
	        }
	
	        extractBalancedJsonObject(text, aroundIndex) {
	          const start = text.lastIndexOf('{', aroundIndex);
	          if (start === -1) return null;
	
	          let depth = 0;
	          let inString = false;
	          let escape = false;
	
	          for (let i = start; i < text.length; i++) {
	            const ch = text[i];
	
	            if (inString) {
	              if (escape) {
	                escape = false;
	              } else if (ch === '\\') {
	                escape = true;
	              } else if (ch === '"') {
	                inString = false;
	              }
	              continue;
	            }
	
	            if (ch === '"') {
	              inString = true;
	              continue;
	            }
	
	            if (ch === '{') {
	              depth++;
	            } else if (ch === '}') {
	              depth--;
	              if (depth === 0) {
	                return text.slice(start, i + 1);
	              }
	            }
	          }
	
	          return null;
	        }
	
	        parseAndNormalizeToolCall(jsonText) {
	          try {
	            const raw = JSON.parse((jsonText || '').trim());
	
	            // Поддерживаем вариации ключей от разных моделей:
	            // - { tool, params }
	            // - { tool, parameters }
	            // - { tool, args }
	            if (!raw || typeof raw !== 'object' || Array.isArray(raw)) return null;
	            if (typeof raw.tool !== 'string' || !raw.tool.trim()) return null;
	
	            const tool = raw.tool.trim();
	            const params =
	              (raw.params && typeof raw.params === 'object' && !Array.isArray(raw.params) ? raw.params : null) ||
	              (raw.parameters && typeof raw.parameters === 'object' && !Array.isArray(raw.parameters) ? raw.parameters : null) ||
	              (raw.args && typeof raw.args === 'object' && !Array.isArray(raw.args) ? raw.args : null) ||
	              {};
	
	            // Валидируем, что это действительно наш инструмент
	            const toolKey = this.getToolKeyByName(tool);
	            if (!toolKey) return null;
	
	            return { tool, params };
	          } catch (e) {
	            console.error('Ошибка парсинга tool call:', e);
	            return null;
	          }
	        }
	
	        /**
	         * Получение ключа включения по имени инструмента (wikipedia/weather/...)
	         */
	        getToolKeyByName(toolName) {
	          const entry = Object.entries(this.toolDefinitions).find(([_, def]) => def.name === toolName);
	          return entry ? entry[0] : null;
	        }
	
	        /**
	         * Выполнение вызова инструмента
	         */
	        async executeToolCall(toolCall) {
	          const { tool, params } = toolCall;
	
	          const toolKey = this.getToolKeyByName(tool);
	          if (!toolKey) {
	            return { error: `Неизвестный инструмент: ${tool}` };
	          }
	          if (!this.enabledTools[toolKey]) {
	            return { error: `Инструмент отключен в настройках: ${tool}` };
	          }
	
		          switch (tool) {
		            case 'wikipedia_search':
		              return await this.searchWikipedia(params.query);
		            case 'get_weather':
		              return await this.getWeather(params.city);
		            case 'get_currency_rate':
		              return await this.getCurrencyRate(params.from, params.to, params.amount);
		            case 'get_crypto_price':
		              return await this.getCryptoPrice(params.coin);
		            case 'search_music':
		              return await this.searchMusic(params.query, params.type);
		            case 'search_sports':
		              return await this.searchSports(params.query);
		            case 'web_search':
		              return await this.webSearch(params.query, params.limit);
		            case 'open_url':
		              return await this.openUrl(params.url, params.max_chars);
		            default:
		              return { error: `Неизвестный инструмент: ${tool}` };
		          }
		        }
	
	        /**
	         * Wikipedia API
	         */
	        async searchWikipedia(query) {
          try {
            const url = `https://ru.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(query)}&prop=extracts&exintro=1&format=json&origin=*`;
            const response = await fetch(url);
            const data = await response.json();

            const pages = data.query.pages;
            const pageId = Object.keys(pages)[0];

            if (pageId === '-1') {
              // Попробуем поиск
              const searchUrl = `https://ru.wikipedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(query)}&format=json&origin=*&srlimit=3`;
              const searchResp = await fetch(searchUrl);
              const searchData = await searchResp.json();

              if (searchData.query.search.length > 0) {
                const firstResult = searchData.query.search[0];
                return {
                  source: 'Wikipedia',
                  title: firstResult.title,
                  snippet: firstResult.snippet.replace(/<[^>]*>/g, ''),
                  suggestion: `Возможно вы имели в виду: ${firstResult.title}`
                };
              }
              return { error: 'Статья не найдена в Wikipedia' };
            }

            const page = pages[pageId];
            const extract = page.extract ? page.extract.replace(/<[^>]*>/g, '').substring(0, 1000) : '';

            return {
              source: 'Wikipedia',
              title: page.title,
              content: extract + (extract.length >= 1000 ? '...' : ''),
              url: `https://ru.wikipedia.org/wiki/${encodeURIComponent(page.title)}`
            };
          } catch (error) {
            return { error: `Ошибка Wikipedia API: ${error.message}` };
          }
        }

        /**
         * Weather API (Open-Meteo)
         */
        async getWeather(city) {
          try {
            // Геокодинг через Nominatim
            const geoUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(city)}&limit=1`;
            const geoResp = await fetch(geoUrl);
            const geoData = await geoResp.json();

            if (geoData.length === 0) {
              return { error: `Город "${city}" не найден` };
            }

            const { lat, lon, display_name } = geoData[0];

            // Погода через Open-Meteo
            const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min,weather_code&timezone=auto&forecast_days=3`;
            const weatherResp = await fetch(weatherUrl);
            const weatherData = await weatherResp.json();

            const weatherCodes = {
              0: 'Ясно', 1: 'Преимущественно ясно', 2: 'Переменная облачность', 3: 'Пасмурно',
              45: 'Туман', 48: 'Изморозь', 51: 'Мелкая морось', 53: 'Морось', 55: 'Сильная морось',
              61: 'Небольшой дождь', 63: 'Дождь', 65: 'Сильный дождь',
              71: 'Небольшой снег', 73: 'Снег', 75: 'Сильный снегопад',
              95: 'Гроза', 96: 'Гроза с градом', 99: 'Сильная гроза с градом'
            };

            const current = weatherData.current;
            const daily = weatherData.daily;

            return {
              source: 'Open-Meteo',
              location: display_name,
              current: {
                temperature: `${current.temperature_2m}°C`,
                humidity: `${current.relative_humidity_2m}%`,
                wind: `${current.wind_speed_10m} км/ч`,
                conditions: weatherCodes[current.weather_code] || 'Неизвестно'
              },
              forecast: daily.time.slice(0, 3).map((date, i) => ({
                date: new Date(date).toLocaleDateString('ru-RU', { weekday: 'short', day: 'numeric', month: 'short' }),
                max: `${daily.temperature_2m_max[i]}°C`,
                min: `${daily.temperature_2m_min[i]}°C`,
                conditions: weatherCodes[daily.weather_code[i]] || 'Неизвестно'
              }))
            };
          } catch (error) {
            return { error: `Ошибка Weather API: ${error.message}` };
          }
        }

        /**
         * Currency API (ExchangeRate)
         */
	        async getCurrencyRate(from = 'USD', to = null, amount = null) {
	          try {
	            // CORS-friendly endpoint for browser apps
	            const url = `https://open.er-api.com/v6/latest/${from.toUpperCase()}`;
	            const response = await fetch(url);
	            const data = await response.json();
	
	            // open.er-api.com returns { result: "error", "error-type": "..." }
	            if (data.result && data.result !== 'success') {
	              return { error: data['error-type'] || 'Ошибка Currency API' };
	            }
	
	            const result = {
	              source: 'ER-API',
	              base: from.toUpperCase(),
	              date: data.time_last_update_utc || data.time_last_update_unix || null
	            };
	
	            if (to) {
	              const rate = data.rates?.[to.toUpperCase()];
	              if (rate) {
	                result.rate = `1 ${from.toUpperCase()} = ${rate.toFixed(4)} ${to.toUpperCase()}`;
	                if (amount) {
	                  result.converted = `${amount} ${from.toUpperCase()} = ${(amount * rate).toFixed(2)} ${to.toUpperCase()}`;
	                }
	              } else {
                result.error = `Валюта ${to} не найдена`;
              }
            } else {
              // Показываем основные валюты
              const mainCurrencies = ['EUR', 'RUB', 'GBP', 'CNY', 'JPY'];
              result.rates = {};
              mainCurrencies.forEach(curr => {
                if (data.rates[curr] && curr !== from.toUpperCase()) {
                  result.rates[curr] = data.rates[curr].toFixed(4);
                }
              });
            }

	            return result;
	          } catch (error) {
	            return { error: `Ошибка Currency API: ${error.message}` };
	          }
	        }

	        /**
	         * Crypto API (CoinGecko)
	         */
	        async getCryptoPrice(coin = 'bitcoin') {
	          const fetchJson = async (url, timeoutMs = 12000) => {
	            const controller = new AbortController();
	            const t = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	              const resp = await fetch(url, { signal: controller.signal });
	              const json = await resp.json();
	              return { ok: resp.ok, status: resp.status, json };
	            } finally {
	              clearTimeout(t);
	            }
	          };
	
	          const coinQuery = String(coin || '').toLowerCase().trim();
	          const normalized = coinQuery.replace(/\s+/g, '-');
	
	          // 1) CoinCap (часто работает, но у некоторых может блокироваться расширениями/политиками)
	          try {
	            const url = `https://api.coincap.io/v2/assets?search=${encodeURIComponent(normalized)}`;
	            const { ok, json } = await fetchJson(url);
	            const assets = Array.isArray(json?.data) ? json.data : [];
	            if (ok && assets.length > 0) {
	              const asset = assets[0];
	              const priceUsd = Number(asset.priceUsd);
	              const change24h = Number(asset.changePercent24Hr);
	              const marketCapUsd = Number(asset.marketCapUsd);
	
	              return {
	                source: 'CoinCap',
	                name: asset.name,
	                symbol: String(asset.symbol || '').toUpperCase(),
	                price_usd: Number.isFinite(priceUsd)
	                  ? `$${priceUsd.toLocaleString(undefined, { maximumFractionDigits: 6 })}`
	                  : 'N/A',
	                change_24h: Number.isFinite(change24h) ? `${change24h.toFixed(2)}%` : 'N/A',
	                market_cap: Number.isFinite(marketCapUsd) ? `$${(marketCapUsd / 1e9).toFixed(2)}B` : 'N/A',
	                rank: asset.rank ? `#${asset.rank}` : 'N/A',
	                id: asset.id
	              };
	            }
	          } catch (_) {
	            // continue to fallbacks
	          }
	
	          // 2) CoinGecko (simple price) — часто CORS OK
	          try {
	            const searchUrl = `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(coinQuery)}`;
	            const search = await fetchJson(searchUrl);
	            const first = Array.isArray(search?.json?.coins) ? search.json.coins[0] : null;
	            if (search.ok && first?.id) {
	              const priceUrl =
	                `https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(first.id)}` +
	                `&vs_currencies=usd,rub&include_24hr_change=true`;
	              const priceResp = await fetchJson(priceUrl);
	              const p = priceResp?.json?.[first.id];
	              if (priceResp.ok && p) {
	                const usd = Number(p.usd);
	                const rub = Number(p.rub);
	                const ch = Number(p.usd_24h_change);
	                return {
	                  source: 'CoinGecko',
	                  name: first.name,
	                  symbol: String(first.symbol || '').toUpperCase(),
	                  price_usd: Number.isFinite(usd) ? `$${usd.toLocaleString()}` : 'N/A',
	                  price_rub: Number.isFinite(rub) ? `₽${rub.toLocaleString()}` : 'N/A',
	                  change_24h: Number.isFinite(ch) ? `${ch.toFixed(2)}%` : 'N/A',
	                  id: first.id
	                };
	              }
	            }
	          } catch (_) {
	            // continue
	          }
	
	          // 3) Coinbase spot price (пары для популярных монет)
	          try {
	            const symbolMap = {
	              bitcoin: 'BTC',
	              btc: 'BTC',
	              ethereum: 'ETH',
	              eth: 'ETH',
	              solana: 'SOL',
	              sol: 'SOL',
	              toncoin: 'TON',
	              ton: 'TON',
	              ripple: 'XRP',
	              xrp: 'XRP'
	            };
	            const sym = symbolMap[normalized] || symbolMap[coinQuery];
	            if (sym) {
	              const url = `https://api.coinbase.com/v2/prices/${encodeURIComponent(sym)}-USD/spot`;
	              const { ok, json } = await fetchJson(url);
	              const amount = Number(json?.data?.amount);
	              if (ok && Number.isFinite(amount)) {
	                return {
	                  source: 'Coinbase',
	                  name: sym,
	                  symbol: sym,
	                  price_usd: `$${amount.toLocaleString()}`
	                };
	              }
	            }
	          } catch (_) {
	            // continue
	          }
	
	          return {
	            error:
	              `Не удалось получить цену для "${coin}". ` +
	              `Возможные причины: блокировка CORS, AdBlock/Privacy extensions, VPN или временная недоступность API.`
	          };
	        }

        /**
         * Music API (MusicBrainz)
         */
	        async searchMusic(query, type = 'artist') {
	          try {
	            // MusicBrainz требует User-Agent, который нельзя выставить из браузера.
	            // Используем iTunes Search API (CORS-friendly) как лёгкую замену.
	            const entity =
	              type === 'album' ? 'album' : type === 'track' ? 'song' : 'musicArtist';
	            const url = `https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=${entity}&limit=5`;
	            const response = await fetch(url);
	            const data = await response.json();
	
	            const results = Array.isArray(data?.results) ? data.results : [];
	            if (results.length === 0) {
	              return { error: `По запросу "${query}" ничего не найдено` };
	            }
	
	            const mapped = results.slice(0, 3).map(item => {
	              if (type === 'artist') {
	                return {
	                  name: item.artistName || item.collectionArtistName || 'Неизвестно',
	                  genre: item.primaryGenreName || 'Неизвестно',
	                  link: item.artistLinkUrl || 'N/A'
	                };
	              }
	              if (type === 'album') {
	                return {
	                  title: item.collectionName || 'Неизвестно',
	                  artist: item.artistName || 'Неизвестно',
	                  year: item.releaseDate ? String(item.releaseDate).substring(0, 4) : 'Неизвестно',
	                  link: item.collectionViewUrl || 'N/A'
	                };
	              }
	              return {
	                title: item.trackName || 'Неизвестно',
	                artist: item.artistName || 'Неизвестно',
	                album: item.collectionName || 'Неизвестно',
	                duration: item.trackTimeMillis ? `${Math.floor(item.trackTimeMillis / 60000)}:${String(Math.floor((item.trackTimeMillis % 60000) / 1000)).padStart(2, '0')}` : 'Неизвестно',
	                link: item.trackViewUrl || 'N/A'
	              };
	            });
	
	            return {
	              source: 'iTunes',
	              query: query,
	              type: type,
	              results: mapped
	            };
	          } catch (error) {
	            return { error: `Ошибка Music API: ${error.message}` };
	          }
	        }

        /**
         * Sports API (TheSportsDB)
         */
	        async searchSports(query) {
	          try {
            const url = `https://www.thesportsdb.com/api/v1/json/3/searchteams.php?t=${encodeURIComponent(query)}`;
            const response = await fetch(url);
            const data = await response.json();

            if (!data.teams || data.teams.length === 0) {
              // Попробуем поиск лиг
              const leagueUrl = `https://www.thesportsdb.com/api/v1/json/3/search_all_leagues.php?s=${encodeURIComponent(query)}`;
              const leagueResp = await fetch(leagueUrl);
              const leagueData = await leagueResp.json();

              if (leagueData.countrys && leagueData.countrys.length > 0) {
                return {
                  source: 'TheSportsDB',
                  type: 'leagues',
                  results: leagueData.countrys.slice(0, 3).map(l => ({
                    name: l.strLeague,
                    sport: l.strSport,
                    country: l.strCountry
                  }))
                };
              }

              return { error: `По запросу "${query}" ничего не найдено` };
            }

            return {
              source: 'TheSportsDB',
              type: 'teams',
              results: data.teams.slice(0, 3).map(team => ({
                name: team.strTeam,
                sport: team.strSport,
                league: team.strLeague,
                country: team.strCountry,
                stadium: team.strStadium,
                founded: team.intFormedYear
              }))
            };
	          } catch (error) {
	            return { error: `Ошибка Sports API: ${error.message}` };
	          }
	        }
	
	        /**
	         * Web Search (без прокси): агрегирует поиск по открытым источникам
	         */
	        async webSearch(query, limit = 8) {
	          const q = String(query || '').trim();
	          const maxResults = Math.max(1, Math.min(parseInt(limit || 8, 10) || 8, 15));
	          if (!q) return { error: 'Пустой поисковый запрос' };
	
	          const fetchJson = async (url, timeoutMs = 12000, options = {}) => {
	            const controller = new AbortController();
	            const t = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	              const resp = await fetch(url, { ...options, signal: controller.signal });
	              const json = await resp.json();
	              return { ok: resp.ok, status: resp.status, json };
	            } finally {
	              clearTimeout(t);
	            }
	          };
	
	          const fetchText = async (url, timeoutMs = 12000, options = {}) => {
	            const controller = new AbortController();
	            const t = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	              const resp = await fetch(url, { ...options, signal: controller.signal });
	              const text = await resp.text();
	              return { ok: resp.ok, status: resp.status, text };
	            } finally {
	              clearTimeout(t);
	            }
	          };
	
	          const results = [];
	          const errors = [];
	
	          // Wikipedia (RU)
	          try {
	            const url = `https://ru.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(q)}&limit=5&namespace=0&format=json&origin=*`;
	            const r = await fetchJson(url);
	            const titles = Array.isArray(r.json?.[1]) ? r.json[1] : [];
	            const descs = Array.isArray(r.json?.[2]) ? r.json[2] : [];
	            const links = Array.isArray(r.json?.[3]) ? r.json[3] : [];
	            titles.slice(0, 5).forEach((title, i) => {
	              results.push({
	                source: 'Wikipedia',
	                title,
	                url: links[i],
	                snippet: descs[i] || ''
	              });
	            });
	          } catch (e) {
	            errors.push(`Wikipedia: ${e.message || e}`);
	          }
	
	          // OpenAlex (papers)
	          try {
	            const url = `https://api.openalex.org/works?search=${encodeURIComponent(q)}&per-page=5`;
	            const r = await fetchJson(url);
	            const works = Array.isArray(r.json?.results) ? r.json.results : [];
	            works.slice(0, 5).forEach(w => {
	              const openAlexId = w?.id ? String(w.id).replace('https://openalex.org/', '') : null;
	              results.push({
	                source: 'OpenAlex',
	                title: w?.title || 'Untitled',
	                url: openAlexId ? `https://openalex.org/${openAlexId}` : (w?.id || ''),
	                snippet: w?.publication_year ? `Year: ${w.publication_year}` : ''
	              });
	            });
	          } catch (e) {
	            errors.push(`OpenAlex: ${e.message || e}`);
	          }
	
	          // arXiv
	          try {
	            const aq = q.replace(/\s+/g, '+');
	            const url = `https://export.arxiv.org/api/query?search_query=all:${encodeURIComponent(aq)}&start=0&max_results=5`;
	            const r = await fetchText(url);
	            if (r.ok) {
	              const xml = new DOMParser().parseFromString(r.text, 'text/xml');
	              const entries = Array.from(xml.getElementsByTagName('entry')).slice(0, 5);
	              entries.forEach(entry => {
	                const title = entry.getElementsByTagName('title')[0]?.textContent?.trim() || 'Untitled';
	                const summary = entry.getElementsByTagName('summary')[0]?.textContent?.trim() || '';
	                const id = entry.getElementsByTagName('id')[0]?.textContent?.trim() || '';
	                results.push({
	                  source: 'arXiv',
	                  title,
	                  url: id,
	                  snippet: summary.slice(0, 220)
	                });
	              });
	            }
	          } catch (e) {
	            errors.push(`arXiv: ${e.message || e}`);
	          }
	
	          // StackOverflow
	          try {
	            const url = `https://api.stackexchange.com/2.3/search/advanced?order=desc&sort=relevance&q=${encodeURIComponent(q)}&site=stackoverflow&pagesize=5`;
	            const r = await fetchJson(url);
	            const items = Array.isArray(r.json?.items) ? r.json.items : [];
	            items.slice(0, 5).forEach(it => {
	              results.push({
	                source: 'StackOverflow',
	                title: it?.title || 'Untitled',
	                url: it?.link || '',
	                snippet: `Score: ${it?.score ?? 0}, Answers: ${it?.answer_count ?? 0}`
	              });
	            });
	          } catch (e) {
	            errors.push(`StackOverflow: ${e.message || e}`);
	          }
	
	          // GitHub repos
	          try {
	            const url = `https://api.github.com/search/repositories?q=${encodeURIComponent(q)}&per_page=5`;
	            const r = await fetchJson(url, 12000, {
	              headers: { Accept: 'application/vnd.github+json' }
	            });
	            const items = Array.isArray(r.json?.items) ? r.json.items : [];
	            items.slice(0, 5).forEach(it => {
	              results.push({
	                source: 'GitHub',
	                title: it?.full_name || it?.name || 'repo',
	                url: it?.html_url || '',
	                snippet: it?.description || ''
	              });
	            });
	          } catch (e) {
	            errors.push(`GitHub: ${e.message || e}`);
	          }
	
	          // Hacker News (Algolia)
	          try {
	            const url = `https://hn.algolia.com/api/v1/search?query=${encodeURIComponent(q)}&tags=story&hitsPerPage=5`;
	            const r = await fetchJson(url);
	            const hits = Array.isArray(r.json?.hits) ? r.json.hits : [];
	            hits.slice(0, 5).forEach(h => {
	              const hnUrl = h?.objectID ? `https://news.ycombinator.com/item?id=${h.objectID}` : '';
	              results.push({
	                source: 'HackerNews',
	                title: h?.title || 'Untitled',
	                url: hnUrl,
	                snippet: `Points: ${h?.points ?? 0}, Author: ${h?.author || 'N/A'}`
	              });
	            });
	          } catch (e) {
	            errors.push(`HackerNews: ${e.message || e}`);
	          }
	
	          // Убираем пустые URL и режем общий лимит
	          const filtered = results.filter(r => r.url).slice(0, maxResults);
	
	          const out = {
	            source: 'WebSearch',
	            query: q,
	            results: filtered
	          };
	          if (errors.length > 0) out.warnings = errors.slice(0, 5);
	          return out;
	        }
	
	        /**
	         * Open URL (без прокси): пытается получить текст для известных источников
	         */
	        async openUrl(url, maxChars = 8000) {
	          const target = String(url || '').trim();
	          const limit = Math.max(500, Math.min(parseInt(maxChars || 8000, 10) || 8000, 20000));
	          if (!target) return { error: 'Пустой URL' };
	
	          const fetchJson = async (u, timeoutMs = 15000, options = {}) => {
	            const controller = new AbortController();
	            const t = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	              const resp = await fetch(u, { ...options, signal: controller.signal });
	              const json = await resp.json();
	              return { ok: resp.ok, status: resp.status, json };
	            } finally {
	              clearTimeout(t);
	            }
	          };
	
	          const fetchText = async (u, timeoutMs = 15000, options = {}) => {
	            const controller = new AbortController();
	            const t = setTimeout(() => controller.abort(), timeoutMs);
	            try {
	              const resp = await fetch(u, { ...options, signal: controller.signal });
	              const text = await resp.text();
	              return { ok: resp.ok, status: resp.status, text, contentType: resp.headers.get('content-type') || '' };
	            } finally {
	              clearTimeout(t);
	            }
	          };
	
	          const htmlToText = (html) => {
	            const doc = new DOMParser().parseFromString(html, 'text/html');
	            doc.querySelectorAll('script,style,noscript').forEach(n => n.remove());
	            const text = (doc.body?.innerText || doc.documentElement?.textContent || '').trim();
	            return text.replace(/\n{3,}/g, '\n\n').slice(0, limit);
	          };
	
	          let parsed;
	          try {
	            parsed = new URL(target);
	          } catch {
	            return { error: `Некорректный URL: ${target}` };
	          }
	
	          // Wikipedia: читаем через API (explaintext)
	          if (/wikipedia\.org$/i.test(parsed.hostname)) {
	            const title = decodeURIComponent(parsed.pathname.replace(/^\/wiki\//, '')).replace(/_/g, ' ');
	            const api = `https://${parsed.hostname}/w/api.php?action=query&prop=extracts&explaintext=1&exsectionformat=plain&format=json&origin=*&redirects=1&titles=${encodeURIComponent(title)}`;
	            const r = await fetchJson(api);
	            const pages = r.json?.query?.pages || {};
	            const pageId = Object.keys(pages)[0];
	            const page = pages?.[pageId] || {};
	            if (pageId === '-1' || !page?.extract) {
	              return { error: 'Статья не найдена или недоступна', url: target };
	            }
	            return {
	              source: 'Wikipedia',
	              url: target,
	              title: page.title,
	              text: String(page.extract).slice(0, limit)
	            };
	          }
	
	          // OpenAlex: https://openalex.org/W...
	          if (/openalex\.org$/i.test(parsed.hostname)) {
	            const id = parsed.pathname.replace(/^\//, '');
	            const api = `https://api.openalex.org/works/${encodeURIComponent(id)}`;
	            const r = await fetchJson(api);
	            if (!r.ok) return { error: `OpenAlex недоступен (${r.status})`, url: target };
	            const w = r.json || {};
	            return {
	              source: 'OpenAlex',
	              url: target,
	              title: w.title || 'Untitled',
	              year: w.publication_year || null,
	              text: (w.abstract_inverted_index ? 'Abstract available (inverted index).' : 'No abstract available.'),
	              primary_location: w.primary_location?.landing_page_url || null
	            };
	          }
	
	          // arXiv: abs link -> export API by id
	          if (/arxiv\.org$/i.test(parsed.hostname) && parsed.pathname.startsWith('/abs/')) {
	            const arxivId = parsed.pathname.replace('/abs/', '').trim();
	            const api = `https://export.arxiv.org/api/query?id_list=${encodeURIComponent(arxivId)}`;
	            const r = await fetchText(api);
	            if (!r.ok) return { error: `arXiv недоступен (${r.status})`, url: target };
	            const xml = new DOMParser().parseFromString(r.text, 'text/xml');
	            const entry = xml.getElementsByTagName('entry')[0];
	            if (!entry) return { error: 'arXiv: запись не найдена', url: target };
	            const title = entry.getElementsByTagName('title')[0]?.textContent?.trim() || 'Untitled';
	            const summary = entry.getElementsByTagName('summary')[0]?.textContent?.trim() || '';
	            return {
	              source: 'arXiv',
	              url: target,
	              title,
	              text: summary.slice(0, limit)
	            };
	          }
	
	          // StackOverflow question -> StackExchange API with body
	          if (/stackoverflow\.com$/i.test(parsed.hostname) && /^\/questions\/\d+/.test(parsed.pathname)) {
	            const m = parsed.pathname.match(/^\/questions\/(\d+)/);
	            const qid = m ? m[1] : null;
	            if (!qid) return { error: 'StackOverflow: не удалось извлечь id вопроса', url: target };
	            const api = `https://api.stackexchange.com/2.3/questions/${qid}?site=stackoverflow&filter=withbody`;
	            const r = await fetchJson(api);
	            const item = Array.isArray(r.json?.items) ? r.json.items[0] : null;
	            if (!r.ok || !item) return { error: `StackOverflow недоступен (${r.status})`, url: target };
	            return {
	              source: 'StackOverflow',
	              url: target,
	              title: item.title || 'Untitled',
	              text: htmlToText(item.body || '').slice(0, limit)
	            };
	          }
	
	          // GitHub repo -> README через API
	          if (/github\.com$/i.test(parsed.hostname)) {
	            const parts = parsed.pathname.split('/').filter(Boolean);
	            if (parts.length >= 2) {
	              const owner = parts[0];
	              const repo = parts[1];
	              const api = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/readme`;
	              const r = await fetchText(api, 15000, {
	                headers: { Accept: 'application/vnd.github.raw+json' }
	              });
	              if (r.ok) {
	                return {
	                  source: 'GitHub',
	                  url: target,
	                  title: `${owner}/${repo} README`,
	                  text: r.text.slice(0, limit)
	                };
	              }
	            }
	          }
	
	          // Hacker News item -> Algolia items API
	          if (/news\.ycombinator\.com$/i.test(parsed.hostname) && parsed.searchParams.get('id')) {
	            const id = parsed.searchParams.get('id');
	            const api = `https://hn.algolia.com/api/v1/items/${encodeURIComponent(id)}`;
	            const r = await fetchJson(api);
	            if (!r.ok) return { error: `HackerNews недоступен (${r.status})`, url: target };
	            const title = r.json?.title || 'Untitled';
	            const points = r.json?.points ?? null;
	            const text = (r.json?.text || '').replace(/<[^>]+>/g, '').trim();
	            return {
	              source: 'HackerNews',
	              url: target,
	              title,
	              points,
	              text: text.slice(0, limit)
	            };
	          }
	
	          // Generic попытка (может упасть на CORS)
	          try {
	            const r = await fetchText(target);
	            if (!r.ok) return { error: `URL недоступен (${r.status})`, url: target };
	            const isHtml = /text\/html/i.test(r.contentType);
	            const text = isHtml ? htmlToText(r.text) : String(r.text).slice(0, limit);
	            return { source: 'open_url', url: target, text };
	          } catch (e) {
	            return {
	              error:
	                'Браузер не смог прочитать страницу (скорее всего CORS). ' +
	                'Без прокси можно открывать только некоторые источники. Откройте ссылку в новой вкладке и при необходимости вставьте текст сюда.',
	              url: target
	            };
	          }
	        }

	        /**
	         * Форматирование результата для отображения
	         */
	        formatToolResult(toolName, result) {
          if (result.error) {
            return `⚠️ ${result.error}`;
          }

          let formatted = `📊 **${result.source || toolName}**\n\n`;

          // Рекурсивное форматирование объекта
          const formatObject = (obj, indent = 0) => {
            let str = '';
            for (const [key, value] of Object.entries(obj)) {
              if (key === 'source') continue;
              const prefix = '  '.repeat(indent);
              if (typeof value === 'object' && value !== null) {
                if (Array.isArray(value)) {
                  str += `${prefix}**${key}:**\n`;
                  value.forEach((item, i) => {
                    if (typeof item === 'object') {
                      str += `${prefix}  ${i + 1}. ${formatObject(item, indent + 2)}\n`;
                    } else {
                      str += `${prefix}  - ${item}\n`;
                    }
                  });
                } else {
                  str += `${prefix}**${key}:** ${formatObject(value, indent + 1)}\n`;
                }
              } else {
                str += `${prefix}• ${key}: ${value}\n`;
              }
            }
            return str;
          };

          formatted += formatObject(result);
          return formatted;
        }
      }

      // Глобальный экземпляр ToolManager
      window.toolManager = new ToolManager();

      /**
       * ChatHistoryManager - Менеджер истории чатов с хранением в localStorage
       */
      class ChatHistoryManager {
        constructor() {
          this.STORAGE_KEY = 'webllm_chat_history';
          this.currentChatId = null;
          this.chats = this.loadChats();
        }

        /**
         * Загрузка чатов из localStorage
         */
        loadChats() {
          try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            return stored ? JSON.parse(stored) : [];
          } catch (e) {
            console.error('Ошибка загрузки истории чатов:', e);
            return [];
          }
        }

        /**
         * Сохранение чатов в localStorage
         */
        saveChats() {
          try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.chats));
          } catch (e) {
            console.error('Ошибка сохранения истории чатов:', e);
          }
        }

        /**
         * Создание нового чата
         */
        createNewChat() {
          const chatId = 'chat_' + Date.now();
          const chat = {
            id: chatId,
            title: 'Новый чат',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            messages: []
          };
          this.chats.unshift(chat);
          this.currentChatId = chatId;
          this.saveChats();
          return chat;
        }

        /**
         * Получение текущего чата
         */
        getCurrentChat() {
          if (!this.currentChatId) {
            return this.createNewChat();
          }
          const chat = this.chats.find(c => c.id === this.currentChatId);
          if (!chat) {
            return this.createNewChat();
          }
          return chat;
        }

        /**
         * Переключение на чат
         */
        switchToChat(chatId) {
          const chat = this.chats.find(c => c.id === chatId);
          if (chat) {
            this.currentChatId = chatId;
            return chat;
          }
          return null;
        }

        /**
         * Добавление сообщения в текущий чат
         */
        addMessage(role, content) {
          const chat = this.getCurrentChat();
          const message = {
            role,
            content,
            timestamp: new Date().toISOString()
          };
          chat.messages.push(message);
          chat.updatedAt = new Date().toISOString();

          // Обновляем название чата по первому сообщению пользователя
          if (role === 'user' && chat.messages.filter(m => m.role === 'user').length === 1) {
            chat.title = content.substring(0, 40) + (content.length > 40 ? '...' : '');
          }

          // Перемещаем чат в начало списка
          const index = this.chats.findIndex(c => c.id === chat.id);
          if (index > 0) {
            this.chats.splice(index, 1);
            this.chats.unshift(chat);
          }

          this.saveChats();
          return message;
        }

        /**
         * Удаление чата
         */
        deleteChat(chatId) {
          const index = this.chats.findIndex(c => c.id === chatId);
          if (index !== -1) {
            this.chats.splice(index, 1);
            this.saveChats();

            // Если удалили текущий чат, переключаемся на первый или создаём новый
            if (this.currentChatId === chatId) {
              if (this.chats.length > 0) {
                this.currentChatId = this.chats[0].id;
              } else {
                this.createNewChat();
              }
            }
            return true;
          }
          return false;
        }

        /**
         * Очистка всех чатов
         */
        clearAllChats() {
          this.chats = [];
          this.currentChatId = null;
          this.saveChats();
          this.createNewChat();
        }

        /**
         * Очистка текущего чата (только сообщения)
         */
        clearCurrentChat() {
          const chat = this.getCurrentChat();
          chat.messages = [];
          chat.title = 'Новый чат';
          chat.updatedAt = new Date().toISOString();
          this.saveChats();
        }

        /**
         * Получение списка чатов для отображения
         */
        getChatList() {
          return this.chats.map(chat => ({
            id: chat.id,
            title: chat.title,
            updatedAt: chat.updatedAt,
            messageCount: chat.messages.length,
            isActive: chat.id === this.currentChatId
          }));
        }

        /**
         * Получение сообщений текущего чата
         */
        getCurrentMessages() {
          const chat = this.getCurrentChat();
          return chat.messages;
        }
      }

      // Глобальный экземпляр ChatHistoryManager
      window.chatHistoryManager = new ChatHistoryManager();

      // WebLLM Chat Application
      // Импорт WebLLM
      import * as webllm from 'https://esm.run/@mlc-ai/web-llm';

	      class WebLLMChat {
	        constructor() {
	          this.engine = null;
	          this.isModelLoading = false;
	          this.currentModel = null;
	          this.conversationHistory = [];
	          this.selectedModelId = 'qwen-3-4b'; // По умолчанию выбираем Qwen 4B (лучшая модель)
	          this.lastLoadError = null;
	          this.streamingEnabled = true;

	          this.initializeElements();
	          this.setupEventListeners();
	          this.initializeModels();
	          this.applyPlatformDefaults();
	          this.checkWebGPUSupport();
	        }
	
	        getPlatformInfo() {
	          const ua = navigator.userAgent || '';
	          const isAppleMobile =
	            /iPad|iPhone|iPod/i.test(ua) ||
	            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
	          const isSafari = /safari/i.test(ua) && !/chrome|crios|edg|fxios/i.test(ua);
	          return { isAppleMobile, isSafari, ua };
	        }
	
	        parseGB(text) {
	          const m = String(text || '').match(/([\d.]+)\s*GB/i);
	          return m ? Number(m[1]) : null;
	        }
	
	        applyPlatformDefaults() {
	          const { isAppleMobile } = this.getPlatformInfo();
	          if (!isAppleMobile) return;
	
	          // На iPad/iPhone большие модели часто не помещаются в память.
	          // Выбираем лёгкую модель по умолчанию, если она есть.
	          const lightId = 'smollm2-1.7b';
	          const lightOption = document.querySelector(`[data-model="${lightId}"]`);
	          if (lightOption) {
	            this.selectModel(lightOption);
	          }
	        }

        initializeElements() {
          this.modelDropdown = document.querySelector('.model-dropdown');
          this.modelDropdownButton = document.querySelector('.model-dropdown-button');
          this.modelDropdownContent = document.querySelector('.model-dropdown-content');
          this.modelOptions = document.querySelectorAll('.model-option');

          this.statusIndicator = document.getElementById('statusIndicator');
          this.progressContainer = document.getElementById('progressContainer');
          this.progressFill = document.getElementById('progressFill');
          this.progressText = document.getElementById('progressText');

          this.chatMessages = document.getElementById('chatMessages');
          this.welcomeMessage = document.getElementById('welcomeMessage');
          this.typingIndicator = document.getElementById('typingIndicator');
          this.chatInput = document.getElementById('chatInput');
          this.sendButton = document.getElementById('sendButton');

          this.loadModelBtn = document.getElementById('loadModelBtn');
          this.clearChatBtn = document.getElementById('clearChatBtn');

          this.temperatureSlider = document.getElementById('temperature');
          this.temperatureValue = document.getElementById('temperatureValue');
          this.maxTokensSlider = document.getElementById('maxTokens');
          this.maxTokensValue = document.getElementById('maxTokensValue');
          this.systemPrompt = document.getElementById('systemPrompt');
        }

        setupEventListeners() {
          // Model dropdown event listeners
          this.modelDropdownButton.addEventListener('click', () =>
            this.toggleDropdown()
          );
          this.modelOptions.forEach(option => {
            option.addEventListener('click', () => this.selectModel(option));
          });

          // Закрываем dropdown при клике вне его
          document.addEventListener('click', e => {
            if (!this.modelDropdown.contains(e.target)) {
              this.modelDropdownContent.style.display = 'none';
            }
          });

          this.sendButton.addEventListener('click', () => this.sendMessage());
          this.chatInput.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              this.sendMessage();
            }
          });

          this.temperatureSlider.addEventListener('input', e => {
            this.temperatureValue.textContent = e.target.value;
          });

          this.maxTokensSlider.addEventListener('input', e => {
            this.maxTokensValue.textContent = e.target.value;
          });

          // Автоматическое изменение размера текстового поля
          this.chatInput.addEventListener('input', () => {
            this.chatInput.style.height = 'auto';
            this.chatInput.style.height =
              Math.min(this.chatInput.scrollHeight, 150) + 'px';
          });
        }

        initializeModels() {
          this.models = {
            'qwen-3-4b': {
              id: 'Qwen2.5-3B-Instruct-q4f16_1-MLC',
              name: 'Qwen-3-4B-Instruct',
              description:
                'Лучшая компактная модель от Alibaba. Отличное качество при небольшом размере.',
              size: '2.0GB',
              vramRequired: '3GB',
              speed: 'Очень быстрая',
              quality: 'Очень высокое',
              recommended: true,
              toolUse: true,
            },
            'qwen-3-8b': {
              id: 'Qwen2.5-7B-Instruct-q4f16_1-MLC',
              name: 'Qwen-3-8B-Instruct',
              description:
                'Многоязычная модель от Alibaba с отличным пониманием контекста.',
              size: '4.5GB',
              vramRequired: '6GB',
              speed: 'Быстрая',
              quality: 'Очень высокое',
              toolUse: true,
            },
            'llama-3-8b': {
              id: 'Llama-3-8B-Instruct-q4f32_1-MLC',
              name: 'Llama-3-8B-Instruct',
              description:
                'Мощная модель от Meta. Отличное качество ответов и понимание контекста.',
              size: '4.3GB',
              vramRequired: '6GB',
              speed: 'Средняя',
              quality: 'Высокое',
              toolUse: true,
            },
            'mistral-7b': {
              id: 'Mistral-7B-Instruct-v0.3-q4f16_1-MLC',
              name: 'Mistral-7B-Instruct',
              description:
                'Быстрая и эффективная модель от Mistral AI. Хороший баланс скорости и качества.',
              size: '3.8GB',
              vramRequired: '5GB',
              speed: 'Быстрая',
              quality: 'Высокое',
              toolUse: true,
            },
            'phi-3-mini': {
              id: 'Phi-3-mini-4k-instruct-q4f16_1-MLC',
              name: 'Phi-3-Mini-4K',
              description:
                'Компактная модель от Microsoft. Идеальна для быстрых ответов и небольших задач.',
              size: '2.2GB',
              vramRequired: '3GB',
              speed: 'Очень быстрая',
              quality: 'Среднее',
              toolUse: false,
            },
            'gemma-3n-4b': {
              id: 'gemma-2-2b-it-q4f16_1-MLC',
              name: 'Gemma-3n-4B-Instruct',
              description:
                'Компактная модель Google с адаптивной активацией параметров. Поддержка 140+ языков.',
              size: '2.5GB',
              vramRequired: '3.5GB',
              speed: 'Быстрая',
              quality: 'Высокое',
              toolUse: true,
            },
            'smollm2-1.7b': {
              id: 'SmolLM2-1.7B-Instruct-q4f16_1-MLC',
              name: 'SmolLM2-1.7B',
              description:
                'Ультра-компактная модель. Минимальные требования к памяти.',
              size: '1.0GB',
              vramRequired: '2GB',
              speed: 'Мгновенная',
              quality: 'Базовое',
              toolUse: false,
            },
            demo: {
              id: null,
              name: 'Демо-режим',
              description:
                'Демонстрационный режим без загрузки модели. Имитирует ответы ИИ.',
              size: '0MB',
              vramRequired: '0GB',
              speed: 'Мгновенная',
              quality: 'Демо',
              toolUse: false,
            },
          };

          // Показываем информацию о модели по умолчанию
          this.handleModelChange();
        }

	        async checkWebGPUSupport() {
	          try {
	            if (!navigator.gpu) {
	              const { isAppleMobile } = this.getPlatformInfo();
	              this.setStatus(
	                'error',
	                isAppleMobile
	                  ? 'WebGPU не поддерживается на этом iPad/iPhone. Для WebLLM нужен Safari с WebGPU (зависит от версии iPadOS).'
	                  : 'WebGPU не поддерживается. Используйте Chrome/Edge с включенным WebGPU.'
	              );
	              return;
	            }

	            const adapter = await navigator.gpu.requestAdapter();
	            if (!adapter) {
              this.setStatus(
                'error',
                'WebGPU адаптер недоступен. Проверьте GPU драйверы.'
	              );
	              return;
	            }

	            // Доп. проверка, что устройство реально выдаёт device
	            try {
	              const device = await adapter.requestDevice();
	              device?.destroy?.();
	            } catch (e) {
	              this.setStatus('error', `WebGPU device недоступен: ${e.message || e}`);
	              return;
	            }
	
	            const { isAppleMobile } = this.getPlatformInfo();
	            this.setStatus(
	              'ready',
	              isAppleMobile
	                ? 'WebGPU готов! На iPad выбирайте лёгкие модели (например, SmolLM2-1.7B).'
	                : 'WebGPU готов! Выберите модель для начала.'
	            );
	          } catch (error) {
	            this.setStatus('error', `Ошибка WebGPU: ${error.message}`);
	          }
	        }

        toggleDropdown() {
          this.modelDropdownContent.style.display =
            this.modelDropdownContent.style.display === 'block' ? 'none' : 'block';
        }

        selectModel(option) {
          const modelId = option.dataset.model;
          this.selectedModelId = modelId;

          // Обновляем кнопку dropdown - ищем span в model-option-header
          const modelName = option.querySelector(
            '.model-option-header span'
          ).textContent;
          this.modelDropdownButton.innerHTML = `
          <span>${modelName}</span>
          <i class="fas fa-chevron-down"></i>
        `;

          // Убираем selected класс у всех опций
          this.modelOptions.forEach(opt => opt.classList.remove('selected'));
          // Добавляем selected класс к выбранной опции
          option.classList.add('selected');

          // Закрываем dropdown
          this.modelDropdownContent.style.display = 'none';

          // Обновляем статус и устанавливаем currentModel
          const model = this.models[modelId];
          if (model) {
            this.setStatus('ready', `Модель ${model.name} выбрана`);
            this.currentModel = modelId;
          } else if (modelId === 'demo') {
            this.setStatus('ready', 'Демо-режим выбран');
            this.currentModel = 'demo';
          }

          console.log(`Выбрана модель: ${modelName}`);
        }

        handleModelChange() {
          // Этот метод больше не используется с новым dropdown
          // Оставляем для совместимости
        }

	        async loadSelectedModel() {
	          const modelId = this.selectedModelId || 'demo';
	          const model = this.models[modelId];

          if (!model) return;

          if (modelId === 'demo') {
            this.currentModel = 'demo';
            this.setStatus('ready', 'Демо-режим активирован. Можете начать общение!');
            this.enableChat();
            return;
          }

	          if (this.isModelLoading) return;
	
	          // Предупреждение для iPad/iPhone по большим моделям
	          const { isAppleMobile } = this.getPlatformInfo();
	          if (isAppleMobile) {
	            const vramGB = this.parseGB(model.vramRequired);
	            if (vramGB !== null && vramGB >= 5) {
	              const proceed = confirm(
	                `Модель требует примерно ${model.vramRequired} памяти и часто не загружается на iPad/iPhone.\n\nПопробовать всё равно?`
	              );
	              if (!proceed) {
	                const lightOption = document.querySelector('[data-model="smollm2-1.7b"]');
	                if (lightOption) {
	                  this.selectModel(lightOption);
	                  this.setStatus('ready', 'Выбрана лёгкая модель. Нажмите «Загрузить».');
	                } else {
	                  this.setStatus('ready', 'Выберите более лёгкую модель и нажмите «Загрузить».');
	                }
	                return;
	              }
	            }
	          }

	          try {
	            this.isModelLoading = true;
	            this.loadModelBtn.disabled = true;
	            this.setStatus('loading', `Загружаем ${model.name}...`);
            this.showProgress();

            // Создаем движок WebLLM
            this.engine = new webllm.MLCEngine();

            // Настраиваем прогресс
            this.engine.setInitProgressCallback(progress => {
              this.updateProgress(progress);
            });

            // Загружаем модель
            await this.engine.reload(model.id);

            this.currentModel = modelId;
            this.hideProgress();
            this.setStatus('ready', `${model.name} загружена! Готов к общению.`);
	            this.enableChat();
	          } catch (error) {
	            console.error('Ошибка загрузки модели:', error);
	            this.lastLoadError = error;
	            this.hideProgress();
	
	            const msg = String(error?.message || error || 'Неизвестная ошибка');
	            const isOOM = /out of memory|oom|memory|allocation|exceeded|device lost|lost/i.test(msg.toLowerCase());
	            const isQuota =
	              String(error?.name || '').toLowerCase().includes('quota') ||
	              /quota|quotaexceeded|exceeded the quota|not enough storage|storage/i.test(msg.toLowerCase());
	            const { isAppleMobile } = this.getPlatformInfo();
	            const hint = isQuota
	              ? ' Похоже, браузеру не хватает места для кеша модели. Очистите данные сайта для этой страницы в Safari или выберите меньшую модель.'
	              : isAppleMobile
	                ? ' На iPad/iPhone часто не хватает памяти для 7B/8B — попробуйте SmolLM2-1.7B.'
	                : '';
	            this.setStatus('error', `Ошибка загрузки: ${msg}${hint}`);

	            // При OOM пробуем предложить лёгкую модель, иначе демо-режим
	            setTimeout(() => {
	              const lightOption = document.querySelector('[data-model="smollm2-1.7b"]');
	              if ((isOOM || isQuota) && navigator.gpu && lightOption) {
	                // Сбрасываем движок, оставляем чат отключённым до успешной загрузки
	                this.engine = null;
	                this.currentModel = null;
	                this.selectedModelId = 'smollm2-1.7b';
	                this.selectModel(lightOption);
	                this.setStatus('ready', 'Выбрана лёгкая модель. Нажмите «Загрузить».');
	              } else {
	                this.selectedModelId = 'demo';
	                this.currentModel = 'demo';
	                // Обновляем UI dropdown
	                const demoOption = document.querySelector('[data-model="demo"]');
	                if (demoOption) {
	                  this.selectModel(demoOption);
	                }
	                this.setStatus('ready', 'Демо-режим активирован из-за ошибки загрузки');
	                this.enableChat();
	              }
	            }, 3000);
	          } finally {
	            this.isModelLoading = false;
	            this.loadModelBtn.disabled = false;
	          }
	        }

        setStatus(type, message) {
          const icon = {
            loading: 'fas fa-circle-notch fa-spin',
            ready: 'fas fa-check-circle',
            error: 'fas fa-exclamation-triangle',
          };

          this.statusIndicator.className = `status-indicator status-${type}`;
          this.statusIndicator.innerHTML = `<i class="${icon[type]}"></i><span>${message}</span>`;

          // Обновляем статус в header
          if (window.updateHeaderModelStatus) {
            const modelName = this.currentModel && this.models[this.currentModel]
              ? this.models[this.currentModel].name
              : 'WebLLM Chat';
            window.updateHeaderModelStatus(modelName, type === 'ready');
          }
        }

        showProgress() {
          this.progressContainer.classList.add('show');
          this.progressFill.style.width = '0%';
        }

        hideProgress() {
          this.progressContainer.classList.remove('show');
        }

        updateProgress(progress) {
          if (progress.progress !== undefined) {
            const percentage = Math.round(progress.progress * 100);
            this.progressFill.style.width = `${percentage}%`;
            this.progressText.textContent = `${progress.text || 'Загрузка модели'} - ${percentage}%`;
          } else {
            this.progressText.textContent = progress.text || 'Загрузка модели...';
          }
        }

        enableChat() {
          this.chatInput.disabled = false;
          this.sendButton.disabled = false;
          this.welcomeMessage.style.display = 'none';
        }

	        async sendMessage() {
	          const message = this.chatInput.value.trim();
	          if (!message || !this.currentModel) return;

          // Добавляем сообщение пользователя
          this.addMessage('user', message);
          this.chatInput.value = '';
          this.chatInput.style.height = 'auto';

	          // Показываем индикатор печати
	          this.showTypingIndicator();
	          this.sendButton.disabled = true;

	          try {
	            if (this.currentModel === 'demo') {
	              // Демо-режим
	              await this.simulateAIResponse(message);
	            } else {
	              // Реальная модель
	              await this.generateAIResponse(message);
	            }
	          } catch (error) {
            console.error('Ошибка генерации ответа:', error);
            this.addMessage('ai', `Извините, произошла ошибка: ${error.message}`);
	          } finally {
	            this.hideTypingIndicator();
	            this.sendButton.disabled = false;
	          }
	        }
	
	        createStreamingMessage(role, saveToHistory = true) {
	          const messageDiv = document.createElement('div');
	          messageDiv.className = `message ${role}`;
	
	          const avatar = document.createElement('div');
	          avatar.className = 'message-avatar';
	
	          if (role === 'user') {
	            avatar.innerHTML = '<i class="fas fa-user"></i>';
	          } else if (role === 'system') {
	            avatar.innerHTML = '<i class="fas fa-cog"></i>';
	            messageDiv.classList.add('system-message');
	          } else if (role === 'tool-call') {
	            avatar.innerHTML = '<i class="fas fa-wrench"></i>';
	            messageDiv.classList.add('tool-call');
	          } else if (role === 'tool-result') {
	            avatar.innerHTML = '<i class="fas fa-database"></i>';
	            messageDiv.classList.add('tool-result');
	          } else {
	            avatar.innerHTML = '<i class="fas fa-robot"></i>';
	          }
	
	          const messageContent = document.createElement('div');
	          messageContent.className = 'message-content';
	
	          messageDiv.appendChild(avatar);
	          messageDiv.appendChild(messageContent);
	
	          this.chatMessages.appendChild(messageDiv);
	          this.scrollToBottom();
	
	          let raw = '';
	          const update = (delta) => {
	            raw += String(delta || '');
	            messageContent.innerHTML = this.formatMessage(raw);
	            this.scrollToBottom();
	          };
	
	          const set = (text) => {
	            raw = String(text || '');
	            messageContent.innerHTML = this.formatMessage(raw);
	            this.scrollToBottom();
	          };
	
	          const finalize = () => {
	            if (saveToHistory && (role === 'user' || role === 'ai')) {
	              const historyRole = role === 'ai' ? 'assistant' : role;
	              window.chatHistoryManager?.addMessage?.(historyRole, raw);
	              window.renderChatList?.();
	            }
	            return raw;
	          };
	
	          return { update, set, finalize, getText: () => raw, element: messageDiv };
	        }
	
	        async runChatCompletionStream({ messages, temperature, max_tokens }, { onDelta } = {}) {
	          if (!this.streamingEnabled) {
	            const resp = await this.engine.chat.completions.create({
	              messages,
	              temperature,
	              max_tokens
	            });
	            const text = resp?.choices?.[0]?.message?.content ?? '';
	            return String(text || '');
	          }
	
	          let full = '';
	          try {
	            const stream = await this.engine.chat.completions.create({
	              messages,
	              temperature,
	              max_tokens,
	              stream: true
	            });
	
	            if (!stream || typeof stream[Symbol.asyncIterator] !== 'function') {
	              const resp = stream;
	              const text = resp?.choices?.[0]?.message?.content ?? '';
	              return String(text || '');
	            }
	
	            for await (const chunk of stream) {
	              const delta =
	                chunk?.choices?.[0]?.delta?.content ??
	                chunk?.choices?.[0]?.message?.content ??
	                '';
	              if (delta) {
	                full += delta;
	                onDelta?.(delta, full);
	              }
	            }
	            return full;
	          } catch (e) {
	            if (full) return full;
	            throw e;
	          }
	        }

	        async generateAIResponse(userMessage) {
	          // Добавляем сообщение в историю
	          this.conversationHistory.push({
	            role: 'user',
	            content: userMessage,
	          });

          // Создаем системный промпт с инструментами
          let systemPrompt =
            this.systemPrompt.value ||
            'Ты - полезный ИИ-ассистент. Отвечай кратко и по делу.';

          // Добавляем описания инструментов к системному промпту
          const toolsPrompt = window.toolManager.getToolsSystemPrompt();
          systemPrompt += toolsPrompt;

          // Создаем сообщения для модели
          const messages = [
            {
              role: 'system',
              content: systemPrompt,
            },
            ...this.conversationHistory,
          ];

	          // Готовим параметры запроса
	          const requestParams = {
	            messages: messages,
	            temperature: parseFloat(this.temperatureSlider.value),
	            max_tokens: parseInt(this.maxTokensSlider.value),
	          };

	          // Генерируем ответ (stream)
	          let aiResponse = '';
	          let startedAssistantStream = false;
	          let assistantStream = null;
	          let alreadyRendered = false;
	          let firstNonWs = null;
	
	          const collectOnly = (delta, full) => {
	            if (firstNonWs === null) {
	              const m = full.match(/[^\s]/);
	              if (m) firstNonWs = m[0];
	            }
	
	            // Если похоже на tool_call/JSON, не стримим в bubble (чтобы не показывать технический JSON)
	            if (!startedAssistantStream && firstNonWs !== null) {
	              if (firstNonWs !== '{' && firstNonWs !== '<') {
	                assistantStream = this.createStreamingMessage('ai', true);
	                startedAssistantStream = true;
	                alreadyRendered = true;
	                this.hideTypingIndicator();
	              }
	            }
	
	            if (startedAssistantStream) {
	              assistantStream.update(delta);
	            }
	          };
	
	          aiResponse = await this.runChatCompletionStream(requestParams, { onDelta: collectOnly });
	          if (startedAssistantStream) {
	            // выравниваем итоговый текст (на случай, если были chunk-особенности)
	            assistantStream.set(aiResponse);
	          }

	          // Проверяем на вызов инструмента
	          if (window.toolManager.hasToolCall(aiResponse)) {
	            // Если мы начали стримить (и случайно показали текст), заменим его на пустое.
	            if (assistantStream) {
	              assistantStream.element.remove();
	              assistantStream = null;
	              startedAssistantStream = false;
	              alreadyRendered = false;
	            }
	            const toolCall = window.toolManager.extractToolCall(aiResponse);

	            if (toolCall) {
	              // Показываем сообщение о вызове инструмента
	              this.addMessage('tool-call', `🔧 Вызов инструмента: ${toolCall.tool}`);

              // Выполняем вызов инструмента
              const toolResult = await window.toolManager.executeToolCall(toolCall);

              // Показываем результат инструмента
              const formattedResult = window.toolManager.formatToolResult(toolCall.tool, toolResult);
              this.addMessage('tool-result', formattedResult);

              // Добавляем результат в историю и просим модель сформировать ответ
              this.conversationHistory.push({
                role: 'assistant',
                content: aiResponse,
              });
	              this.conversationHistory.push({
	                role: 'user',
	                content: `Результат инструмента ${toolCall.tool}:\n${JSON.stringify(toolResult, null, 2)}\n\nТеперь сформулируй понятный ответ для пользователя на основе этих данных.`,
	              });

	              // Генерируем финальный ответ (stream)
	              const finalMessages = [
	                { role: 'system', content: 'Ты - полезный ИИ-ассистент. Сформулируй ответ на основе полученных данных. Не используй tool_call, просто дай ответ.' },
	                ...this.conversationHistory,
	              ];

	              // Создаем bubble для финального ответа и стримим туда
	              const finalStream = this.createStreamingMessage('ai', true);
	              alreadyRendered = true;
	              this.hideTypingIndicator();
	              aiResponse = await this.runChatCompletionStream(
	                {
	                  messages: finalMessages,
	                  temperature: parseFloat(this.temperatureSlider.value),
	                  max_tokens: parseInt(this.maxTokensSlider.value),
	                },
	                { onDelta: (delta) => finalStream.update(delta) }
	              );
	              finalStream.set(aiResponse);
	              finalStream.finalize();

	              // Удаляем технические сообщения из истории
	              this.conversationHistory.pop();
	              this.conversationHistory.pop();
	            }
	          }

	          // Добавляем ответ в историю
	          this.conversationHistory.push({
	            role: 'assistant',
	            content: aiResponse,
	          });

	          // Показываем ответ (если не стримили ранее)
	          if (!alreadyRendered && !window.toolManager.hasToolCall(aiResponse)) {
	            this.addMessage('ai', aiResponse);
	          } else if (assistantStream && !window.toolManager.hasToolCall(aiResponse)) {
	            assistantStream.finalize();
	          }
	        }

        async simulateAIResponse(userMessage) {
          const lowerMessage = userMessage.toLowerCase();

          // Определяем, какой инструмент использовать
          let toolToUse = null;
          let toolParams = {};

          if (lowerMessage.includes('погод') || lowerMessage.includes('weather')) {
            toolToUse = 'get_weather';
            // Извлекаем город из сообщения
            const cityMatch = userMessage.match(/(?:в|in|город|city)\s+([а-яa-z]+)/i) ||
                              userMessage.match(/погод[аеу]?\s+([а-яa-z]+)/i);
            toolParams = { city: cityMatch ? cityMatch[1] : 'Москва' };
          } else if (lowerMessage.includes('курс') || lowerMessage.includes('валют') || lowerMessage.includes('dollar') || lowerMessage.includes('euro')) {
            toolToUse = 'get_currency_rate';
            toolParams = { from: 'USD', to: 'RUB' };
          } else if (lowerMessage.includes('биткоин') || lowerMessage.includes('bitcoin') || lowerMessage.includes('крипт') || lowerMessage.includes('ethereum')) {
            toolToUse = 'get_crypto_price';
            const coinMatch = lowerMessage.includes('ethereum') ? 'ethereum' : 'bitcoin';
            toolParams = { coin: coinMatch };
          } else if (lowerMessage.includes('музык') || lowerMessage.includes('music') || lowerMessage.includes('артист') || lowerMessage.includes('группа')) {
            toolToUse = 'search_music';
            const queryMatch = userMessage.match(/(?:о|about|про)\s+([^?]+)/i);
            toolParams = { query: queryMatch ? queryMatch[1].trim() : 'Queen', type: 'artist' };
          } else if (lowerMessage.includes('команд') || lowerMessage.includes('team') || lowerMessage.includes('футбол') || lowerMessage.includes('спорт')) {
            toolToUse = 'search_sports';
            const teamMatch = userMessage.match(/(?:о|about|про)\s+([^?]+)/i);
            toolParams = { query: teamMatch ? teamMatch[1].trim() : 'Barcelona' };
          } else if (lowerMessage.includes('что такое') || lowerMessage.includes('кто такой') || lowerMessage.includes('расскажи о') || lowerMessage.includes('wiki')) {
            toolToUse = 'wikipedia_search';
            const wikiMatch = userMessage.match(/(?:что такое|кто такой|расскажи о|о|wiki)\s+([^?]+)/i);
            toolParams = { query: wikiMatch ? wikiMatch[1].trim() : 'Искусственный интеллект' };
          }

          // Если определили инструмент - вызываем его
          if (toolToUse && window.toolManager.enabledTools[this.getToolKey(toolToUse)]) {
            await new Promise(resolve => setTimeout(resolve, 500));

            // Показываем вызов инструмента
            this.addMessage('tool-call', `🔧 Вызов инструмента: ${toolToUse}`);

            // Выполняем реальный вызов API
            const toolResult = await window.toolManager.executeToolCall({
              tool: toolToUse,
              params: toolParams
            });

            // Показываем результат
            const formattedResult = window.toolManager.formatToolResult(toolToUse, toolResult);
            this.addMessage('tool-result', formattedResult);

            await new Promise(resolve => setTimeout(resolve, 500));

            // Формируем ответ на основе результата
            let response;
            if (toolResult.error) {
              response = `К сожалению, не удалось получить данные: ${toolResult.error}. Попробуйте загрузить полную модель для более точных ответов.`;
            } else {
              response = `Вот актуальные данные от ${toolResult.source || 'API'}! В демо-режиме я показываю реальные данные из API, но для полноценного общения рекомендую загрузить модель Qwen или Llama.`;
            }
            this.addMessage('ai', response);
          } else {
            // Стандартные демо-ответы
            await new Promise(resolve =>
              setTimeout(resolve, 1000 + Math.random() * 1000)
            );

            const demoResponses = [
              'Это демо-режим WebLLM Chat с поддержкой Tool Calling! Попробуйте спросить о погоде, курсах валют или криптовалютах.',
              'В демо-режиме вы можете протестировать инструменты: спросите "какая погода в Москве?" или "курс биткоина".',
              'WebLLM позволяет запускать ИИ локально. Попробуйте: "что такое квантовый компьютер?" или "расскажи о группе Queen".',
              'Демо-режим показывает работу API инструментов. Для полного ИИ-общения загрузите модель!',
              'Попробуйте вопросы о погоде, валютах, криптовалютах, музыке или спорте - я покажу реальные данные из API!',
            ];

            const response = demoResponses[Math.floor(Math.random() * demoResponses.length)];
            this.addMessage('ai', response);
          }
        }

        /**
         * Получение ключа инструмента по имени
         */
        getToolKey(toolName) {
          const mapping = {
            'wikipedia_search': 'wikipedia',
            'get_weather': 'weather',
            'get_currency_rate': 'currency',
            'get_crypto_price': 'crypto',
            'search_music': 'music',
            'search_sports': 'sports'
          };
          return mapping[toolName] || toolName;
        }

        addMessage(role, content, saveToHistory = true) {
          const messageDiv = document.createElement('div');
          messageDiv.className = `message ${role}`;

          const avatar = document.createElement('div');
          avatar.className = 'message-avatar';

          // Разные иконки для разных типов сообщений
          if (role === 'user') {
            avatar.innerHTML = '<i class="fas fa-user"></i>';
          } else if (role === 'system') {
            avatar.innerHTML = '<i class="fas fa-cog"></i>';
            messageDiv.classList.add('system-message');
          } else if (role === 'tool-call') {
            avatar.innerHTML = '<i class="fas fa-wrench"></i>';
            messageDiv.classList.add('tool-call');
          } else if (role === 'tool-result') {
            avatar.innerHTML = '<i class="fas fa-database"></i>';
            messageDiv.classList.add('tool-result');
          } else {
            avatar.innerHTML = '<i class="fas fa-robot"></i>';
          }

          const messageContent = document.createElement('div');
          messageContent.className = 'message-content';

          // Обработка markdown-подобного форматирования
          const formattedContent = this.formatMessage(content);
          messageContent.innerHTML = formattedContent;

          messageDiv.appendChild(avatar);
          messageDiv.appendChild(messageContent);

          this.chatMessages.appendChild(messageDiv);
          this.scrollToBottom();

          // Сохраняем сообщение в историю чатов (только user и ai)
          if (saveToHistory && (role === 'user' || role === 'ai')) {
            const historyRole = role === 'ai' ? 'assistant' : role;
            window.chatHistoryManager.addMessage(historyRole, content);
            // Обновляем список чатов
            if (window.renderChatList) {
              window.renderChatList();
            }
          }
        }

	        formatMessage(content) {
	          const escapeHtml = (str) =>
	            String(str)
	              .replace(/&/g, '&amp;')
	              .replace(/</g, '&lt;')
	              .replace(/>/g, '&gt;')
	              .replace(/"/g, '&quot;')
	              .replace(/'/g, '&#39;');
	
	          const stripUrlPunctuation = (url) => {
	            let u = url;
	            let suffix = '';
	            while (u.length > 0 && /[),.;:!?]+$/.test(u)) {
	              suffix = u.slice(-1) + suffix;
	              u = u.slice(0, -1);
	            }
	            return { url: u, suffix };
	          };
	
	          const makeLink = (href, label) =>
	            `<a href="${href}" target="_blank" rel="noopener noreferrer">${label}</a>`;
	
	          let text = String(content ?? '').replace(/\r\n?/g, '\n');
	
	          // 1) Вырезаем code blocks, чтобы не линковать внутри
	          const codeBlocks = [];
	          text = text.replace(/```([\s\S]*?)```/g, (_, code) => {
	            const key = `@@CODEBLOCK_${codeBlocks.length}@@`;
	            codeBlocks.push(code);
	            return key;
	          });
	
	          // 2) Вырезаем inline code, чтобы не линковать внутри
	          const inlineCodes = [];
	          text = text.replace(/`([^`\n]+)`/g, (_, code) => {
	            const key = `@@INLINECODE_${inlineCodes.length}@@`;
	            inlineCodes.push(code);
	            return key;
	          });
	
	          // 3) Экранируем HTML
	          text = escapeHtml(text);
	
	          // 4) Markdown links: [text](https://...)
	          text = text.replace(/\[([^\]]+)\]\((https?:\/\/[^)\s]+)\)/g, (_, label, href) => {
	            const { url, suffix } = stripUrlPunctuation(href);
	            return makeLink(url, label) + suffix;
	          });
	
	          // 5) Авто-линковка голых URL
	          text = text.replace(/(^|[\s>])((https?:\/\/)[^\s<]+)/g, (_, prefix, href) => {
	            const { url, suffix } = stripUrlPunctuation(href);
	            return `${prefix}${makeLink(url, url)}${suffix}`;
	          });
	
	          // 6) Переводы строк
	          text = text.replace(/\n/g, '<br>');
	
	          // 7) Возвращаем inline code
	          text = text.replace(/@@INLINECODE_(\d+)@@/g, (_, i) => `<code>${escapeHtml(inlineCodes[Number(i)] ?? '')}</code>`);
	
	          // 8) Возвращаем code blocks (с сохранением \n внутри <pre>)
	          text = text.replace(/@@CODEBLOCK_(\d+)@@/g, (_, i) => `<pre><code>${escapeHtml(codeBlocks[Number(i)] ?? '')}</code></pre>`);
	
	          return text;
	        }

        showTypingIndicator() {
          this.typingIndicator.classList.add('show');
          this.scrollToBottom();
        }

        hideTypingIndicator() {
          this.typingIndicator.classList.remove('show');
        }

        scrollToBottom() {
          setTimeout(() => {
            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
          }, 100);
        }

        clearChat() {
          this.conversationHistory = [];
          this.chatMessages.innerHTML = '';
          this.chatMessages.appendChild(this.welcomeMessage);
          this.chatMessages.appendChild(this.typingIndicator);
          this.welcomeMessage.style.display = 'block';

          // Очищаем текущий чат в истории
          if (window.chatHistoryManager) {
            window.chatHistoryManager.clearCurrentChat();
          }
          if (window.renderChatList) {
            window.renderChatList();
          }
        }
      }

      // Функции для модального окна системных требований
      window.showRequirements = function () {
        const modal = document.getElementById('requirementsModal');
        modal.classList.add('show');
      };

      window.hideRequirements = function () {
        const modal = document.getElementById('requirementsModal');
        modal.classList.remove('show');
      };

      // Функция для управления аккордеоном
      window.toggleAccordion = function (accordionId) {
        const content = document.getElementById(accordionId);
        const header = content.previousElementSibling;

        if (content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          header.classList.add('active');
        } else {
          content.classList.add('collapsed');
          header.classList.remove('active');
        }
      };

      // Глобальные функции для кнопок
      window.loadSelectedModel = function () {
        window.webLLMChat.loadSelectedModel();
      };

      window.clearChat = function () {
        window.webLLMChat.clearChat();
      };

      window.closeSettingsModal = function () {
        document.getElementById('settingsModal').classList.remove('show');
      };

      // Инициализация приложения
      document.addEventListener('DOMContentLoaded', () => {
        // Инициализируем настройки
        window.aiPagesSettings.init();

        // ==== Элементы интерфейса ====
        const settingsModal = document.getElementById('settingsModal');
        const themeSwitch = document.getElementById('themeSwitch');
        const modelSidebar = document.getElementById('modelSidebar');
        const modelSidebarOverlay = document.getElementById('modelSidebarOverlay');
        const chatHistorySidebar = document.getElementById('chatHistorySidebar');
        const chatList = document.getElementById('chatList');
        const expandSidebarBtn = document.getElementById('expandSidebarBtn');
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const openSettingsBtn = document.getElementById('openSettingsBtn');
        const clearAllChatsBtn = document.getElementById('clearAllChatsBtn');
        const clearCurrentChatBtn = document.getElementById('clearCurrentChatBtn');
        const chatHeaderModel = document.getElementById('chatHeaderModel');
        const closeModelSidebar = document.getElementById('closeModelSidebar');
        const headerModelName = document.getElementById('headerModelName');
        const modelStatusDot = document.getElementById('modelStatusDot');

        // ==== Функции для управления UI ====

        /**
         * Рендеринг списка чатов
         */
        function renderChatList() {
          const chats = window.chatHistoryManager.getChatList();
          chatList.innerHTML = '';

          if (chats.length === 0) {
            chatList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 0.9rem;">Нет сохранённых чатов</div>';
            return;
          }

          chats.forEach(chat => {
            const item = document.createElement('div');
            item.className = `chat-list-item${chat.isActive ? ' active' : ''}`;
            item.dataset.chatId = chat.id;
            item.innerHTML = `
              <i class="fas fa-comment chat-icon"></i>
              <span class="chat-title">${escapeHtml(chat.title)}</span>
              <button class="chat-delete" title="Удалить чат">
                <i class="fas fa-trash"></i>
              </button>
            `;

            // Клик для переключения на чат
            item.addEventListener('click', (e) => {
              if (!e.target.closest('.chat-delete')) {
                switchToChat(chat.id);
              }
            });

            // Клик для удаления чата
            const deleteBtn = item.querySelector('.chat-delete');
            deleteBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              if (confirm('Удалить этот чат?')) {
                window.chatHistoryManager.deleteChat(chat.id);
                renderChatList();
                // Если удалили активный чат, загружаем текущий
                if (chat.isActive) {
                  loadCurrentChatMessages();
                }
              }
            });

            chatList.appendChild(item);
          });
        }

        /**
         * Escape HTML для безопасного рендеринга
         */
        function escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        /**
         * Переключение на чат
         */
        function switchToChat(chatId) {
          window.chatHistoryManager.switchToChat(chatId);
          renderChatList();
          loadCurrentChatMessages();

          // На мобильных закрываем sidebar
          if (window.innerWidth <= 768) {
            chatHistorySidebar.classList.add('collapsed');
            expandSidebarBtn.classList.add('show');
          }
        }

        /**
         * Загрузка сообщений текущего чата
         */
        function loadCurrentChatMessages() {
          const chatMessages = document.getElementById('chatMessages');
          const welcomeMessage = document.getElementById('welcomeMessage');
          const typingIndicator = document.getElementById('typingIndicator');

          // Очищаем сообщения
          chatMessages.innerHTML = '';
          chatMessages.appendChild(welcomeMessage);
          chatMessages.appendChild(typingIndicator);

          // Получаем сообщения текущего чата
          const messages = window.chatHistoryManager.getCurrentMessages();

          if (messages.length === 0) {
            welcomeMessage.style.display = 'block';
          } else {
            welcomeMessage.style.display = 'none';
            messages.forEach(msg => {
              if (msg.role === 'user' || msg.role === 'ai' || msg.role === 'assistant') {
                const role = msg.role === 'assistant' ? 'ai' : msg.role;
                window.webLLMChat.addMessage(role, msg.content, false);
              }
            });
          }

          // Обновляем conversation history в WebLLMChat
          if (window.webLLMChat) {
            window.webLLMChat.conversationHistory = messages
              .filter(m => m.role === 'user' || m.role === 'assistant' || m.role === 'ai')
              .map(m => ({
                role: m.role === 'ai' ? 'assistant' : m.role,
                content: m.content
              }));
          }
        }

        /**
         * Создание нового чата
         */
        function createNewChat() {
          window.chatHistoryManager.createNewChat();
          renderChatList();
          loadCurrentChatMessages();

          // На мобильных закрываем sidebar
          if (window.innerWidth <= 768) {
            chatHistorySidebar.classList.add('collapsed');
            expandSidebarBtn.classList.add('show');
          }
        }

        /**
         * Открытие панели настроек модели
         */
        function openModelSettings() {
          modelSidebar.classList.add('show');
          modelSidebarOverlay.classList.add('show');
        }

        /**
         * Закрытие панели настроек модели
         */
        function closeModelSettings() {
          modelSidebar.classList.remove('show');
          modelSidebarOverlay.classList.remove('show');
        }

        /**
         * Переключение видимости sidebar истории чатов
         */
        function toggleChatHistorySidebar() {
          const isCollapsed = chatHistorySidebar.classList.toggle('collapsed');
          expandSidebarBtn.classList.toggle('show', isCollapsed);
        }

        // ==== Обработчики событий ====

        // Кнопка нового чата
        newChatBtn.addEventListener('click', createNewChat);

        // Кнопка сворачивания sidebar
        toggleSidebarBtn.addEventListener('click', toggleChatHistorySidebar);

        // Кнопка разворачивания sidebar
        expandSidebarBtn.addEventListener('click', toggleChatHistorySidebar);

        // Кнопка открытия настроек модели (в sidebar)
        openSettingsBtn.addEventListener('click', openModelSettings);

        // Кнопка открытия настроек модели (в header)
        chatHeaderModel.addEventListener('click', openModelSettings);

        // Закрытие панели настроек модели
        closeModelSidebar.addEventListener('click', closeModelSettings);
        modelSidebarOverlay.addEventListener('click', closeModelSettings);

        // Очистка текущего чата
        clearCurrentChatBtn.addEventListener('click', () => {
          if (confirm('Очистить текущий чат?')) {
            window.chatHistoryManager.clearCurrentChat();
            loadCurrentChatMessages();
            renderChatList();
          }
        });

        // Очистка всех чатов
        clearAllChatsBtn.addEventListener('click', () => {
          if (confirm('Удалить всю историю чатов?')) {
            window.chatHistoryManager.clearAllChats();
            renderChatList();
            loadCurrentChatMessages();
          }
        });

        // Закрытие модала настроек по клику на фон
        settingsModal.addEventListener('click', (e) => {
          if (e.target === settingsModal) {
            settingsModal.classList.remove('show');
          }
        });

        // Переключение темы
        themeSwitch.addEventListener('change', () => {
          const theme = themeSwitch.checked ? 'dark' : 'light';
          window.aiPagesSettings.set('theme', theme);
        });

        // Закрытие по Escape
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            if (settingsModal.classList.contains('show')) {
              settingsModal.classList.remove('show');
            }
            if (modelSidebar.classList.contains('show')) {
              closeModelSettings();
            }
          }
        });

        // Обработчики для переключения инструментов
        const toolItems = document.querySelectorAll('.tool-item');
        toolItems.forEach(item => {
          const checkbox = item.querySelector('input[type="checkbox"]');
          const toolName = item.dataset.tool;

          // Загружаем сохраненные настройки
          const savedState = localStorage.getItem(`tool_${toolName}`);
          if (savedState !== null) {
            const isEnabled = savedState === 'true';
            checkbox.checked = isEnabled;
            item.classList.toggle('active', isEnabled);
            window.toolManager.enabledTools[toolName] = isEnabled;
          }

          // Обработчик клика
          item.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
              checkbox.checked = !checkbox.checked;
            }

            const isEnabled = checkbox.checked;
            item.classList.toggle('active', isEnabled);
            window.toolManager.enabledTools[toolName] = isEnabled;
            localStorage.setItem(`tool_${toolName}`, isEnabled);

            console.log(`Инструмент ${toolName}: ${isEnabled ? 'включен' : 'выключен'}`);
          });
        });

        // ==== Инициализация WebLLMChat ====
        window.webLLMChat = new WebLLMChat();

        // Обновление статуса модели в header
        window.updateHeaderModelStatus = function(modelName, isReady) {
          headerModelName.textContent = modelName || 'WebLLM Chat';
          modelStatusDot.classList.toggle('ready', isReady);
        };

        // Начальная загрузка списка чатов
        renderChatList();

        // Если есть активный чат, загружаем его сообщения
        if (window.chatHistoryManager.chats.length > 0) {
          loadCurrentChatMessages();
        }

        // Экспортируем функции для использования в WebLLMChat
        window.renderChatList = renderChatList;
        window.loadCurrentChatMessages = loadCurrentChatMessages;

        console.log('🤖 WebLLM Chat готов! Выберите модель и начните общение.');
        console.log('🔧 Tool Calling включен. Доступные инструменты:', Object.keys(window.toolManager.enabledTools).filter(t => window.toolManager.enabledTools[t]));
        console.log('📜 История чатов включена. Чатов сохранено:', window.chatHistoryManager.chats.length);
      });
    </script>
  </body>
</html>
